{"code":"var /* @ngInject */ PermissionService_1;\r\nimport { __decorate, __metadata } from \"tslib\";\r\n/*\r\n * Copyright (c) 2022 SAP SE or an SAP affiliate company. All rights reserved.\r\n */\r\nimport { CrossFrameEventService, EVENT_PERSPECTIVE_CHANGED, EVENTS, GatewayProxied, IPermissionService, LogService, SeDowngradeService, SystemEventService } from 'smarteditcommons';\r\n/**\r\n * The name used to register the default rule.\r\n */\r\nexport const DEFAULT_DEFAULT_RULE_NAME = 'se.permission.service.default.rule';\r\nlet /* @ngInject */ PermissionService = /* @ngInject */ PermissionService_1 = class /* @ngInject */ PermissionService extends IPermissionService {\r\n    constructor(logService, systemEventService, crossFrameEventService) {\r\n        super();\r\n        this.logService = logService;\r\n        this.systemEventService = systemEventService;\r\n        this.crossFrameEventService = crossFrameEventService;\r\n        this._registerEventHandlers();\r\n    }\r\n    static resetForTests() {\r\n        /* @ngInject */ PermissionService_1.rules = [];\r\n        /* @ngInject */ PermissionService_1.permissionsRegistry = [];\r\n        /* @ngInject */ PermissionService_1.cachedResults = {};\r\n    }\r\n    static hasCacheRegion(ruleName) {\r\n        return /* @ngInject */ PermissionService_1.cachedResults.hasOwnProperty(ruleName);\r\n    }\r\n    static getCacheRegion(ruleName) {\r\n        return /* @ngInject */ PermissionService_1.cachedResults[ruleName];\r\n    }\r\n    getPermission(permissionName) {\r\n        return /* @ngInject */ PermissionService_1.permissionsRegistry.find((permission) => permission.aliases.indexOf(permissionName) > -1);\r\n    }\r\n    unregisterDefaultRule() {\r\n        const defaultRule = this._getRule(DEFAULT_DEFAULT_RULE_NAME);\r\n        if (defaultRule) {\r\n            /* @ngInject */ PermissionService_1.rules.splice(/* @ngInject */ PermissionService_1.rules.indexOf(defaultRule), 1);\r\n        }\r\n    }\r\n    registerPermission(permission) {\r\n        this._validatePermission(permission);\r\n        /* @ngInject */ PermissionService_1.permissionsRegistry.push({\r\n            aliases: permission.aliases,\r\n            rules: permission.rules\r\n        });\r\n    }\r\n    hasCachedResult(ruleName, key) {\r\n        return (/* @ngInject */ PermissionService_1.hasCacheRegion(ruleName) &&\r\n            /* @ngInject */ PermissionService_1.getCacheRegion(ruleName).hasOwnProperty(key));\r\n    }\r\n    clearCache() {\r\n        /* @ngInject */ PermissionService_1.cachedResults = {};\r\n        this.crossFrameEventService.publish(EVENTS.PERMISSION_CACHE_CLEANED);\r\n    }\r\n    isPermitted(permissions) {\r\n        const rulePermissionNames = this._mapRuleNameToPermissionNames(permissions);\r\n        const rulePromises = this._getRulePromises(rulePermissionNames);\r\n        const names = Object.keys(rulePromises);\r\n        const promises = names.map((key) => rulePromises[key]);\r\n        const onSuccess = (permissionResults) => {\r\n            const result = names.reduce((acc, name, index) => {\r\n                acc[name] = permissionResults[index];\r\n                return acc;\r\n            }, {});\r\n            this._updateCache(rulePermissionNames, result);\r\n            return true;\r\n        };\r\n        const onError = (result) => {\r\n            if (result === false) {\r\n                return result;\r\n            }\r\n            this.logService.error(result);\r\n            return result === undefined ? false : result;\r\n        };\r\n        return Promise.all(promises).then(onSuccess, onError);\r\n    }\r\n    /**\r\n     * This method adds a promise obtained by calling the pre-configured rule.verify function to the rulePromises\r\n     * map if the result does not exist in the rule's cache. Otherwise, a promise that contains the cached result\r\n     * is added.\r\n     *\r\n     * The promise obtained from the rule.verify function is chained to allow short-circuiting the permission\r\n     * verification process. If a rule resolves with a false result or with an error, the chained promise is\r\n     * rejected to stop the verification process without waiting for all other rules to resolve.\r\n     *\r\n     * @param rulePromises An object that maps rule names to promises.\r\n     * @param rulePermissionNames An object that maps rule names to permission name arrays.\r\n     * @param ruleName The name of the rule to verify.\r\n     */\r\n    _addRulePromise(rulePromises, rulePermissionNames, ruleName) {\r\n        const rule = this._getRule(ruleName);\r\n        const permissionNameObjs = rulePermissionNames[ruleName];\r\n        const cacheKey = this._generateCacheKey(permissionNameObjs);\r\n        let rulePromise;\r\n        if (this.hasCachedResult(ruleName, cacheKey)) {\r\n            rulePromise = Promise.resolve(this._getCachedResult(ruleName, cacheKey));\r\n        }\r\n        else {\r\n            rulePromise = this._callRuleVerify(rule.names.join('-'), permissionNameObjs).then((isPermitted) => isPermitted ? Promise.resolve(true) : Promise.reject(false));\r\n        }\r\n        rulePromises[ruleName] = rulePromise;\r\n    }\r\n    /**\r\n     * This method validates a permission name. Permission names need to be prefixed by at least one\r\n     * namespace followed by a \".\" character to be valid.\r\n     *\r\n     * Example: se.mynamespace is valid.\r\n     * Example: mynamespace is not valid.\r\n     */\r\n    _isPermissionNameValid(permissionName) {\r\n        const checkNameSpace = /^[A-Za-z0-9_\\-]+\\.[A-Za-z0-9_\\-\\.]+/;\r\n        return checkNameSpace.test(permissionName);\r\n    }\r\n    /**\r\n     * This method returns an object that maps rule names to promises.\r\n     */\r\n    _getRulePromises(rulePermissionNames) {\r\n        const rulePromises = {};\r\n        Object.keys(rulePermissionNames).forEach((ruleName) => {\r\n            this._addRulePromise.call(this, rulePromises, rulePermissionNames, ruleName);\r\n        });\r\n        return rulePromises;\r\n    }\r\n    /**\r\n     * This method returns true if a default rule is already registered.\r\n     *\r\n     * @returns true if the default rule has been registered, false otherwise.\r\n     */\r\n    _hasDefaultRule() {\r\n        return !!this._getRule(DEFAULT_DEFAULT_RULE_NAME);\r\n    }\r\n    /**\r\n     * This method returns the rule's cached result for the given key.\r\n     *\r\n     * @param ruleName The name of the rule for which to lookup the cached result.\r\n     * @param key The cached key to lookup..\r\n     *\r\n     * @returns The cached result, if it exists, null otherwise.\r\n     */\r\n    _getCachedResult(ruleName, key) {\r\n        return /* @ngInject */ PermissionService_1.hasCacheRegion(ruleName)\r\n            ? /* @ngInject */ PermissionService_1.getCacheRegion(ruleName)[key]\r\n            : null;\r\n    }\r\n    /**\r\n     * This method generates a key to store a rule's result for a given combination of\r\n     * permissions in its cache. It is done by sorting the list of permissions by name\r\n     * and serializing it.\r\n     *\r\n     * @param permissions A list of permissions with a name and context.\r\n     *\r\n     * [{\r\n     *     name: \"permission.name\"\r\n     *     context: {\r\n     *         key: \"value\"\r\n     *     }\r\n     * }]\r\n     *\r\n     * @returns The serialized sorted list of permissions.\r\n     */\r\n    _generateCacheKey(permissions) {\r\n        return JSON.stringify(permissions.sort((permissionA, permissionB) => {\r\n            const nameA = permissionA.name;\r\n            const nameB = permissionB.name;\r\n            return nameA === nameB ? 0 : nameA < nameB ? -1 : 1;\r\n        }));\r\n    }\r\n    /**\r\n     * This method goes through the permission name arrays associated to rule names to remove any duplicate\r\n     * permission names.\r\n     *\r\n     * If one or more permission names with the same context are found in a rule name's permission name array,\r\n     * only one entry is kept.\r\n     */\r\n    _removeDuplicatePermissionNames(rulePermissionNames) {\r\n        Object.keys(rulePermissionNames).forEach((ruleName) => {\r\n            rulePermissionNames[ruleName] = rulePermissionNames[ruleName].filter((currentPermission) => {\r\n                const existingPermission = rulePermissionNames[ruleName].find((permission) => permission.name === currentPermission.name);\r\n                if (existingPermission === currentPermission) {\r\n                    return true;\r\n                }\r\n                else {\r\n                    const existingPermissionContext = existingPermission.context;\r\n                    const currentPermissionContext = currentPermission.context;\r\n                    return (JSON.stringify(existingPermissionContext) !==\r\n                        JSON.stringify(currentPermissionContext));\r\n                }\r\n            });\r\n        });\r\n    }\r\n    /**\r\n     * This method returns an object mapping rule name to permission name arrays.\r\n     *\r\n     * It will iterate through the given permission name object array to extract the permission names and contexts,\r\n     * populate the map and clean it up by removing duplicate permission name and context pairs.\r\n     */\r\n    _mapRuleNameToPermissionNames(permissions) {\r\n        const rulePermissionNames = {};\r\n        permissions.forEach((permission) => {\r\n            if (!permission.names) {\r\n                throw Error('Requested Permission requires at least one name');\r\n            }\r\n            const permissionNames = permission.names;\r\n            const permissionContext = permission.context;\r\n            permissionNames.forEach((permissionName) => {\r\n                this._populateRulePermissionNames(rulePermissionNames, permissionName, permissionContext);\r\n            });\r\n        });\r\n        this._removeDuplicatePermissionNames(rulePermissionNames);\r\n        return rulePermissionNames;\r\n    }\r\n    /**\r\n     * This method will populate rulePermissionNames with the rules associated to the permission with the given\r\n     * permissionName.\r\n     *\r\n     * If no permission is registered with the given permissionName and a default rule is registered, the default\r\n     * rule is added to rulePermissionNames.\r\n     *\r\n     * If no permission is registered with the given permissionName and no default rule is registered, an error\r\n     * is thrown.\r\n     */\r\n    _populateRulePermissionNames(rulePermissionNames, permissionName, permissionContext) {\r\n        const permission = this.getPermission(permissionName);\r\n        const permissionHasRules = !!permission && !!permission.rules && permission.rules.length > 0;\r\n        if (permissionHasRules) {\r\n            permission.rules.forEach((ruleName) => {\r\n                this._addPermissionName(rulePermissionNames, ruleName, permissionName, permissionContext);\r\n            });\r\n        }\r\n        else if (this._hasDefaultRule()) {\r\n            this._addPermissionName(rulePermissionNames, DEFAULT_DEFAULT_RULE_NAME, permissionName, permissionContext);\r\n        }\r\n        else {\r\n            throw Error('Permission has no rules');\r\n        }\r\n    }\r\n    /**\r\n     * This method will add an object with the permissionName and permissionContext to rulePermissionNames.\r\n     *\r\n     * Since rules can have multiple names, the map will use the first name in the rule's name list as its key.\r\n     * This way, each rule will be called only once for every permission name and context.\r\n     *\r\n     * If the rule associated to a given rule name is already in rulePermissionNames, the permission will be\r\n     * appended to the associated array. Otherwise, the rule name is added to the map and its permission name array\r\n     * is created.\r\n     */\r\n    _addPermissionName(rulePermissionNames, ruleName, permissionName, permissionContext) {\r\n        const rule = this._getRule(ruleName);\r\n        if (!rule) {\r\n            throw Error('Permission found but no rule found named: ' + ruleName);\r\n        }\r\n        ruleName = rule.names[0];\r\n        if (!rulePermissionNames.hasOwnProperty(ruleName)) {\r\n            rulePermissionNames[ruleName] = [];\r\n        }\r\n        rulePermissionNames[ruleName].push({\r\n            name: permissionName,\r\n            context: permissionContext\r\n        });\r\n    }\r\n    /**\r\n     * This method returns the rule registered with the given name.\r\n     *\r\n     * @param ruleName The name of the rule to lookup.\r\n     *\r\n     * @returns rule The rule with the given name, undefined otherwise.\r\n     */\r\n    _getRule(ruleName) {\r\n        return /* @ngInject */ PermissionService_1.rules.find((rule) => rule.names.indexOf(ruleName) > -1);\r\n    }\r\n    _validationRule(ruleConfiguration) {\r\n        ruleConfiguration.names.forEach((ruleName) => {\r\n            if (this._getRule(ruleName)) {\r\n                throw Error('Rule already exists: ' + ruleName);\r\n            }\r\n        });\r\n    }\r\n    _validatePermission(permissionConfiguration) {\r\n        if (!(permissionConfiguration.aliases instanceof Array)) {\r\n            throw Error('Permission aliases must be an array');\r\n        }\r\n        if (permissionConfiguration.aliases.length < 1) {\r\n            throw Error('Permission requires at least one alias');\r\n        }\r\n        if (!(permissionConfiguration.rules instanceof Array)) {\r\n            throw Error('Permission rules must be an array');\r\n        }\r\n        if (permissionConfiguration.rules.length < 1) {\r\n            throw Error('Permission requires at least one rule');\r\n        }\r\n        permissionConfiguration.aliases.forEach((permissionName) => {\r\n            if (this.getPermission(permissionName)) {\r\n                throw Error('Permission already exists: ' + permissionName);\r\n            }\r\n            if (!this._isPermissionNameValid(permissionName)) {\r\n                throw Error('Permission aliases must be prefixed with namespace and a full stop');\r\n            }\r\n        });\r\n        permissionConfiguration.rules.forEach((ruleName) => {\r\n            if (!this._getRule(ruleName)) {\r\n                throw Error('Permission found but no rule found named: ' + ruleName);\r\n            }\r\n        });\r\n    }\r\n    _updateCache(rulePermissionNames, permissionResults) {\r\n        Object.keys(permissionResults).forEach((ruleName) => {\r\n            const cacheKey = this._generateCacheKey(rulePermissionNames[ruleName]);\r\n            const cacheValue = permissionResults[ruleName];\r\n            this._addCachedResult(ruleName, cacheKey, cacheValue);\r\n        });\r\n    }\r\n    _addCachedResult(ruleName, key, result) {\r\n        if (!/* @ngInject */ PermissionService_1.hasCacheRegion(ruleName)) {\r\n            /* @ngInject */ PermissionService_1.cachedResults[ruleName] = {};\r\n        }\r\n        /* @ngInject */ PermissionService_1.cachedResults[ruleName][key] = result;\r\n    }\r\n    _registerRule(ruleConfiguration) {\r\n        this._validationRule(ruleConfiguration);\r\n        if (ruleConfiguration.names &&\r\n            ruleConfiguration.names.length &&\r\n            ruleConfiguration.names.indexOf(DEFAULT_DEFAULT_RULE_NAME) > -1) {\r\n            throw Error('Register default rule using permissionService.registerDefaultRule()');\r\n        }\r\n        /* @ngInject */ PermissionService_1.rules.push({\r\n            names: ruleConfiguration.names\r\n        });\r\n    }\r\n    _registerDefaultRule(ruleConfiguration) {\r\n        this._validationRule(ruleConfiguration);\r\n        if (ruleConfiguration.names &&\r\n            ruleConfiguration.names.length &&\r\n            ruleConfiguration.names.indexOf(DEFAULT_DEFAULT_RULE_NAME) === -1) {\r\n            throw Error('Default rule name must be DEFAULT_RULE_NAME');\r\n        }\r\n        /* @ngInject */ PermissionService_1.rules.push({\r\n            names: ruleConfiguration.names\r\n        });\r\n    }\r\n    _callRuleVerify(ruleKey, permissionNameObjs) {\r\n        if (this.ruleVerifyFunctions && this.ruleVerifyFunctions[ruleKey]) {\r\n            return this.ruleVerifyFunctions[ruleKey].verify(permissionNameObjs);\r\n        }\r\n        // ask inner application for verify function.\r\n        return this._remoteCallRuleVerify(ruleKey, permissionNameObjs);\r\n    }\r\n    _registerEventHandlers() {\r\n        this.crossFrameEventService.subscribe(EVENTS.USER_HAS_CHANGED, this.clearCache.bind(this));\r\n        this.systemEventService.subscribe(EVENTS.EXPERIENCE_UPDATE, this.clearCache.bind(this));\r\n        this.crossFrameEventService.subscribe(EVENTS.PAGE_CHANGE, this.clearCache.bind(this));\r\n        this.crossFrameEventService.subscribe(EVENT_PERSPECTIVE_CHANGED, this.clearCache.bind(this));\r\n    }\r\n    _remoteCallRuleVerify(name, permissionNameObjs) {\r\n        'proxyFunction';\r\n        return null;\r\n    }\r\n};\r\n/* @ngInject */ PermissionService.rules = [];\r\n/* @ngInject */ PermissionService.permissionsRegistry = [];\r\n/* @ngInject */ PermissionService.cachedResults = {};\r\n/* @ngInject */ PermissionService = /* @ngInject */ PermissionService_1 = __decorate([\r\n    SeDowngradeService(IPermissionService),\r\n    GatewayProxied('isPermitted', 'clearCache', 'registerPermission', 'unregisterDefaultRule', 'registerDefaultRule', 'registerRule', '_registerRule', '_remoteCallRuleVerify', '_registerDefaultRule'),\r\n    __metadata(\"design:paramtypes\", [LogService,\r\n        SystemEventService,\r\n        CrossFrameEventService])\r\n], /* @ngInject */ PermissionService);\r\nexport { /* @ngInject */ PermissionService };\r\n//# sourceMappingURL=PermissionServiceOuter.js.map","references":["/home/wadmin/Documents/cloud-commerce-sample-setup-update-2211/core-customize/hybris/bin/modules/smartedit/smartedit/apps/smartedit-commons/dist/index.d.ts"],"map":"{\"version\":3,\"file\":\"PermissionServiceOuter.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../../../src/services/PermissionServiceOuter.ts\"],\"names\":[],\"mappings\":\"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\"}","dts":{"name":"/home/wadmin/Documents/cloud-commerce-sample-setup-update-2211/core-customize/hybris/bin/modules/smartedit/smartedit/apps/smartedit-container/node_modules/.cache/rollup-plugin-typescript2/placeholder/services/PermissionServiceOuter.d.ts","writeByteOrderMark":false,"text":"import { CrossFrameEventService, IPermissionService, LogService, MultiNamePermissionContext, Permission, PermissionContext, Rule, RuleNames, SystemEventService, TypedMap } from 'smarteditcommons';\r\n/**\r\n * The name used to register the default rule.\r\n */\r\nexport declare const DEFAULT_DEFAULT_RULE_NAME = \"se.permission.service.default.rule\";\r\nexport declare type RulePermissionNames = TypedMap<PermissionContext[]>;\r\nexport declare class PermissionService extends IPermissionService {\r\n    private logService;\r\n    private systemEventService;\r\n    private crossFrameEventService;\r\n    private static rules;\r\n    private static permissionsRegistry;\r\n    private static cachedResults;\r\n    static resetForTests(): void;\r\n    private static hasCacheRegion;\r\n    private static getCacheRegion;\r\n    constructor(logService: LogService, systemEventService: SystemEventService, crossFrameEventService: CrossFrameEventService);\r\n    getPermission(permissionName: string): Permission;\r\n    unregisterDefaultRule(): void;\r\n    registerPermission(permission: Permission): void;\r\n    hasCachedResult(ruleName: string, key: string): boolean;\r\n    clearCache(): void;\r\n    isPermitted(permissions: MultiNamePermissionContext[]): Promise<boolean>;\r\n    /**\r\n     * This method adds a promise obtained by calling the pre-configured rule.verify function to the rulePromises\r\n     * map if the result does not exist in the rule's cache. Otherwise, a promise that contains the cached result\r\n     * is added.\r\n     *\r\n     * The promise obtained from the rule.verify function is chained to allow short-circuiting the permission\r\n     * verification process. If a rule resolves with a false result or with an error, the chained promise is\r\n     * rejected to stop the verification process without waiting for all other rules to resolve.\r\n     *\r\n     * @param rulePromises An object that maps rule names to promises.\r\n     * @param rulePermissionNames An object that maps rule names to permission name arrays.\r\n     * @param ruleName The name of the rule to verify.\r\n     */\r\n    protected _addRulePromise(rulePromises: TypedMap<Promise<boolean>>, rulePermissionNames: RulePermissionNames, ruleName: string): void;\r\n    /**\r\n     * This method validates a permission name. Permission names need to be prefixed by at least one\r\n     * namespace followed by a \".\" character to be valid.\r\n     *\r\n     * Example: se.mynamespace is valid.\r\n     * Example: mynamespace is not valid.\r\n     */\r\n    protected _isPermissionNameValid(permissionName: string): boolean;\r\n    /**\r\n     * This method returns an object that maps rule names to promises.\r\n     */\r\n    protected _getRulePromises(rulePermissionNames: RulePermissionNames): TypedMap<Promise<boolean>>;\r\n    /**\r\n     * This method returns true if a default rule is already registered.\r\n     *\r\n     * @returns true if the default rule has been registered, false otherwise.\r\n     */\r\n    protected _hasDefaultRule(): boolean;\r\n    /**\r\n     * This method returns the rule's cached result for the given key.\r\n     *\r\n     * @param ruleName The name of the rule for which to lookup the cached result.\r\n     * @param key The cached key to lookup..\r\n     *\r\n     * @returns The cached result, if it exists, null otherwise.\r\n     */\r\n    protected _getCachedResult(ruleName: string, key: string): boolean | null;\r\n    /**\r\n     * This method generates a key to store a rule's result for a given combination of\r\n     * permissions in its cache. It is done by sorting the list of permissions by name\r\n     * and serializing it.\r\n     *\r\n     * @param permissions A list of permissions with a name and context.\r\n     *\r\n     * [{\r\n     *     name: \"permission.name\"\r\n     *     context: {\r\n     *         key: \"value\"\r\n     *     }\r\n     * }]\r\n     *\r\n     * @returns The serialized sorted list of permissions.\r\n     */\r\n    protected _generateCacheKey(permissions: PermissionContext[]): string;\r\n    /**\r\n     * This method goes through the permission name arrays associated to rule names to remove any duplicate\r\n     * permission names.\r\n     *\r\n     * If one or more permission names with the same context are found in a rule name's permission name array,\r\n     * only one entry is kept.\r\n     */\r\n    protected _removeDuplicatePermissionNames(rulePermissionNames: RulePermissionNames): void;\r\n    /**\r\n     * This method returns an object mapping rule name to permission name arrays.\r\n     *\r\n     * It will iterate through the given permission name object array to extract the permission names and contexts,\r\n     * populate the map and clean it up by removing duplicate permission name and context pairs.\r\n     */\r\n    protected _mapRuleNameToPermissionNames(permissions: MultiNamePermissionContext[]): TypedMap<PermissionContext[]>;\r\n    /**\r\n     * This method will populate rulePermissionNames with the rules associated to the permission with the given\r\n     * permissionName.\r\n     *\r\n     * If no permission is registered with the given permissionName and a default rule is registered, the default\r\n     * rule is added to rulePermissionNames.\r\n     *\r\n     * If no permission is registered with the given permissionName and no default rule is registered, an error\r\n     * is thrown.\r\n     */\r\n    protected _populateRulePermissionNames(rulePermissionNames: RulePermissionNames, permissionName: string, permissionContext: TypedMap<string>): void;\r\n    /**\r\n     * This method will add an object with the permissionName and permissionContext to rulePermissionNames.\r\n     *\r\n     * Since rules can have multiple names, the map will use the first name in the rule's name list as its key.\r\n     * This way, each rule will be called only once for every permission name and context.\r\n     *\r\n     * If the rule associated to a given rule name is already in rulePermissionNames, the permission will be\r\n     * appended to the associated array. Otherwise, the rule name is added to the map and its permission name array\r\n     * is created.\r\n     */\r\n    protected _addPermissionName(rulePermissionNames: RulePermissionNames, ruleName: string, permissionName: string, permissionContext: TypedMap<any>): void;\r\n    /**\r\n     * This method returns the rule registered with the given name.\r\n     *\r\n     * @param ruleName The name of the rule to lookup.\r\n     *\r\n     * @returns rule The rule with the given name, undefined otherwise.\r\n     */\r\n    protected _getRule(ruleName: string): RuleNames;\r\n    protected _validationRule(ruleConfiguration: Rule): void;\r\n    protected _validatePermission(permissionConfiguration: Permission): void;\r\n    protected _updateCache(rulePermissionNames: RulePermissionNames, permissionResults: TypedMap<boolean>): void;\r\n    protected _addCachedResult(ruleName: string, key: string, result: boolean): void;\r\n    protected _registerRule(ruleConfiguration: Rule): void;\r\n    protected _registerDefaultRule(ruleConfiguration: Rule): void;\r\n    protected _callRuleVerify(ruleKey: string, permissionNameObjs: PermissionContext[]): Promise<boolean>;\r\n    protected _registerEventHandlers(): void;\r\n    protected _remoteCallRuleVerify(name: string, permissionNameObjs: PermissionContext[]): Promise<boolean>;\r\n}\r\n"}}
