"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RushProjectConfiguration = exports.RUSH_PROJECT_CONFIGURATION_FILE = void 0;
const path = __importStar(require("path"));
const node_core_library_1 = require("@rushstack/node-core-library");
const heft_config_file_1 = require("@rushstack/heft-config-file");
const rig_package_1 = require("@rushstack/rig-package");
const RushConstants_1 = require("../logic/RushConstants");
const OverlappingPathAnalyzer_1 = require("../utilities/OverlappingPathAnalyzer");
exports.RUSH_PROJECT_CONFIGURATION_FILE = new heft_config_file_1.ConfigurationFile({
    projectRelativeFilePath: `config/${RushConstants_1.RushConstants.rushProjectConfigFilename}`,
    jsonSchemaPath: path.resolve(__dirname, '..', 'schemas', 'rush-project.schema.json'),
    propertyInheritance: {
        operationSettings: {
            inheritanceType: heft_config_file_1.InheritanceType.custom,
            inheritanceFunction: (child, parent) => {
                if (!child) {
                    return parent;
                }
                else if (!parent) {
                    return child;
                }
                else {
                    // Merge the outputFolderNames arrays
                    const resultOperationSettingsByOperationName = new Map();
                    for (const parentOperationSettings of parent) {
                        resultOperationSettingsByOperationName.set(parentOperationSettings.operationName, parentOperationSettings);
                    }
                    const childEncounteredOperationNames = new Set();
                    for (const childOperationSettings of child) {
                        const operationName = childOperationSettings.operationName;
                        if (childEncounteredOperationNames.has(operationName)) {
                            // If the operation settings already exist, but didn't come from the parent, then
                            // it shows up multiple times in the child.
                            const childSourceFilePath = exports.RUSH_PROJECT_CONFIGURATION_FILE.getObjectSourceFilePath(child);
                            throw new Error(`The operation "${operationName}" occurs multiple times in the "operationSettings" array ` +
                                `in "${childSourceFilePath}".`);
                        }
                        childEncounteredOperationNames.add(operationName);
                        let mergedOperationSettings = resultOperationSettingsByOperationName.get(operationName);
                        if (mergedOperationSettings) {
                            // The parent operation settings object already exists, so append to the outputFolderNames
                            const outputFolderNames = mergedOperationSettings.outputFolderNames && childOperationSettings.outputFolderNames
                                ? [
                                    ...mergedOperationSettings.outputFolderNames,
                                    ...childOperationSettings.outputFolderNames
                                ]
                                : mergedOperationSettings.outputFolderNames || childOperationSettings.outputFolderNames;
                            mergedOperationSettings = Object.assign(Object.assign(Object.assign({}, mergedOperationSettings), childOperationSettings), { outputFolderNames });
                            resultOperationSettingsByOperationName.set(operationName, mergedOperationSettings);
                        }
                        else {
                            resultOperationSettingsByOperationName.set(operationName, childOperationSettings);
                        }
                    }
                    return Array.from(resultOperationSettingsByOperationName.values());
                }
            }
        },
        incrementalBuildIgnoredGlobs: {
            inheritanceType: heft_config_file_1.InheritanceType.replace
        }
    }
});
const OLD_RUSH_PROJECT_CONFIGURATION_FILE = new heft_config_file_1.ConfigurationFile({
    projectRelativeFilePath: exports.RUSH_PROJECT_CONFIGURATION_FILE.projectRelativeFilePath,
    jsonSchemaPath: path.resolve(__dirname, '..', 'schemas', 'anything.schema.json')
});
/**
 * Use this class to load the "config/rush-project.json" config file.
 *
 * This file provides project-specific configuration options.
 * @public
 */
class RushProjectConfiguration {
    constructor(project, rushProjectJson, operationSettingsByOperationName) {
        this.project = project;
        this.incrementalBuildIgnoredGlobs = rushProjectJson.incrementalBuildIgnoredGlobs || [];
        this.disableBuildCacheForProject = rushProjectJson.disableBuildCacheForProject || false;
        this.operationSettingsByOperationName = operationSettingsByOperationName;
    }
    /**
     * Loads the rush-project.json data for the specified project.
     */
    static async tryLoadForProjectAsync(project, repoCommandLineConfiguration, terminal) {
        // false is a signal that the project config does not exist
        const cacheEntry = RushProjectConfiguration._configCache.get(project);
        if (cacheEntry !== undefined) {
            return cacheEntry || undefined;
        }
        const rushProjectJson = await this._tryLoadJsonForProjectAsync(project, terminal);
        if (rushProjectJson) {
            const result = RushProjectConfiguration._getRushProjectConfiguration(project, rushProjectJson, repoCommandLineConfiguration, terminal);
            RushProjectConfiguration._configCache.set(project, result);
            return result;
        }
        else {
            RushProjectConfiguration._configCache.set(project, false);
            return undefined;
        }
    }
    /**
     * Load only the `incrementalBuildIgnoredGlobs` property from the rush-project.json file, skipping
     * validation of other parts of the config file.
     *
     * @remarks
     * This function exists to allow the ProjectChangeAnalyzer to load just the ignore globs without
     * having to validate the rest of the `rush-project.json` file against the repo's command-line configuration.
     */
    static async tryLoadIgnoreGlobsForProjectAsync(project, terminal) {
        const rushProjectJson = await this._tryLoadJsonForProjectAsync(project, terminal);
        return rushProjectJson === null || rushProjectJson === void 0 ? void 0 : rushProjectJson.incrementalBuildIgnoredGlobs;
    }
    static async _tryLoadJsonForProjectAsync(project, terminal) {
        const rigConfig = await rig_package_1.RigConfig.loadForProjectFolderAsync({
            projectFolderPath: project.projectFolder
        });
        try {
            return await exports.RUSH_PROJECT_CONFIGURATION_FILE.tryLoadConfigurationFileForProjectAsync(terminal, project.projectFolder, rigConfig);
        }
        catch (e) {
            // Detect if the project is using the old rush-project.json schema
            let oldRushProjectJson;
            try {
                oldRushProjectJson =
                    await OLD_RUSH_PROJECT_CONFIGURATION_FILE.tryLoadConfigurationFileForProjectAsync(terminal, project.projectFolder, rigConfig);
            }
            catch (e) {
                // Ignore
            }
            if ((oldRushProjectJson === null || oldRushProjectJson === void 0 ? void 0 : oldRushProjectJson.projectOutputFolderNames) ||
                (oldRushProjectJson === null || oldRushProjectJson === void 0 ? void 0 : oldRushProjectJson.phaseOptions) ||
                (oldRushProjectJson === null || oldRushProjectJson === void 0 ? void 0 : oldRushProjectJson.buildCacheOptions)) {
                throw new Error(`The ${exports.RUSH_PROJECT_CONFIGURATION_FILE.projectRelativeFilePath} file appears to be ` +
                    'in an outdated format. Please see the UPGRADING.md notes for details. ' +
                    'Quick link: https://rushjs.io/link/upgrading');
            }
            else {
                throw e;
            }
        }
    }
    static _getRushProjectConfiguration(project, rushProjectJson, repoCommandLineConfiguration, terminal) {
        const operationSettingsByOperationName = new Map();
        if (rushProjectJson.operationSettings) {
            for (const operationSettings of rushProjectJson.operationSettings) {
                const operationName = operationSettings.operationName;
                const existingOperationSettings = operationSettingsByOperationName.get(operationName);
                if (existingOperationSettings) {
                    const existingOperationSettingsJsonPath = exports.RUSH_PROJECT_CONFIGURATION_FILE.getObjectSourceFilePath(existingOperationSettings);
                    const operationSettingsJsonPath = exports.RUSH_PROJECT_CONFIGURATION_FILE.getObjectSourceFilePath(operationSettings);
                    let errorMessage = `The operation "${operationName}" appears multiple times in the "${project.packageName}" project's ` +
                        `${exports.RUSH_PROJECT_CONFIGURATION_FILE.projectRelativeFilePath} file's ` +
                        'operationSettings property.';
                    if (existingOperationSettingsJsonPath && operationSettingsJsonPath) {
                        if (existingOperationSettingsJsonPath !== operationSettingsJsonPath) {
                            errorMessage +=
                                ` It first appears in "${existingOperationSettingsJsonPath}" and again ` +
                                    `in "${operationSettingsJsonPath}".`;
                        }
                        else if (!node_core_library_1.Path.convertToSlashes(existingOperationSettingsJsonPath).startsWith(node_core_library_1.Path.convertToSlashes(project.projectFolder))) {
                            errorMessage += ` It appears multiple times in "${operationSettingsJsonPath}".`;
                        }
                    }
                    terminal.writeErrorLine(errorMessage);
                }
                else {
                    operationSettingsByOperationName.set(operationName, operationSettings);
                }
            }
            // For each phased command, check if any of its phases' output folders overlap.
            for (const command of repoCommandLineConfiguration.commands.values()) {
                if (command.commandKind === 'phased') {
                    const overlappingPathAnalyzer = new OverlappingPathAnalyzer_1.OverlappingPathAnalyzer();
                    for (const phase of command.phases) {
                        const operationName = phase.name;
                        const operationSettings = operationSettingsByOperationName.get(operationName);
                        if (operationSettings) {
                            if (operationSettings.outputFolderNames) {
                                for (const outputFolderName of operationSettings.outputFolderNames) {
                                    const overlappingOperationNames = overlappingPathAnalyzer.addPathAndGetFirstEncounteredLabels(outputFolderName, operationName);
                                    if (overlappingOperationNames) {
                                        const overlapsWithOwnOperation = overlappingOperationNames === null || overlappingOperationNames === void 0 ? void 0 : overlappingOperationNames.includes(operationName);
                                        if (overlapsWithOwnOperation) {
                                            terminal.writeErrorLine(`The project "${project.packageName}" has a ` +
                                                `"${exports.RUSH_PROJECT_CONFIGURATION_FILE.projectRelativeFilePath}" configuration that defines an ` +
                                                `operation with overlapping paths in the "outputFolderNames" list. The operation is ` +
                                                `"${operationName}", and the conflicting path is "${outputFolderName}".`);
                                        }
                                        else {
                                            terminal.writeErrorLine(`The project "${project.packageName}" has a ` +
                                                `"${exports.RUSH_PROJECT_CONFIGURATION_FILE.projectRelativeFilePath}" configuration that defines ` +
                                                'two potentially simultaneous operations whose "outputFolderNames" would overlap. ' +
                                                "Simultaneous operations should not delete each other's output." +
                                                `\n\n` +
                                                `The "${outputFolderName}" path overlaps between these operations: ` +
                                                overlappingOperationNames.map((operationName) => `"${operationName}"`).join(', '));
                                        }
                                        throw new node_core_library_1.AlreadyReportedError();
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        return new RushProjectConfiguration(project, rushProjectJson, operationSettingsByOperationName);
    }
}
exports.RushProjectConfiguration = RushProjectConfiguration;
RushProjectConfiguration._configCache = new Map();
//# sourceMappingURL=RushProjectConfiguration.js.map