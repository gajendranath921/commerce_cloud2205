/**
 * @fileoverview added by tsickle
 * Generated from: lib/datetime-picker/format/datetime-parser.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { Injectable } from '@angular/core';
import { FdDatetime } from '../models/fd-datetime';
import { FdDate } from '../../calendar/models/fd-date';
import * as i0 from "@angular/core";
/**
 * @return {?}
 */
export function DATE_TIME_FORMAT_FACTORY() {
    return new DateTimeFormatParserDefault();
}
/**
 * Abstract class which defines the behaviour of the datetime format and parser.
 * @abstract
 */
var DateTimeFormatParser = /** @class */ (function () {
    function DateTimeFormatParser() {
    }
    DateTimeFormatParser.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root',
                    useFactory: DATE_TIME_FORMAT_FACTORY
                },] }
    ];
    /** @nocollapse */ DateTimeFormatParser.ngInjectableDef = i0.ɵɵdefineInjectable({ factory: DATE_TIME_FORMAT_FACTORY, token: DateTimeFormatParser, providedIn: "root" });
    return DateTimeFormatParser;
}());
export { DateTimeFormatParser };
if (false) {
    /**
     * Should take in a string value and return a FdDatetime model object.
     * @abstract
     * @param {?} value String to concert to a FdDatetime model object.
     * @return {?}
     */
    DateTimeFormatParser.prototype.parse = function (value) { };
    /**
     * Should take in a FdDatetime model object and return a string representation.
     * @abstract
     * @param {?} date FdDatetime object to concert to a date string.
     * Return null, to keep default angular DatePipe as a formatter.
     * @return {?}
     */
    DateTimeFormatParser.prototype.format = function (date) { };
}
/**
 * Default implementation of the DateFormatParser service.
 */
var DateTimeFormatParserDefault = /** @class */ (function (_super) {
    tslib_1.__extends(DateTimeFormatParserDefault, _super);
    function DateTimeFormatParserDefault() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Takes in a string representation of a date and returns a FdDatetime object.
     * @param value String to convert to a FdDatetime model object.
     */
    /**
     * Takes in a string representation of a date and returns a FdDatetime object.
     * @param {?} value String to convert to a FdDatetime model object.
     * @return {?}
     */
    DateTimeFormatParserDefault.prototype.parse = /**
     * Takes in a string representation of a date and returns a FdDatetime object.
     * @param {?} value String to convert to a FdDatetime model object.
     * @return {?}
     */
    function (value) {
        if (!value) {
            return FdDatetime.getToday();
        }
        else {
            /** @type {?} */
            var date = new Date(value);
            return new FdDatetime(new FdDate(date.getFullYear(), date.getMonth() + 1, date.getDate()), {
                hour: date.getHours(),
                minute: date.getMinutes(),
                second: date.getSeconds()
            });
        }
    };
    /**
     * Takes in a FdDatetime object and returns the string representation.
     * @param date FdDatetime model object to convert to a string.
     * Return null, to keep default angular DatePipe as a formatter.
     */
    /**
     * Takes in a FdDatetime object and returns the string representation.
     * @param {?} date FdDatetime model object to convert to a string.
     * Return null, to keep default angular DatePipe as a formatter.
     * @return {?}
     */
    DateTimeFormatParserDefault.prototype.format = /**
     * Takes in a FdDatetime object and returns the string representation.
     * @param {?} date FdDatetime model object to convert to a string.
     * Return null, to keep default angular DatePipe as a formatter.
     * @return {?}
     */
    function (date) {
        return null;
    };
    DateTimeFormatParserDefault.decorators = [
        { type: Injectable }
    ];
    return DateTimeFormatParserDefault;
}(DateTimeFormatParser));
export { DateTimeFormatParserDefault };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0ZXRpbWUtcGFyc2VyLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQGZ1bmRhbWVudGFsLW5neC9jb3JlLyIsInNvdXJjZXMiOlsibGliL2RhdGV0aW1lLXBpY2tlci9mb3JtYXQvZGF0ZXRpbWUtcGFyc2VyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDM0MsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLHVCQUF1QixDQUFDO0FBQ25ELE9BQU8sRUFBRSxNQUFNLEVBQUUsTUFBTSwrQkFBK0IsQ0FBQzs7Ozs7QUFHdkQsTUFBTSxVQUFVLHdCQUF3QjtJQUNwQyxPQUFPLElBQUksMkJBQTJCLEVBQUUsQ0FBQztBQUM3QyxDQUFDOzs7OztBQUtEO0lBQUE7S0FrQkM7O2dCQWxCQSxVQUFVLFNBQUM7b0JBQ1IsVUFBVSxFQUFFLE1BQU07b0JBQ2xCLFVBQVUsRUFBRSx3QkFBd0I7aUJBQ3ZDOzs7K0JBZkQ7Q0E4QkMsQUFsQkQsSUFrQkM7U0FkcUIsb0JBQW9COzs7Ozs7OztJQU10Qyw0REFBMEM7Ozs7Ozs7O0lBTzFDLDREQUEwQzs7Ozs7QUFNOUM7SUFDaUQsdURBQW9CO0lBRHJFOztJQStCQSxDQUFDO0lBNUJHOzs7T0FHRzs7Ozs7O0lBQ0ksMkNBQUs7Ozs7O0lBQVosVUFBYSxLQUFhO1FBQ3RCLElBQUksQ0FBQyxLQUFLLEVBQUU7WUFDUixPQUFPLFVBQVUsQ0FBQyxRQUFRLEVBQUUsQ0FBQztTQUNoQzthQUFNOztnQkFDRyxJQUFJLEdBQVMsSUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDO1lBQ2xDLE9BQU8sSUFBSSxVQUFVLENBQ2pCLElBQUksTUFBTSxDQUFDLElBQUksQ0FBQyxXQUFXLEVBQUUsRUFBRSxJQUFJLENBQUMsUUFBUSxFQUFFLEdBQUcsQ0FBQyxFQUFFLElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQyxFQUNuRTtnQkFDSSxJQUFJLEVBQUUsSUFBSSxDQUFDLFFBQVEsRUFBRTtnQkFDckIsTUFBTSxFQUFFLElBQUksQ0FBQyxVQUFVLEVBQUU7Z0JBQ3pCLE1BQU0sRUFBRSxJQUFJLENBQUMsVUFBVSxFQUFFO2FBQzVCLENBQ0osQ0FBQztTQUNMO0lBQ0wsQ0FBQztJQUVEOzs7O09BSUc7Ozs7Ozs7SUFDSSw0Q0FBTTs7Ozs7O0lBQWIsVUFBYyxJQUFnQjtRQUMxQixPQUFPLElBQUksQ0FBQztJQUNoQixDQUFDOztnQkE5QkosVUFBVTs7SUErQlgsa0NBQUM7Q0FBQSxBQS9CRCxDQUNpRCxvQkFBb0IsR0E4QnBFO1NBOUJZLDJCQUEyQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEZkRGF0ZXRpbWUgfSBmcm9tICcuLi9tb2RlbHMvZmQtZGF0ZXRpbWUnO1xuaW1wb3J0IHsgRmREYXRlIH0gZnJvbSAnLi4vLi4vY2FsZW5kYXIvbW9kZWxzL2ZkLWRhdGUnO1xuaW1wb3J0IHsgRGF0ZVBpcGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuXG5leHBvcnQgZnVuY3Rpb24gREFURV9USU1FX0ZPUk1BVF9GQUNUT1JZKCkge1xuICAgIHJldHVybiBuZXcgRGF0ZVRpbWVGb3JtYXRQYXJzZXJEZWZhdWx0KCk7XG59XG5cbi8qKlxuICogQWJzdHJhY3QgY2xhc3Mgd2hpY2ggZGVmaW5lcyB0aGUgYmVoYXZpb3VyIG9mIHRoZSBkYXRldGltZSBmb3JtYXQgYW5kIHBhcnNlci5cbiAqL1xuQEluamVjdGFibGUoe1xuICAgIHByb3ZpZGVkSW46ICdyb290JyxcbiAgICB1c2VGYWN0b3J5OiBEQVRFX1RJTUVfRk9STUFUX0ZBQ1RPUllcbn0pXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgRGF0ZVRpbWVGb3JtYXRQYXJzZXIge1xuXG4gICAgLyoqXG4gICAgICogU2hvdWxkIHRha2UgaW4gYSBzdHJpbmcgdmFsdWUgYW5kIHJldHVybiBhIEZkRGF0ZXRpbWUgbW9kZWwgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB2YWx1ZSBTdHJpbmcgdG8gY29uY2VydCB0byBhIEZkRGF0ZXRpbWUgbW9kZWwgb2JqZWN0LlxuICAgICAqL1xuICAgIGFic3RyYWN0IHBhcnNlKHZhbHVlOiBzdHJpbmcpOiBGZERhdGV0aW1lO1xuXG4gICAgLyoqXG4gICAgICogU2hvdWxkIHRha2UgaW4gYSBGZERhdGV0aW1lIG1vZGVsIG9iamVjdCBhbmQgcmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uLlxuICAgICAqIEBwYXJhbSBkYXRlIEZkRGF0ZXRpbWUgb2JqZWN0IHRvIGNvbmNlcnQgdG8gYSBkYXRlIHN0cmluZy5cbiAgICAgKiBSZXR1cm4gbnVsbCwgdG8ga2VlcCBkZWZhdWx0IGFuZ3VsYXIgRGF0ZVBpcGUgYXMgYSBmb3JtYXR0ZXIuXG4gICAgICovXG4gICAgYWJzdHJhY3QgZm9ybWF0KGRhdGU6IEZkRGF0ZXRpbWUpOiBzdHJpbmc7XG59XG5cbi8qKlxuICogRGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgRGF0ZUZvcm1hdFBhcnNlciBzZXJ2aWNlLlxuICovXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgRGF0ZVRpbWVGb3JtYXRQYXJzZXJEZWZhdWx0IGV4dGVuZHMgRGF0ZVRpbWVGb3JtYXRQYXJzZXIge1xuXG4gICAgLyoqXG4gICAgICogVGFrZXMgaW4gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBkYXRlIGFuZCByZXR1cm5zIGEgRmREYXRldGltZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHZhbHVlIFN0cmluZyB0byBjb252ZXJ0IHRvIGEgRmREYXRldGltZSBtb2RlbCBvYmplY3QuXG4gICAgICovXG4gICAgcHVibGljIHBhcnNlKHZhbHVlOiBzdHJpbmcpOiBGZERhdGV0aW1lIHtcbiAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIEZkRGF0ZXRpbWUuZ2V0VG9kYXkoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGU6IERhdGUgPSBuZXcgRGF0ZSh2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZkRGF0ZXRpbWUoXG4gICAgICAgICAgICAgICAgbmV3IEZkRGF0ZShkYXRlLmdldEZ1bGxZZWFyKCksIGRhdGUuZ2V0TW9udGgoKSArIDEsIGRhdGUuZ2V0RGF0ZSgpKSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGhvdXI6IGRhdGUuZ2V0SG91cnMoKSxcbiAgICAgICAgICAgICAgICAgICAgbWludXRlOiBkYXRlLmdldE1pbnV0ZXMoKSxcbiAgICAgICAgICAgICAgICAgICAgc2Vjb25kOiBkYXRlLmdldFNlY29uZHMoKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUYWtlcyBpbiBhIEZkRGF0ZXRpbWUgb2JqZWN0IGFuZCByZXR1cm5zIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24uXG4gICAgICogQHBhcmFtIGRhdGUgRmREYXRldGltZSBtb2RlbCBvYmplY3QgdG8gY29udmVydCB0byBhIHN0cmluZy5cbiAgICAgKiBSZXR1cm4gbnVsbCwgdG8ga2VlcCBkZWZhdWx0IGFuZ3VsYXIgRGF0ZVBpcGUgYXMgYSBmb3JtYXR0ZXIuXG4gICAgICovXG4gICAgcHVibGljIGZvcm1hdChkYXRlOiBGZERhdGV0aW1lKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuIl19