/**
 * @fileoverview added by tsickle
 * Generated from: lib/calendar/calendar-views/calendar-month-view/calendar-month-view.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { Component, Input, Output, ViewEncapsulation, EventEmitter, ElementRef, ChangeDetectorRef, ChangeDetectionStrategy } from '@angular/core';
import { FdDate } from '../../models/fd-date';
import { CalendarI18n } from '../../i18n/calendar-i18n';
import { Subject } from 'rxjs';
import { takeUntil } from 'rxjs/operators';
import { CalendarService } from '../../calendar.service';
/**
 * Component representing the month view of the calendar.
 */
var CalendarMonthViewComponent = /** @class */ (function () {
    function CalendarMonthViewComponent(eRef, cdRef, calendarI18n, calendarService) {
        this.eRef = eRef;
        this.cdRef = cdRef;
        this.calendarI18n = calendarI18n;
        this.calendarService = calendarService;
        /**
         * A number offset used to achieve the 1-12 representation of the calendar
         */
        this._monthOffset = 1;
        this._amountOfColPerRow = 4;
        /**
         * An RxJS Subject that will kill the data stream upon componentâ€™s destruction (for unsubscribing)
         */
        this.onDestroy$ = new Subject();
        /**
         * An event fired when a new month is selected
         */
        this.monthClicked = new EventEmitter();
    }
    /** @hidden */
    /**
     * @hidden
     * @return {?}
     */
    CalendarMonthViewComponent.prototype.ngOnInit = /**
     * @hidden
     * @return {?}
     */
    function () {
        var _this = this;
        this.calendarService.focusEscapeFunction = this.focusEscapeFunction;
        this.refreshShortMonthNames();
        this.calendarService.onFocusIdChange
            .pipe(takeUntil(this.onDestroy$))
            .subscribe((/**
         * @param {?} index
         * @return {?}
         */
        function (index) { return _this.focusElement('#' + _this.id + '-fd-month-' + index); }));
        this.calendarService.onKeySelect
            .pipe(takeUntil(this.onDestroy$))
            .subscribe((/**
         * @param {?} index
         * @return {?}
         */
        function (index) { return _this.selectMonth(index); }));
        this.calendarI18n.i18nChange
            .pipe(takeUntil(this.onDestroy$))
            .subscribe((/**
         * @return {?}
         */
        function () { return _this.refreshShortMonthNames(); }));
    };
    /** @hidden */
    /**
     * @hidden
     * @return {?}
     */
    CalendarMonthViewComponent.prototype.ngOnDestroy = /**
     * @hidden
     * @return {?}
     */
    function () {
        this.onDestroy$.next();
        this.onDestroy$.complete();
    };
    Object.defineProperty(CalendarMonthViewComponent.prototype, "currentMonth", {
        /** Get a number (1-12) representing the current month  */
        get: /**
         * Get a number (1-12) representing the current month
         * @return {?}
         */
        function () {
            return FdDate.getToday().month;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CalendarMonthViewComponent.prototype, "monthOffset", {
        /**  Getter for the private class member _monthOffset */
        get: /**
         * Getter for the private class member _monthOffset
         * @return {?}
         */
        function () {
            return this._monthOffset;
        },
        enumerable: true,
        configurable: true
    });
    /** Method for handling the mouse click event when a month is selected  */
    /**
     * Method for handling the mouse click event when a month is selected
     * @param {?} selectedMonth
     * @param {?=} event
     * @return {?}
     */
    CalendarMonthViewComponent.prototype.selectMonth = /**
     * Method for handling the mouse click event when a month is selected
     * @param {?} selectedMonth
     * @param {?=} event
     * @return {?}
     */
    function (selectedMonth, event) {
        if (event) {
            event.stopPropagation();
        }
        this.monthSelected = selectedMonth + this.monthOffset;
        this.monthClicked.emit(this.monthSelected);
    };
    /** Method for handling the keyboard events (a11y) */
    /**
     * Method for handling the keyboard events (a11y)
     * @param {?} event
     * @param {?} index
     * @return {?}
     */
    CalendarMonthViewComponent.prototype.onKeydownMonthHandler = /**
     * Method for handling the keyboard events (a11y)
     * @param {?} event
     * @param {?} index
     * @return {?}
     */
    function (event, index) {
        this.calendarService.onKeydownHandler(event, index);
    };
    /** Method that allows to focus elements inside this component */
    /**
     * Method that allows to focus elements inside this component
     * @param {?} elementSelector
     * @return {?}
     */
    CalendarMonthViewComponent.prototype.focusElement = /**
     * Method that allows to focus elements inside this component
     * @param {?} elementSelector
     * @return {?}
     */
    function (elementSelector) {
        /** @type {?} */
        var elementToFocus = this.eRef.nativeElement.querySelector(elementSelector);
        if (elementToFocus) {
            elementToFocus.focus();
        }
    };
    /** Method returning id of month cell */
    /**
     * Method returning id of month cell
     * @param {?} rowIndex
     * @param {?} colIndex
     * @return {?}
     */
    CalendarMonthViewComponent.prototype.getId = /**
     * Method returning id of month cell
     * @param {?} rowIndex
     * @param {?} colIndex
     * @return {?}
     */
    function (rowIndex, colIndex) {
        return rowIndex * this._amountOfColPerRow + colIndex;
    };
    /** Method that checks if this is current month */
    /**
     * Method that checks if this is current month
     * @param {?} id
     * @return {?}
     */
    CalendarMonthViewComponent.prototype.isCurrent = /**
     * Method that checks if this is current month
     * @param {?} id
     * @return {?}
     */
    function (id) {
        return id + this._monthOffset === this.currentMonth;
    };
    /** Method that check if this is selected month */
    /**
     * Method that check if this is selected month
     * @param {?} id
     * @return {?}
     */
    CalendarMonthViewComponent.prototype.isSelected = /**
     * Method that check if this is selected month
     * @param {?} id
     * @return {?}
     */
    function (id) {
        return id + this._monthOffset === this.monthSelected;
    };
    Object.defineProperty(CalendarMonthViewComponent.prototype, "shortMonthNames", {
        /** Method that returns grid of short month names from currently provided calendarI18n service */
        get: /**
         * Method that returns grid of short month names from currently provided calendarI18n service
         * @return {?}
         */
        function () {
            return this._shortMonthNames;
        },
        enumerable: true,
        configurable: true
    });
    /** Method that returns the full name of month for grid element. */
    /**
     * Method that returns the full name of month for grid element.
     * @param {?} rowIndex
     * @param {?} colIndex
     * @return {?}
     */
    CalendarMonthViewComponent.prototype.getFullMonthName = /**
     * Method that returns the full name of month for grid element.
     * @param {?} rowIndex
     * @param {?} colIndex
     * @return {?}
     */
    function (rowIndex, colIndex) {
        /** @type {?} */
        var index = this.getId(rowIndex, colIndex);
        return this._fullMonthNames[index];
    };
    /** Method that rewrite short month names, used mostly in case of i18n service language change */
    /**
     * Method that rewrite short month names, used mostly in case of i18n service language change
     * @private
     * @return {?}
     */
    CalendarMonthViewComponent.prototype.refreshShortMonthNames = /**
     * Method that rewrite short month names, used mostly in case of i18n service language change
     * @private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var monthNames = tslib_1.__spread(this.calendarI18n.getAllShortMonthNames());
        this._fullMonthNames = tslib_1.__spread(this.calendarI18n.getAllFullMonthNames());
        /** @type {?} */
        var twoDimensionMonthNames = [];
        /** Creating 2d grid */
        while (monthNames.length) {
            twoDimensionMonthNames.push(monthNames.splice(0, this._amountOfColPerRow));
        }
        this._shortMonthNames = twoDimensionMonthNames;
        this.cdRef.markForCheck();
    };
    CalendarMonthViewComponent.decorators = [
        { type: Component, args: [{
                    selector: 'fd-calendar-month-view',
                    template: "<div class=\"fd-calendar__months\">\n    <table class=\"fd-calendar__table\" role=\"grid\">\n        <tbody class=\"fd-calendar__group\">\n        <tr class=\"fd-calendar__row\"\n            *ngFor=\"let colMonths of shortMonthNames; let rowIndex = index\">\n            <td class=\"fd-calendar__item\"\n                *ngFor=\"let month of colMonths; let colIndex = index\"\n                [ngClass]=\"{\n                    'fd-calendar__item--current': isCurrent(getId(rowIndex, colIndex)),\n                    'is-selected': isSelected(getId(rowIndex, colIndex))\n                }\"\n                [attr.tabIndex]=\"isSelected(getId(rowIndex, colIndex)) ? 0 : -1\"\n                [attr.id]=\"id + '-fd-month-' + getId(rowIndex, colIndex)\"\n                (keydown)=\"onKeydownMonthHandler($event, getId(rowIndex, colIndex))\"\n                (click)=\"selectMonth(getId(rowIndex, colIndex), $event)\">\n                <span role=\"button\" class=\"fd-calendar__text\" [attr.aria-label]=\"getFullMonthName(rowIndex, colIndex)\">\n                    {{ month }}\n                </span>\n            </td>\n        </tr>\n        </tbody>\n    </table>\n</div>\n",
                    encapsulation: ViewEncapsulation.None,
                    host: {
                        '[attr.id]': 'id + "-month-view"'
                    },
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    styles: [""]
                }] }
    ];
    /** @nocollapse */
    CalendarMonthViewComponent.ctorParameters = function () { return [
        { type: ElementRef },
        { type: ChangeDetectorRef },
        { type: CalendarI18n },
        { type: CalendarService }
    ]; };
    CalendarMonthViewComponent.propDecorators = {
        id: [{ type: Input }],
        monthSelected: [{ type: Input }],
        focusEscapeFunction: [{ type: Input }],
        monthClicked: [{ type: Output }]
    };
    return CalendarMonthViewComponent;
}());
export { CalendarMonthViewComponent };
if (false) {
    /**
     * A number offset used to achieve the 1-12 representation of the calendar
     * @type {?}
     * @private
     */
    CalendarMonthViewComponent.prototype._monthOffset;
    /**
     * @type {?}
     * @private
     */
    CalendarMonthViewComponent.prototype._amountOfColPerRow;
    /**
     * @type {?}
     * @private
     */
    CalendarMonthViewComponent.prototype._shortMonthNames;
    /**
     * @type {?}
     * @private
     */
    CalendarMonthViewComponent.prototype._fullMonthNames;
    /**
     * An RxJS Subject that will kill the data stream upon componentâ€™s destruction (for unsubscribing)
     * @type {?}
     * @private
     */
    CalendarMonthViewComponent.prototype.onDestroy$;
    /**
     * The id of the calendar passed from the parent component
     * @type {?}
     */
    CalendarMonthViewComponent.prototype.id;
    /**
     * A number (1-12) representing the selected month
     * @type {?}
     */
    CalendarMonthViewComponent.prototype.monthSelected;
    /**
     * A function that handles escape focus
     * @type {?}
     */
    CalendarMonthViewComponent.prototype.focusEscapeFunction;
    /**
     * An event fired when a new month is selected
     * @type {?}
     */
    CalendarMonthViewComponent.prototype.monthClicked;
    /**
     * @type {?}
     * @private
     */
    CalendarMonthViewComponent.prototype.eRef;
    /**
     * @type {?}
     * @private
     */
    CalendarMonthViewComponent.prototype.cdRef;
    /**
     * @type {?}
     * @private
     */
    CalendarMonthViewComponent.prototype.calendarI18n;
    /**
     * @type {?}
     * @private
     */
    CalendarMonthViewComponent.prototype.calendarService;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2FsZW5kYXItbW9udGgtdmlldy5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AZnVuZGFtZW50YWwtbmd4L2NvcmUvIiwic291cmNlcyI6WyJsaWIvY2FsZW5kYXIvY2FsZW5kYXItdmlld3MvY2FsZW5kYXItbW9udGgtdmlldy9jYWxlbmRhci1tb250aC12aWV3LmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxPQUFPLEVBQ0gsU0FBUyxFQUNULEtBQUssRUFDTCxNQUFNLEVBQ04saUJBQWlCLEVBQ2pCLFlBQVksRUFDWixVQUFVLEVBR1YsaUJBQWlCLEVBQ2pCLHVCQUF1QixFQUMxQixNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUUsTUFBTSxFQUFFLE1BQU0sc0JBQXNCLENBQUM7QUFDOUMsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLDBCQUEwQixDQUFDO0FBQ3hELE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDL0IsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQzNDLE9BQU8sRUFBRSxlQUFlLEVBQUUsTUFBTSx3QkFBd0IsQ0FBQzs7OztBQUd6RDtJQXVDSSxvQ0FDWSxJQUFnQixFQUNoQixLQUF3QixFQUN4QixZQUEwQixFQUMxQixlQUFnQztRQUhoQyxTQUFJLEdBQUosSUFBSSxDQUFZO1FBQ2hCLFVBQUssR0FBTCxLQUFLLENBQW1CO1FBQ3hCLGlCQUFZLEdBQVosWUFBWSxDQUFjO1FBQzFCLG9CQUFlLEdBQWYsZUFBZSxDQUFpQjs7OztRQTlCM0IsaUJBQVksR0FBVyxDQUFDLENBQUM7UUFFekIsdUJBQWtCLEdBQVcsQ0FBQyxDQUFDOzs7O1FBTS9CLGVBQVUsR0FBa0IsSUFBSSxPQUFPLEVBQVEsQ0FBQzs7OztRQWdCeEQsaUJBQVksR0FBeUIsSUFBSSxZQUFZLEVBQVUsQ0FBQztJQVF6RSxDQUFDO0lBRUQsY0FBYzs7Ozs7SUFDZCw2Q0FB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SUFBSSxFQUFFO3dCQUNGLFdBQVcsRUFBRSxvQkFBb0I7cUJBQ3BDO29CQUNELGVBQWUsRUFBRSx1QkFBdUIsQ0FBQyxNQUFNOztpQkFDbEQ7Ozs7Z0JBdEJHLFVBQVU7Z0JBR1YsaUJBQWlCO2dCQUlaLFlBQVk7Z0JBR1osZUFBZTs7O3FCQTJCbkIsS0FBSztnQ0FJTCxLQUFLO3NDQUlMLEtBQUs7K0JBSUwsTUFBTTs7SUE0R1gsaUNBQUM7Q0FBQSxBQWhKRCxJQWdKQztTQXRJWSwwQkFBMEI7Ozs7Ozs7SUFHbkMsa0RBQTBDOzs7OztJQUUxQyx3REFBZ0Q7Ozs7O0lBRWhELHNEQUFxQzs7Ozs7SUFDckMscURBQWtDOzs7Ozs7SUFHbEMsZ0RBQWlFOzs7OztJQUdqRSx3Q0FDVzs7Ozs7SUFHWCxtREFDc0I7Ozs7O0lBR3RCLHlEQUM4Qjs7Ozs7SUFHOUIsa0RBQ3lFOzs7OztJQUdyRSwwQ0FBd0I7Ozs7O0lBQ3hCLDJDQUFnQzs7Ozs7SUFDaEMsa0RBQWtDOzs7OztJQUNsQyxxREFBd0MiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICAgIENvbXBvbmVudCxcbiAgICBJbnB1dCxcbiAgICBPdXRwdXQsXG4gICAgVmlld0VuY2Fwc3VsYXRpb24sXG4gICAgRXZlbnRFbWl0dGVyLFxuICAgIEVsZW1lbnRSZWYsXG4gICAgT25Jbml0LFxuICAgIE9uRGVzdHJveSxcbiAgICBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneVxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEZkRGF0ZSB9IGZyb20gJy4uLy4uL21vZGVscy9mZC1kYXRlJztcbmltcG9ydCB7IENhbGVuZGFySTE4biB9IGZyb20gJy4uLy4uL2kxOG4vY2FsZW5kYXItaTE4bic7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyB0YWtlVW50aWwgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBDYWxlbmRhclNlcnZpY2UgfSBmcm9tICcuLi8uLi9jYWxlbmRhci5zZXJ2aWNlJztcblxuLyoqIENvbXBvbmVudCByZXByZXNlbnRpbmcgdGhlIG1vbnRoIHZpZXcgb2YgdGhlIGNhbGVuZGFyLiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdmZC1jYWxlbmRhci1tb250aC12aWV3JyxcbiAgICB0ZW1wbGF0ZVVybDogJy4vY2FsZW5kYXItbW9udGgtdmlldy5jb21wb25lbnQuaHRtbCcsXG4gICAgc3R5bGVVcmxzOiBbJy4vY2FsZW5kYXItbW9udGgtdmlldy5jb21wb25lbnQuc2NzcyddLFxuICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gICAgaG9zdDoge1xuICAgICAgICAnW2F0dHIuaWRdJzogJ2lkICsgXCItbW9udGgtdmlld1wiJ1xuICAgIH0sXG4gICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcbn0pXG5leHBvcnQgY2xhc3MgQ2FsZW5kYXJNb250aFZpZXdDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQsIE9uRGVzdHJveSB7XG5cbiAgICAvKiogQSBudW1iZXIgb2Zmc2V0IHVzZWQgdG8gYWNoaWV2ZSB0aGUgMS0xMiByZXByZXNlbnRhdGlvbiBvZiB0aGUgY2FsZW5kYXIgKi9cbiAgICBwcml2YXRlIHJlYWRvbmx5IF9tb250aE9mZnNldDogbnVtYmVyID0gMTtcblxuICAgIHByaXZhdGUgcmVhZG9ubHkgX2Ftb3VudE9mQ29sUGVyUm93OiBudW1iZXIgPSA0O1xuXG4gICAgcHJpdmF0ZSBfc2hvcnRNb250aE5hbWVzOiBzdHJpbmdbXVtdO1xuICAgIHByaXZhdGUgX2Z1bGxNb250aE5hbWVzOiBzdHJpbmdbXTtcblxuICAgIC8qKiBBbiBSeEpTIFN1YmplY3QgdGhhdCB3aWxsIGtpbGwgdGhlIGRhdGEgc3RyZWFtIHVwb24gY29tcG9uZW504oCZcyBkZXN0cnVjdGlvbiAoZm9yIHVuc3Vic2NyaWJpbmcpICAqL1xuICAgIHByaXZhdGUgcmVhZG9ubHkgb25EZXN0cm95JDogU3ViamVjdDx2b2lkPiA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG5cbiAgICAvKiogVGhlIGlkIG9mIHRoZSBjYWxlbmRhciBwYXNzZWQgZnJvbSB0aGUgcGFyZW50IGNvbXBvbmVudCAqL1xuICAgIEBJbnB1dCgpXG4gICAgaWQ6IHN0cmluZztcblxuICAgIC8qKiBBIG51bWJlciAoMS0xMikgcmVwcmVzZW50aW5nIHRoZSBzZWxlY3RlZCBtb250aCAqL1xuICAgIEBJbnB1dCgpXG4gICAgbW9udGhTZWxlY3RlZDogbnVtYmVyO1xuXG4gICAgLyoqIEEgZnVuY3Rpb24gdGhhdCBoYW5kbGVzIGVzY2FwZSBmb2N1cyAqL1xuICAgIEBJbnB1dCgpXG4gICAgZm9jdXNFc2NhcGVGdW5jdGlvbjogRnVuY3Rpb247XG5cbiAgICAvKiogQW4gZXZlbnQgZmlyZWQgd2hlbiBhIG5ldyBtb250aCBpcyBzZWxlY3RlZCAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHJlYWRvbmx5IG1vbnRoQ2xpY2tlZDogRXZlbnRFbWl0dGVyPG51bWJlcj4gPSBuZXcgRXZlbnRFbWl0dGVyPG51bWJlcj4oKTtcblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBwcml2YXRlIGVSZWY6IEVsZW1lbnRSZWYsXG4gICAgICAgIHByaXZhdGUgY2RSZWY6IENoYW5nZURldGVjdG9yUmVmLFxuICAgICAgICBwcml2YXRlIGNhbGVuZGFySTE4bjogQ2FsZW5kYXJJMThuLFxuICAgICAgICBwcml2YXRlIGNhbGVuZGFyU2VydmljZTogQ2FsZW5kYXJTZXJ2aWNlXG4gICAgKSB7XG4gICAgfVxuXG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBuZ09uSW5pdCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5jYWxlbmRhclNlcnZpY2UuZm9jdXNFc2NhcGVGdW5jdGlvbiA9IHRoaXMuZm9jdXNFc2NhcGVGdW5jdGlvbjtcbiAgICAgICAgdGhpcy5yZWZyZXNoU2hvcnRNb250aE5hbWVzKCk7XG5cbiAgICAgICAgdGhpcy5jYWxlbmRhclNlcnZpY2Uub25Gb2N1c0lkQ2hhbmdlXG4gICAgICAgICAgICAucGlwZSh0YWtlVW50aWwodGhpcy5vbkRlc3Ryb3kkKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoaW5kZXggPT4gdGhpcy5mb2N1c0VsZW1lbnQoJyMnICsgdGhpcy5pZCArICctZmQtbW9udGgtJyArIGluZGV4KSlcbiAgICAgICAgO1xuXG4gICAgICAgIHRoaXMuY2FsZW5kYXJTZXJ2aWNlLm9uS2V5U2VsZWN0XG4gICAgICAgICAgICAucGlwZSh0YWtlVW50aWwodGhpcy5vbkRlc3Ryb3kkKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoaW5kZXggPT4gdGhpcy5zZWxlY3RNb250aChpbmRleCkpXG4gICAgICAgIDtcblxuICAgICAgICB0aGlzLmNhbGVuZGFySTE4bi5pMThuQ2hhbmdlXG4gICAgICAgICAgICAucGlwZSh0YWtlVW50aWwodGhpcy5vbkRlc3Ryb3kkKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKCkgPT4gdGhpcy5yZWZyZXNoU2hvcnRNb250aE5hbWVzKCkpXG4gICAgICAgIDtcbiAgICB9XG5cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgICAgICB0aGlzLm9uRGVzdHJveSQubmV4dCgpO1xuICAgICAgICB0aGlzLm9uRGVzdHJveSQuY29tcGxldGUoKTtcbiAgICB9XG5cbiAgICAvKiogR2V0IGEgbnVtYmVyICgxLTEyKSByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgbW9udGggICovXG4gICAgZ2V0IGN1cnJlbnRNb250aCgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gRmREYXRlLmdldFRvZGF5KCkubW9udGg7XG4gICAgfVxuXG4gICAgLyoqICBHZXR0ZXIgZm9yIHRoZSBwcml2YXRlIGNsYXNzIG1lbWJlciBfbW9udGhPZmZzZXQgKi9cbiAgICBnZXQgbW9udGhPZmZzZXQoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoT2Zmc2V0O1xuICAgIH1cblxuICAgIC8qKiBNZXRob2QgZm9yIGhhbmRsaW5nIHRoZSBtb3VzZSBjbGljayBldmVudCB3aGVuIGEgbW9udGggaXMgc2VsZWN0ZWQgICovXG4gICAgc2VsZWN0TW9udGgoc2VsZWN0ZWRNb250aDogbnVtYmVyLCBldmVudD86IE1vdXNlRXZlbnQpOiB2b2lkIHtcbiAgICAgICAgaWYgKGV2ZW50KSB7XG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1vbnRoU2VsZWN0ZWQgPSBzZWxlY3RlZE1vbnRoICsgdGhpcy5tb250aE9mZnNldDtcbiAgICAgICAgdGhpcy5tb250aENsaWNrZWQuZW1pdCh0aGlzLm1vbnRoU2VsZWN0ZWQpO1xuICAgIH1cblxuICAgIC8qKiBNZXRob2QgZm9yIGhhbmRsaW5nIHRoZSBrZXlib2FyZCBldmVudHMgKGExMXkpICovXG4gICAgb25LZXlkb3duTW9udGhIYW5kbGVyKGV2ZW50LCBpbmRleDogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIHRoaXMuY2FsZW5kYXJTZXJ2aWNlLm9uS2V5ZG93bkhhbmRsZXIoZXZlbnQsIGluZGV4KTtcbiAgICB9XG5cbiAgICAvKiogTWV0aG9kIHRoYXQgYWxsb3dzIHRvIGZvY3VzIGVsZW1lbnRzIGluc2lkZSB0aGlzIGNvbXBvbmVudCAqL1xuICAgIGZvY3VzRWxlbWVudChlbGVtZW50U2VsZWN0b3I6IHN0cmluZyk6IHZvaWQge1xuICAgICAgICBjb25zdCBlbGVtZW50VG9Gb2N1czogSFRNTEVsZW1lbnQgPSB0aGlzLmVSZWYubmF0aXZlRWxlbWVudC5xdWVyeVNlbGVjdG9yKGVsZW1lbnRTZWxlY3Rvcik7XG4gICAgICAgIGlmIChlbGVtZW50VG9Gb2N1cykge1xuICAgICAgICAgICAgZWxlbWVudFRvRm9jdXMuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBNZXRob2QgcmV0dXJuaW5nIGlkIG9mIG1vbnRoIGNlbGwgKi9cbiAgICBnZXRJZChyb3dJbmRleDogbnVtYmVyLCBjb2xJbmRleDogbnVtYmVyKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHJvd0luZGV4ICogdGhpcy5fYW1vdW50T2ZDb2xQZXJSb3cgKyBjb2xJbmRleDtcbiAgICB9XG5cbiAgICAvKiogTWV0aG9kIHRoYXQgY2hlY2tzIGlmIHRoaXMgaXMgY3VycmVudCBtb250aCAqL1xuICAgIGlzQ3VycmVudChpZDogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiBpZCArIHRoaXMuX21vbnRoT2Zmc2V0ID09PSB0aGlzLmN1cnJlbnRNb250aDtcbiAgICB9XG5cbiAgICAvKiogTWV0aG9kIHRoYXQgY2hlY2sgaWYgdGhpcyBpcyBzZWxlY3RlZCBtb250aCAqL1xuICAgIGlzU2VsZWN0ZWQoaWQ6IG51bWJlcik6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gaWQgKyB0aGlzLl9tb250aE9mZnNldCA9PT0gdGhpcy5tb250aFNlbGVjdGVkO1xuICAgIH1cblxuICAgIC8qKiBNZXRob2QgdGhhdCByZXR1cm5zIGdyaWQgb2Ygc2hvcnQgbW9udGggbmFtZXMgZnJvbSBjdXJyZW50bHkgcHJvdmlkZWQgY2FsZW5kYXJJMThuIHNlcnZpY2UgKi9cbiAgICBnZXQgc2hvcnRNb250aE5hbWVzKCk6IHN0cmluZ1tdW10ge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2hvcnRNb250aE5hbWVzO1xuICAgIH1cblxuICAgIC8qKiBNZXRob2QgdGhhdCByZXR1cm5zIHRoZSBmdWxsIG5hbWUgb2YgbW9udGggZm9yIGdyaWQgZWxlbWVudC4gKi9cbiAgICBnZXRGdWxsTW9udGhOYW1lKHJvd0luZGV4OiBudW1iZXIsIGNvbEluZGV4OiBudW1iZXIpOiBzdHJpbmcge1xuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuZ2V0SWQocm93SW5kZXgsIGNvbEluZGV4KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Z1bGxNb250aE5hbWVzW2luZGV4XTtcbiAgICB9XG5cbiAgICAvKiogTWV0aG9kIHRoYXQgcmV3cml0ZSBzaG9ydCBtb250aCBuYW1lcywgdXNlZCBtb3N0bHkgaW4gY2FzZSBvZiBpMThuIHNlcnZpY2UgbGFuZ3VhZ2UgY2hhbmdlICovXG4gICAgcHJpdmF0ZSByZWZyZXNoU2hvcnRNb250aE5hbWVzKCk6IHZvaWQge1xuICAgICAgICBjb25zdCBtb250aE5hbWVzOiBzdHJpbmdbXSA9IFsuLi50aGlzLmNhbGVuZGFySTE4bi5nZXRBbGxTaG9ydE1vbnRoTmFtZXMoKV07XG4gICAgICAgIHRoaXMuX2Z1bGxNb250aE5hbWVzID0gWy4uLnRoaXMuY2FsZW5kYXJJMThuLmdldEFsbEZ1bGxNb250aE5hbWVzKCldO1xuICAgICAgICBjb25zdCB0d29EaW1lbnNpb25Nb250aE5hbWVzOiBzdHJpbmdbXVtdID0gW107XG4gICAgICAgIC8qKiBDcmVhdGluZyAyZCBncmlkICovXG4gICAgICAgIHdoaWxlIChtb250aE5hbWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgdHdvRGltZW5zaW9uTW9udGhOYW1lcy5wdXNoKG1vbnRoTmFtZXMuc3BsaWNlKDAsIHRoaXMuX2Ftb3VudE9mQ29sUGVyUm93KSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2hvcnRNb250aE5hbWVzID0gdHdvRGltZW5zaW9uTW9udGhOYW1lcztcbiAgICAgICAgdGhpcy5jZFJlZi5tYXJrRm9yQ2hlY2soKTtcbiAgICB9XG59XG4iXX0=