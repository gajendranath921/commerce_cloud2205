"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.OperationExecutionManager = void 0;
const os = __importStar(require("os"));
const safe_1 = __importDefault(require("colors/safe"));
const terminal_1 = require("@rushstack/terminal");
const stream_collator_1 = require("@rushstack/stream-collator");
const node_core_library_1 = require("@rushstack/node-core-library");
const Stopwatch_1 = require("../../utilities/Stopwatch");
const AsyncOperationQueue_1 = require("./AsyncOperationQueue");
const OperationStatus_1 = require("./OperationStatus");
/**
 * Format "======" lines for a shell window with classic 80 columns
 */
const ASCII_HEADER_WIDTH = 79;
/**
 * A class which manages the execution of a set of tasks with interdependencies.
 * Initially, and at the end of each task execution, all unblocked tasks
 * are added to a ready queue which is then executed. This is done continually until all
 * tasks are complete, or prematurely fails if any of the tasks fail.
 */
class OperationExecutionManager {
    constructor(operations, options) {
        this._streamCollator_onWriterActive = (writer) => {
            if (writer) {
                this._completedOperations++;
                // Format a header like this
                //
                // ==[ @rushstack/the-long-thing ]=================[ 1 of 1000 ]==
                // leftPart: "==[ @rushstack/the-long-thing "
                const leftPart = safe_1.default.gray('==[') + ' ' + safe_1.default.cyan(writer.taskName) + ' ';
                const leftPartLength = 4 + writer.taskName.length + 1;
                // rightPart: " 1 of 1000 ]=="
                const completedOfTotal = `${this._completedOperations} of ${this._totalOperations}`;
                const rightPart = ' ' + safe_1.default.white(completedOfTotal) + ' ' + safe_1.default.gray(']==');
                const rightPartLength = 1 + completedOfTotal.length + 4;
                // middlePart: "]=================["
                const twoBracketsLength = 2;
                const middlePartLengthMinusTwoBrackets = Math.max(ASCII_HEADER_WIDTH - (leftPartLength + rightPartLength + twoBracketsLength), 0);
                const middlePart = safe_1.default.gray(']' + '='.repeat(middlePartLengthMinusTwoBrackets) + '[');
                this._terminal.writeStdoutLine('\n' + leftPart + middlePart + rightPart);
                if (!this._quietMode) {
                    this._terminal.writeStdoutLine('');
                }
            }
        };
        const { quietMode, debugMode, parallelism, changedProjectsOnly, repoCommandLineConfiguration } = options;
        this._operations = operations;
        this._completedOperations = 0;
        this._totalOperations = operations.size;
        this._quietMode = quietMode;
        this._debugMode = debugMode;
        this._hasAnyFailures = false;
        this._hasAnyNonAllowedWarnings = false;
        this._changedProjectsOnly = changedProjectsOnly;
        this._repoCommandLineConfiguration = repoCommandLineConfiguration;
        // TERMINAL PIPELINE:
        //
        // streamCollator --> colorsNewlinesTransform --> StdioWritable
        //
        this._outputWritable = options.destination ? options.destination : terminal_1.StdioWritable.instance;
        this._colorsNewlinesTransform = new terminal_1.TextRewriterTransform({
            destination: this._outputWritable,
            normalizeNewlines: node_core_library_1.NewlineKind.OsDefault,
            removeColors: !safe_1.default.enabled
        });
        this._streamCollator = new stream_collator_1.StreamCollator({
            destination: this._colorsNewlinesTransform,
            onWriterActive: this._streamCollator_onWriterActive
        });
        this._terminal = this._streamCollator.terminal;
        const numberOfCores = os.cpus().length;
        if (parallelism) {
            if (parallelism === 'max') {
                this._parallelism = numberOfCores;
            }
            else {
                const parallelismInt = parseInt(parallelism, 10);
                if (isNaN(parallelismInt)) {
                    throw new Error(`Invalid parallelism value of '${parallelism}', expected a number or 'max'`);
                }
                this._parallelism = parallelismInt;
            }
        }
        else {
            // If an explicit parallelism number wasn't provided, then choose a sensible
            // default.
            if (os.platform() === 'win32') {
                // On desktop Windows, some people have complained that their system becomes
                // sluggish if Rush is using all the CPU cores.  Leave one thread for
                // other operations. For CI environments, you can use the "max" argument to use all available cores.
                this._parallelism = Math.max(numberOfCores - 1, 1);
            }
            else {
                // Unix-like operating systems have more balanced scheduling, so default
                // to the number of CPU cores
                this._parallelism = numberOfCores;
            }
        }
    }
    /**
     * Executes all operations which have been registered, returning a promise which is resolved when all the
     * operations are completed successfully, or rejects when any operation fails.
     */
    async executeAsync() {
        this._completedOperations = 0;
        const totalTasks = this._totalOperations;
        if (!this._quietMode) {
            const plural = totalTasks === 1 ? '' : 's';
            this._terminal.writeStdoutLine(`Selected ${totalTasks} project${plural}:`);
            this._terminal.writeStdoutLine(Array.from(this._operations, (x) => `  ${x.name}`)
                .sort()
                .join('\n'));
            this._terminal.writeStdoutLine('');
        }
        this._terminal.writeStdoutLine(`Executing a maximum of ${this._parallelism} simultaneous processes...`);
        const maxParallelism = Math.min(totalTasks, this._parallelism);
        const prioritySort = (a, b) => {
            let diff = a.criticalPathLength - b.criticalPathLength;
            if (diff) {
                return diff;
            }
            diff = a.dependents.size - b.dependents.size;
            if (diff) {
                return diff;
            }
            // No further default considerations.
            return 0;
        };
        const executionQueue = new AsyncOperationQueue_1.AsyncOperationQueue(this._operations, prioritySort);
        // Iterate in parallel with maxParallelism concurrent lanes
        await Promise.all(Array.from({ length: maxParallelism }, async (unused, index) => {
            var e_1, _a;
            // laneId can be used in logging to examine concurrency
            const laneId = index + 1;
            try {
                // The executionQueue is a singular async iterable that stalls until an operation is available, and marks itself
                // done when the queue is empty.
                for (var executionQueue_1 = __asyncValues(executionQueue), executionQueue_1_1; executionQueue_1_1 = await executionQueue_1.next(), !executionQueue_1_1.done;) {
                    const operations = executionQueue_1_1.value;
                    // Take an operation, execute it, wait for it to finish, wait for a new operations
                    await this._executeOperationAsync(operations, laneId);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (executionQueue_1_1 && !executionQueue_1_1.done && (_a = executionQueue_1.return)) await _a.call(executionQueue_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }));
        this._printOperationStatus();
        if (this._hasAnyFailures) {
            this._terminal.writeStderrLine(safe_1.default.red('Projects failed to build.') + '\n');
            throw new node_core_library_1.AlreadyReportedError();
        }
        else if (this._hasAnyNonAllowedWarnings) {
            this._terminal.writeStderrLine(safe_1.default.yellow('Projects succeeded with warnings.') + '\n');
            throw new node_core_library_1.AlreadyReportedError();
        }
    }
    async _executeOperationAsync(operation, tid) {
        operation.status = OperationStatus_1.OperationStatus.Executing;
        operation.stopwatch = Stopwatch_1.Stopwatch.start();
        operation.collatedWriter = this._streamCollator.registerTask(operation.name);
        operation.stdioSummarizer = new terminal_1.StdioSummarizer();
        const context = {
            repoCommandLineConfiguration: this._repoCommandLineConfiguration,
            stdioSummarizer: operation.stdioSummarizer,
            collatedWriter: operation.collatedWriter,
            quietMode: this._quietMode,
            debugMode: this._debugMode
        };
        try {
            const result = await operation.runner.executeAsync(context);
            operation.stopwatch.stop();
            operation.stdioSummarizer.close();
            switch (result) {
                case OperationStatus_1.OperationStatus.Success:
                    this._markAsSuccess(operation);
                    break;
                case OperationStatus_1.OperationStatus.SuccessWithWarning:
                    this._hasAnyNonAllowedWarnings =
                        this._hasAnyNonAllowedWarnings || !operation.runner.warningsAreAllowed;
                    this._markAsSuccessWithWarning(operation);
                    break;
                case OperationStatus_1.OperationStatus.FromCache:
                    this._markAsFromCache(operation);
                    break;
                case OperationStatus_1.OperationStatus.Skipped:
                    this._markAsSkipped(operation);
                    break;
                case OperationStatus_1.OperationStatus.Failure:
                    this._hasAnyFailures = true;
                    this._markAsFailed(operation);
                    break;
            }
        }
        catch (error) {
            operation.stdioSummarizer.close();
            this._hasAnyFailures = true;
            // eslint-disable-next-line require-atomic-updates
            operation.error = error;
            this._markAsFailed(operation);
        }
        operation.collatedWriter.close();
    }
    /**
     * Marks an operation as having failed and marks each of its dependents as blocked
     */
    _markAsFailed(operation) {
        if (operation.error) {
            operation.collatedWriter.terminal.writeStderrLine(operation.error.message);
        }
        operation.collatedWriter.terminal.writeStderrLine(safe_1.default.red(`"${operation.name}" failed to build.`));
        operation.status = OperationStatus_1.OperationStatus.Failure;
        operation.dependents.forEach((dependent) => {
            this._markAsBlocked(dependent, operation);
        });
    }
    /**
     * Marks an operation and all its dependents as blocked
     */
    _markAsBlocked(blockedOperation, failedOperation) {
        if (blockedOperation.status === OperationStatus_1.OperationStatus.Ready) {
            this._completedOperations++;
            // Note: We cannot write to blockedOperation.collatedWriter because "blockedOperation" will be skipped
            failedOperation.collatedWriter.terminal.writeStdoutLine(`"${blockedOperation.name}" is blocked by "${failedOperation.name}".`);
            blockedOperation.status = OperationStatus_1.OperationStatus.Blocked;
            blockedOperation.dependents.forEach((dependent) => {
                this._markAsBlocked(dependent, failedOperation);
            });
        }
    }
    /**
     * Marks an operation as being completed, and removes it from the dependencies list of all its dependents
     */
    _markAsSuccess(operation) {
        if (operation.runner.hadEmptyScript) {
            operation.collatedWriter.terminal.writeStdoutLine(safe_1.default.green(`"${operation.name}" had an empty script.`));
        }
        else {
            operation.collatedWriter.terminal.writeStdoutLine(safe_1.default.green(`"${operation.name}" completed successfully in ${operation.stopwatch.toString()}.`));
        }
        operation.status = OperationStatus_1.OperationStatus.Success;
        operation.dependents.forEach((dependent) => {
            if (!this._changedProjectsOnly) {
                dependent.runner.isSkipAllowed = false;
            }
            dependent.dependencies.delete(operation);
        });
    }
    /**
     * Marks an operation as being completed, but with warnings written to stderr, and removes it from the dependencies
     * list of all its dependents
     */
    _markAsSuccessWithWarning(operation) {
        operation.collatedWriter.terminal.writeStderrLine(safe_1.default.yellow(`"${operation.name}" completed with warnings in ${operation.stopwatch.toString()}.`));
        operation.status = OperationStatus_1.OperationStatus.SuccessWithWarning;
        operation.dependents.forEach((dependent) => {
            if (!this._changedProjectsOnly) {
                dependent.runner.isSkipAllowed = false;
            }
            dependent.dependencies.delete(operation);
        });
    }
    /**
     * Marks an operation as skipped.
     */
    _markAsSkipped(operation) {
        operation.collatedWriter.terminal.writeStdoutLine(safe_1.default.green(`${operation.name} was skipped.`));
        operation.status = OperationStatus_1.OperationStatus.Skipped;
        operation.dependents.forEach((dependent) => {
            dependent.dependencies.delete(operation);
        });
        const invalidationQueue = new Set(operation.dependents);
        for (const consumer of invalidationQueue) {
            // If an operation is skipped, state is not guaranteed in downstream tasks, so block cache write
            consumer.runner.isCacheWriteAllowed = false;
            // Propagate through the entire build queue applying cache write prevention.
            for (const indirectConsumer of consumer.dependents) {
                invalidationQueue.add(indirectConsumer);
            }
        }
    }
    /**
     * Marks an operation as provided by cache.
     */
    _markAsFromCache(operation) {
        operation.collatedWriter.terminal.writeStdoutLine(safe_1.default.green(`${operation.name} was restored from the build cache.`));
        operation.status = OperationStatus_1.OperationStatus.FromCache;
        operation.dependents.forEach((dependent) => {
            dependent.dependencies.delete(operation);
        });
    }
    /**
     * Prints out a report of the status of each project
     */
    _printOperationStatus() {
        const operationsByStatus = {};
        for (const operation of this._operations) {
            switch (operation.status) {
                // These are the sections that we will report below
                case OperationStatus_1.OperationStatus.Skipped:
                case OperationStatus_1.OperationStatus.FromCache:
                case OperationStatus_1.OperationStatus.Success:
                case OperationStatus_1.OperationStatus.SuccessWithWarning:
                case OperationStatus_1.OperationStatus.Blocked:
                case OperationStatus_1.OperationStatus.Failure:
                    break;
                default:
                    // This should never happen
                    throw new node_core_library_1.InternalError('Unexpected task status: ' + operation.status);
            }
            if (operationsByStatus[operation.status]) {
                operationsByStatus[operation.status].push(operation);
            }
            else {
                operationsByStatus[operation.status] = [operation];
            }
        }
        // Skip a few lines before we start the summary
        this._terminal.writeStdoutLine('');
        this._terminal.writeStdoutLine('');
        this._terminal.writeStdoutLine('');
        // These are ordered so that the most interesting statuses appear last:
        this._writeCondensedSummary(OperationStatus_1.OperationStatus.Skipped, operationsByStatus, safe_1.default.green, 'These projects were already up to date:');
        this._writeCondensedSummary(OperationStatus_1.OperationStatus.FromCache, operationsByStatus, safe_1.default.green, 'These projects were restored from the build cache:');
        this._writeCondensedSummary(OperationStatus_1.OperationStatus.Success, operationsByStatus, safe_1.default.green, 'These projects completed successfully:');
        this._writeDetailedSummary(OperationStatus_1.OperationStatus.SuccessWithWarning, operationsByStatus, safe_1.default.yellow, 'WARNING');
        this._writeCondensedSummary(OperationStatus_1.OperationStatus.Blocked, operationsByStatus, safe_1.default.white, 'These projects were blocked by dependencies that failed:');
        this._writeDetailedSummary(OperationStatus_1.OperationStatus.Failure, operationsByStatus, safe_1.default.red);
        this._terminal.writeStdoutLine('');
    }
    _writeCondensedSummary(status, operationsByStatus, headingColor, preamble) {
        // Example:
        //
        // ==[ BLOCKED: 4 projects ]==============================================================
        //
        // These projects were blocked by dependencies that failed:
        //   @scope/name
        //   e
        //   k
        const operations = operationsByStatus[status];
        if (!operations || operations.length === 0) {
            return;
        }
        node_core_library_1.Sort.sortBy(operations, (x) => x.name);
        this._writeSummaryHeader(status, operations, headingColor);
        this._terminal.writeStdoutLine(preamble);
        const longestTaskName = Math.max(...operations.map((x) => x.name.length));
        for (const operation of operations) {
            if (operation.stopwatch &&
                !operation.runner.hadEmptyScript &&
                operation.status !== OperationStatus_1.OperationStatus.Skipped) {
                const time = operation.stopwatch.toString();
                const padding = ' '.repeat(longestTaskName - operation.name.length);
                this._terminal.writeStdoutLine(`  ${operation.name}${padding}    ${time}`);
            }
            else {
                this._terminal.writeStdoutLine(`  ${operation.name}`);
            }
        }
        this._terminal.writeStdoutLine('');
    }
    _writeDetailedSummary(status, operationsByStatus, headingColor, shortStatusName) {
        // Example:
        //
        // ==[ SUCCESS WITH WARNINGS: 2 projects ]================================
        //
        // --[ WARNINGS: f ]------------------------------------[ 5.07 seconds ]--
        //
        // [eslint] Warning: src/logic/operations/OperationsExecutionManager.ts:393:3 ...
        const operations = operationsByStatus[status];
        if (!operations || operations.length === 0) {
            return;
        }
        this._writeSummaryHeader(status, operations, headingColor);
        if (shortStatusName === undefined) {
            shortStatusName = status;
        }
        for (const operation of operations) {
            // Format a header like this
            //
            // --[ WARNINGS: f ]------------------------------------[ 5.07 seconds ]--
            // leftPart: "--[ WARNINGS: f "
            const subheadingText = `${shortStatusName}: ${operation.name}`;
            const leftPart = safe_1.default.gray('--[') + ' ' + headingColor(subheadingText) + ' ';
            const leftPartLength = 4 + subheadingText.length + 1;
            // rightPart: " 5.07 seconds ]--"
            const time = operation.stopwatch.toString();
            const rightPart = ' ' + safe_1.default.white(time) + ' ' + safe_1.default.gray(']--');
            const rightPartLength = 1 + time.length + 1 + 3;
            // middlePart: "]----------------------["
            const twoBracketsLength = 2;
            const middlePartLengthMinusTwoBrackets = Math.max(ASCII_HEADER_WIDTH - (leftPartLength + rightPartLength + twoBracketsLength), 0);
            const middlePart = safe_1.default.gray(']' + '-'.repeat(middlePartLengthMinusTwoBrackets) + '[');
            this._terminal.writeStdoutLine(leftPart + middlePart + rightPart + '\n');
            const details = operation.stdioSummarizer.getReport();
            if (details) {
                // Don't write a newline, because the report will always end with a newline
                this._terminal.writeChunk({ text: details, kind: "O" /* Stdout */ });
            }
            this._terminal.writeStdoutLine('');
        }
    }
    _writeSummaryHeader(status, operations, headingColor) {
        // Format a header like this
        //
        // ==[ FAILED: 2 projects ]================================================
        // "2 projects"
        const projectsText = `${operations.length}${operations.length === 1 ? ' project' : ' projects'}`;
        const headingText = `${status}: ${projectsText}`;
        // leftPart: "==[ FAILED: 2 projects "
        const leftPart = `${safe_1.default.gray('==[')} ${headingColor(headingText)} `;
        const leftPartLength = 3 + 1 + headingText.length + 1;
        const rightPartLengthMinusBracket = Math.max(ASCII_HEADER_WIDTH - (leftPartLength + 1), 0);
        // rightPart: "]======================"
        const rightPart = safe_1.default.gray(`]${'='.repeat(rightPartLengthMinusBracket)}`);
        this._terminal.writeStdoutLine(leftPart + rightPart);
        this._terminal.writeStdoutLine('');
    }
}
exports.OperationExecutionManager = OperationExecutionManager;
//# sourceMappingURL=OperationExecutionManager.js.map