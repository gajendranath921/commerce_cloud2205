{"version":3,"file":"OperationSelector.js","sourceRoot":"","sources":["../../../src/logic/operations/OperationSelector.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport type { RushConfigurationProject } from '../../api/RushConfigurationProject';\nimport type { IPhase } from '../../api/CommandLineConfiguration';\nimport type { Operation } from './Operation';\n\nexport interface IOperationSelectorOptions {\n  phasesToRun: ReadonlySet<IPhase>;\n}\n\nexport interface ICreateOperationsOptions {\n  projectSelection: ReadonlySet<RushConfigurationProject>;\n  operationFactory: IOperationFactory;\n}\n\nexport interface IOperationOptions {\n  project: RushConfigurationProject;\n  phase: IPhase;\n}\n\nexport interface IOperationFactory {\n  createTask(options: IOperationOptions): Operation;\n}\n\ninterface IOperationDependencies {\n  operations: Set<Operation> | undefined;\n  isCacheWriteAllowed: boolean;\n}\n\ninterface IOperationNode {\n  key: string;\n  phase: IPhase;\n  project: RushConfigurationProject;\n}\n\ninterface ISelectedOperationNode extends IOperationNode {\n  operation: Operation;\n}\n\n/**\n * This class is responsible for transforming a set of selected phases and selected projects into an operation dependency graph.\n */\nexport class OperationSelector {\n  private readonly _phasesToRun: ReadonlySet<IPhase>;\n\n  public constructor(options: IOperationSelectorOptions) {\n    this._phasesToRun = options.phasesToRun;\n  }\n\n  public createOperations(createTasksOptions: ICreateOperationsOptions): Set<Operation> {\n    const { projectSelection, operationFactory: taskFactory } = createTasksOptions;\n\n    const selectedNodes: Map<string, ISelectedOperationNode> = new Map();\n    const selectedOperations: Set<Operation> = new Set();\n\n    // Create tasks for selected phases and projects\n    for (const phase of this._phasesToRun) {\n      for (const project of projectSelection) {\n        const operation: Operation = taskFactory.createTask({\n          phase,\n          project\n        });\n\n        const key: string = getOperationKey(phase, project);\n\n        const record: ISelectedOperationNode = {\n          key,\n          phase,\n          project,\n          operation\n        };\n\n        selectedNodes.set(key, record);\n        selectedOperations.add(operation);\n      }\n    }\n\n    // Convert the [IPhase, RushConfigurationProject] into a value suitable for use as a Map key\n    function getOperationKey(phase: IPhase, project: RushConfigurationProject): string {\n      return `${project.packageName};${phase.name}`;\n    }\n\n    /**\n     * Enumerates the declared dependencies\n     */\n    function* getRawDependencies(node: IOperationNode): Iterable<IOperationNode> {\n      const {\n        phase: {\n          phaseDependencies: { self, upstream }\n        },\n        project\n      } = node;\n\n      for (const depPhase of self) {\n        // Different phase, same project\n        yield {\n          key: getOperationKey(depPhase, project),\n          phase: depPhase,\n          project\n        };\n      }\n\n      if (upstream.size) {\n        const { dependencyProjects } = project;\n        if (dependencyProjects.size) {\n          for (const depPhase of upstream) {\n            for (const dependencyProject of dependencyProjects) {\n              yield {\n                key: getOperationKey(depPhase, dependencyProject),\n                phase: depPhase,\n                project: dependencyProject\n              };\n            }\n          }\n        }\n      }\n    }\n\n    const filteredDependencyCache: Map<string, IOperationDependencies> = new Map();\n    function getFilteredDependencies(node: IOperationNode): IOperationDependencies {\n      const { key } = node;\n      const cached: IOperationDependencies | undefined = filteredDependencyCache.get(key);\n      if (cached) {\n        return cached;\n      }\n\n      const dependencies: IOperationDependencies = {\n        operations: undefined,\n        isCacheWriteAllowed: selectedNodes.has(key)\n      };\n\n      filteredDependencyCache.set(key, dependencies);\n\n      for (const dep of getRawDependencies(node)) {\n        const selectedRecord: ISelectedOperationNode | undefined = selectedNodes.get(dep.key);\n        if (selectedRecord) {\n          // This operation is part of the current execution\n          if (!dependencies.operations) {\n            dependencies.operations = new Set();\n          }\n          dependencies.operations.add(selectedRecord.operation);\n        } else {\n          // This operation is not part of the current execution, but may have dependencies that are\n          // Since an operation has been excluded, we cannot guarantee the results, so it is cache unsafe\n          dependencies.isCacheWriteAllowed = false;\n          const { operations: indirectDependencies }: IOperationDependencies = getFilteredDependencies(dep);\n          if (indirectDependencies) {\n            if (!dependencies.operations) {\n              dependencies.operations = new Set();\n            }\n\n            for (const indirectDep of indirectDependencies) {\n              dependencies.operations.add(indirectDep);\n            }\n          }\n        }\n      }\n\n      return dependencies;\n    }\n\n    // Add dependency relationships\n    for (const record of selectedNodes.values()) {\n      const deps: IOperationDependencies = getFilteredDependencies(record);\n      if (deps.operations) {\n        for (const dependencyOperation of deps.operations) {\n          record.operation.dependencies.add(dependencyOperation);\n          dependencyOperation.dependents.add(record.operation);\n        }\n      }\n\n      record.operation.runner.isCacheWriteAllowed = deps.isCacheWriteAllowed;\n    }\n\n    return selectedOperations;\n  }\n}\n"]}