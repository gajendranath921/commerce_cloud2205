"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
exports.OperationSelector = void 0;
/**
 * This class is responsible for transforming a set of selected phases and selected projects into an operation dependency graph.
 */
class OperationSelector {
    constructor(options) {
        this._phasesToRun = options.phasesToRun;
    }
    createOperations(createTasksOptions) {
        const { projectSelection, operationFactory: taskFactory } = createTasksOptions;
        const selectedNodes = new Map();
        const selectedOperations = new Set();
        // Create tasks for selected phases and projects
        for (const phase of this._phasesToRun) {
            for (const project of projectSelection) {
                const operation = taskFactory.createTask({
                    phase,
                    project
                });
                const key = getOperationKey(phase, project);
                const record = {
                    key,
                    phase,
                    project,
                    operation
                };
                selectedNodes.set(key, record);
                selectedOperations.add(operation);
            }
        }
        // Convert the [IPhase, RushConfigurationProject] into a value suitable for use as a Map key
        function getOperationKey(phase, project) {
            return `${project.packageName};${phase.name}`;
        }
        /**
         * Enumerates the declared dependencies
         */
        function* getRawDependencies(node) {
            const { phase: { phaseDependencies: { self, upstream } }, project } = node;
            for (const depPhase of self) {
                // Different phase, same project
                yield {
                    key: getOperationKey(depPhase, project),
                    phase: depPhase,
                    project
                };
            }
            if (upstream.size) {
                const { dependencyProjects } = project;
                if (dependencyProjects.size) {
                    for (const depPhase of upstream) {
                        for (const dependencyProject of dependencyProjects) {
                            yield {
                                key: getOperationKey(depPhase, dependencyProject),
                                phase: depPhase,
                                project: dependencyProject
                            };
                        }
                    }
                }
            }
        }
        const filteredDependencyCache = new Map();
        function getFilteredDependencies(node) {
            const { key } = node;
            const cached = filteredDependencyCache.get(key);
            if (cached) {
                return cached;
            }
            const dependencies = {
                operations: undefined,
                isCacheWriteAllowed: selectedNodes.has(key)
            };
            filteredDependencyCache.set(key, dependencies);
            for (const dep of getRawDependencies(node)) {
                const selectedRecord = selectedNodes.get(dep.key);
                if (selectedRecord) {
                    // This operation is part of the current execution
                    if (!dependencies.operations) {
                        dependencies.operations = new Set();
                    }
                    dependencies.operations.add(selectedRecord.operation);
                }
                else {
                    // This operation is not part of the current execution, but may have dependencies that are
                    // Since an operation has been excluded, we cannot guarantee the results, so it is cache unsafe
                    dependencies.isCacheWriteAllowed = false;
                    const { operations: indirectDependencies } = getFilteredDependencies(dep);
                    if (indirectDependencies) {
                        if (!dependencies.operations) {
                            dependencies.operations = new Set();
                        }
                        for (const indirectDep of indirectDependencies) {
                            dependencies.operations.add(indirectDep);
                        }
                    }
                }
            }
            return dependencies;
        }
        // Add dependency relationships
        for (const record of selectedNodes.values()) {
            const deps = getFilteredDependencies(record);
            if (deps.operations) {
                for (const dependencyOperation of deps.operations) {
                    record.operation.dependencies.add(dependencyOperation);
                    dependencyOperation.dependents.add(record.operation);
                }
            }
            record.operation.runner.isCacheWriteAllowed = deps.isCacheWriteAllowed;
        }
        return selectedOperations;
    }
}
exports.OperationSelector = OperationSelector;
//# sourceMappingURL=OperationSelector.js.map