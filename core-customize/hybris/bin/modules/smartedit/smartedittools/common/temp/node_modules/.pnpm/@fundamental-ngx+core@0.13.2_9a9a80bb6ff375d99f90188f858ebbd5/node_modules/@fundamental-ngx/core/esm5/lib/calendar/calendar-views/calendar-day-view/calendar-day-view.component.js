/**
 * @fileoverview added by tsickle
 * Generated from: lib/calendar/calendar-views/calendar-day-view/calendar-day-view.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { ChangeDetectionStrategy, ChangeDetectorRef, Component, ElementRef, EventEmitter, HostBinding, Input, Output, ViewEncapsulation } from '@angular/core';
import { CalendarI18n } from '../../i18n/calendar-i18n';
import { FdDate } from '../../models/fd-date';
import { CalendarService } from '../../calendar.service';
import { Subject } from 'rxjs';
import { takeUntil } from 'rxjs/operators';
/**
 * Component representing the day view of the calendar.
 */
var CalendarDayViewComponent = /** @class */ (function () {
    /** @hidden */
    function CalendarDayViewComponent(calendarI18n, eRef, changeDetRef) {
        var _this = this;
        this.calendarI18n = calendarI18n;
        this.eRef = eRef;
        this.changeDetRef = changeDetRef;
        /**
         * @hidden
         */
        this.newFocusedDayId = '';
        /**
         * @hidden
         */
        this.fdCalendarDateViewClass = true;
        /**
         * The type of calendar, 'single' for single date selection or 'range' for a range of dates.
         */
        this.calType = 'single';
        /**
         * Event emitted always, when model is changed in range mode
         */
        this.selectedRangeDateChange = new EventEmitter();
        /**
         * Event emitted always, when next month is selected, by focus
         */
        this.nextMonthSelect = new EventEmitter();
        /**
         * Event emitted always, when previous month is selected, by focus
         */
        this.previousMonthSelect = new EventEmitter();
        /**
         * Event emitted always, when model is changed in single mode
         */
        this.selectedDateChange = new EventEmitter();
        /**
         * An RxJS Subject that will kill the data stream upon component’s destruction (for unsubscribing)
         */
        this.onDestroy$ = new Subject();
        /**
         * Function used to disable certain dates in the calendar.
         * @param fdDate FdDate
         */
        this.disableFunction = (/**
         * @param {?} fdDate
         * @return {?}
         */
        function (fdDate) {
            return false;
        });
        /**
         * Function used to disable certain dates in the calendar for the range start selection.
         * @param fdDate FdDate
         */
        this.disableRangeStartFunction = (/**
         * @param {?} fdDate
         * @return {?}
         */
        function (fdDate) {
            return false;
        });
        /**
         * Function used to disable certain dates in the calendar for the range end selection.
         * @param fdDate FdDate
         */
        this.disableRangeEndFunction = (/**
         * @param {?} fdDate
         * @return {?}
         */
        function (fdDate) {
            return false;
        });
        /**
         * Function used to block certain dates in the calendar for the range start selection.
         * @param fdDate FdDate
         */
        this.blockRangeStartFunction = (/**
         * @param {?} fdDate
         * @return {?}
         */
        function (fdDate) {
            return false;
        });
        /**
         * Function used to block certain dates in the calendar for the range end selection.
         * @param fdDate FdDate
         */
        this.blockRangeEndFunction = (/**
         * @param {?} fdDate
         * @return {?}
         */
        function (fdDate) {
            return false;
        });
        /**
         * Function used to block certain dates in the calendar.
         * @param fdDate FdDate
         */
        this.blockFunction = (/**
         * @param {?} fdDate
         * @return {?}
         */
        function (fdDate) {
            return false;
        });
        this.calendarI18n.i18nChange
            .pipe(takeUntil(this.onDestroy$))
            .subscribe((/**
         * @return {?}
         */
        function () { return _this.refreshShortWeekDays(); }));
    }
    /**
     * Function for selecting a date on the calendar. Typically called when a date is clicked, but can also be called programmatically.
     * @param day CalendarDay object to be selected.
     */
    /**
     * Function for selecting a date on the calendar. Typically called when a date is clicked, but can also be called programmatically.
     * @param {?} day CalendarDay object to be selected.
     * @param {?=} event
     * @return {?}
     */
    CalendarDayViewComponent.prototype.selectDate = /**
     * Function for selecting a date on the calendar. Typically called when a date is clicked, but can also be called programmatically.
     * @param {?} day CalendarDay object to be selected.
     * @param {?=} event
     * @return {?}
     */
    function (day, event) {
        if (event) {
            /**
             * There are some problems with popup integration. After clicking inside day component, the popover closes.
             */
            event.stopPropagation();
            event.preventDefault();
            this.newFocusedDayId = day.id;
            this.focusElement(this.newFocusedDayId);
        }
        if (!day.blocked && !day.disabled) {
            if (this.calType === 'single') {
                this.selectedDate = day.date;
                this.selectedDateChange.emit(day.date);
                this.buildDayViewGrid();
            }
            else {
                if (this.selectCounter === 0 || this.selectCounter === 2) {
                    this.selectedRangeDate = { start: day.date, end: null };
                    this.selectedRangeDateChange.emit(this.selectedRangeDate);
                    this.buildDayViewGrid();
                }
                else if (this.selectCounter === 1) {
                    // Check if date picked is higher than already chosen, otherwise just reverse them
                    if (this.selectedRangeDate.start.getTimeStamp() < day.date.getTimeStamp()) {
                        this.selectedRangeDate = { start: this.selectedRangeDate.start, end: day.date };
                    }
                    else {
                        this.selectedRangeDate = { start: day.date, end: this.selectedRangeDate.start };
                    }
                    this.selectedRangeDateChange.emit(this.selectedRangeDate);
                    this.buildDayViewGrid();
                }
            }
        }
    };
    /** @hidden */
    /**
     * @hidden
     * @return {?}
     */
    CalendarDayViewComponent.prototype.ngOnInit = /**
     * @hidden
     * @return {?}
     */
    function () {
        this.refreshShortWeekDays();
        this.buildDayViewGrid();
    };
    /** @hidden */
    /**
     * @hidden
     * @return {?}
     */
    CalendarDayViewComponent.prototype.ngOnDestroy = /**
     * @hidden
     * @return {?}
     */
    function () {
        this.onDestroy$.next();
        this.onDestroy$.complete();
    };
    Object.defineProperty(CalendarDayViewComponent.prototype, "selectCounter", {
        /** @hidden
         *  Amount of selected days
         *  0, when there is no day selected, or start date is invalid,
         *  1, when there is only valid start date, or end date is same as start date,
         *  2, when both dates are valid
         */
        get: /**
         * @hidden
         *  Amount of selected days
         *  0, when there is no day selected, or start date is invalid,
         *  1, when there is only valid start date, or end date is same as start date,
         *  2, when both dates are valid
         * @return {?}
         */
        function () {
            if (!this.selectedRangeDate || !this.selectedRangeDate.start || !this.selectedRangeDate.start.isDateValid()) {
                return 0;
            }
            else if (this.selectedRangeDate.start &&
                (!this.selectedRangeDate.end || !this.selectedRangeDate.end.isDateValid() ||
                    CalendarService.datesEqual(this.selectedRangeDate.start, this.selectedRangeDate.end))) {
                return 1;
            }
            else if (this.selectedRangeDate.start && this.selectedRangeDate.start.isDateValid() &&
                this.selectedRangeDate.end && this.selectedRangeDate.end.isDateValid()) {
                return 2;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     * Method that handles day cells keydown events,
     * @param event KeyboardEvent
     * @param cell CalendarDay
     * @param grid with specified column and row as a x and y
     */
    /**
     * @hidden
     * Method that handles day cells keydown events,
     * @param {?} event KeyboardEvent
     * @param {?} cell CalendarDay
     * @param {?} grid with specified column and row as a x and y
     * @return {?}
     */
    CalendarDayViewComponent.prototype.onKeydownDayHandler = /**
     * @hidden
     * Method that handles day cells keydown events,
     * @param {?} event KeyboardEvent
     * @param {?} cell CalendarDay
     * @param {?} grid with specified column and row as a x and y
     * @return {?}
     */
    function (event, cell, grid) {
        if (event.key === 'Tab' && !event.shiftKey) {
            if (this.focusEscapeFunction) {
                event.preventDefault();
                this.focusEscapeFunction();
            }
        }
        else {
            switch (event.key) {
                case (' '):
                case ('Enter'): {
                    event.preventDefault();
                    this.selectDate(cell);
                    this.newFocusedDayId = cell.id;
                    break;
                }
                case ('ArrowUp'): {
                    event.preventDefault();
                    if (grid.y > 0) {
                        this.newFocusedDayId = this.dayViewGrid[grid.y - 1][grid.x].id;
                    }
                    else {
                        this.selectPreviousMonth();
                        this.newFocusedDayId = this.dayViewGrid[this.dayViewGrid.length - 1][grid.x].id;
                    }
                    break;
                }
                case ('ArrowDown'): {
                    event.preventDefault();
                    if (grid.y < this.dayViewGrid.length - 1) {
                        this.newFocusedDayId = this.dayViewGrid[grid.y + 1][grid.x].id;
                    }
                    else {
                        this.selectNextMonth();
                        this.newFocusedDayId = this.dayViewGrid[0][grid.x].id;
                    }
                    break;
                }
                case ('ArrowLeft'): {
                    event.preventDefault();
                    if (grid.x > 0) {
                        this.newFocusedDayId = this.dayViewGrid[grid.y][grid.x - 1].id;
                    }
                    else if (grid.y > 0) {
                        this.newFocusedDayId = this.dayViewGrid[grid.y - 1][this.dayViewGrid[0].length - 1].id;
                    }
                    else {
                        this.selectPreviousMonth();
                        this.newFocusedDayId =
                            this.dayViewGrid[this.dayViewGrid.length - 1][this.dayViewGrid[0].length - 1].id;
                    }
                    break;
                }
                case ('ArrowRight'): {
                    event.preventDefault();
                    if (grid.x < this.dayViewGrid[0].length - 1) {
                        this.newFocusedDayId = this.dayViewGrid[grid.y][grid.x + 1].id;
                    }
                    else if (grid.y < this.dayViewGrid.length - 1) {
                        this.newFocusedDayId = this.dayViewGrid[grid.y + 1][0].id;
                    }
                    else {
                        this.selectNextMonth();
                        this.newFocusedDayId = this.dayViewGrid[0][0].id;
                    }
                    break;
                }
            }
        }
        if (this.newFocusedDayId) {
            this.focusElement(this.newFocusedDayId);
        }
    };
    /** @hidden */
    /**
     * @hidden
     * @return {?}
     */
    CalendarDayViewComponent.prototype.ngOnChanges = /**
     * @hidden
     * @return {?}
     */
    function () {
        this.buildDayViewGrid();
    };
    /** @hidden
     *  Method that allow to focus elements inside this component
     */
    /**
     * @hidden
     *  Method that allow to focus elements inside this component
     * @param {?} elementSelector
     * @return {?}
     */
    CalendarDayViewComponent.prototype.focusElement = /**
     * @hidden
     *  Method that allow to focus elements inside this component
     * @param {?} elementSelector
     * @return {?}
     */
    function (elementSelector) {
        var _this = this;
        if (this.newFocusedDayId) {
            this.newFocusedDayId = '';
            setTimeout((/**
             * @return {?}
             */
            function () {
                /** @type {?} */
                var elementToFocus = _this.eRef.nativeElement.querySelector('#' + elementSelector);
                if (elementToFocus) {
                    elementToFocus.focus();
                }
            }), 0);
        }
    };
    /** Active day means that with tabindex = 0, it's selected day or today or first day */
    /**
     * Active day means that with tabindex = 0, it's selected day or today or first day
     * @return {?}
     */
    CalendarDayViewComponent.prototype.focusActiveDay = /**
     * Active day means that with tabindex = 0, it's selected day or today or first day
     * @return {?}
     */
    function () {
        this.newFocusedDayId = this.getActiveCell(this.calendarDayList.filter((/**
         * @param {?} cell
         * @return {?}
         */
        function (cell) { return cell.monthStatus === 'current'; }))).id;
        this.focusElement(this.newFocusedDayId);
    };
    Object.defineProperty(CalendarDayViewComponent.prototype, "calendarDayList", {
        /** Function that gives array of all displayed CalendarDays */
        get: /**
         * Function that gives array of all displayed CalendarDays
         * @return {?}
         */
        function () {
            return this.dayViewGrid.reduce((/**
             * @param {?} totalCalendarRows
             * @param {?} calendarRow
             * @return {?}
             */
            function (totalCalendarRows, calendarRow) {
                if (!calendarRow) {
                    calendarRow = [];
                }
                return totalCalendarRows.concat(calendarRow);
            }));
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Method that selects previous month
     * Triggered only when the month is changed during changing focus
     * Also triggers event to parent calendar component and rebuilds day view grid
     */
    /**
     * Method that selects previous month
     * Triggered only when the month is changed during changing focus
     * Also triggers event to parent calendar component and rebuilds day view grid
     * @private
     * @return {?}
     */
    CalendarDayViewComponent.prototype.selectPreviousMonth = /**
     * Method that selects previous month
     * Triggered only when the month is changed during changing focus
     * Also triggers event to parent calendar component and rebuilds day view grid
     * @private
     * @return {?}
     */
    function () {
        if (this.currentlyDisplayed.month > 1) {
            this.currentlyDisplayed = tslib_1.__assign({}, this.currentlyDisplayed, { month: this.currentlyDisplayed.month - 1 });
        }
        else {
            this.currentlyDisplayed = { year: this.currentlyDisplayed.year - 1, month: 12 };
        }
        this.buildDayViewGrid();
        this.previousMonthSelect.emit();
    };
    /**
     * Method that selects next month
     * Triggered only when the month is changed during changing focus
     * Also triggers event to parent calendar component and rebuilds day view grid
     */
    /**
     * Method that selects next month
     * Triggered only when the month is changed during changing focus
     * Also triggers event to parent calendar component and rebuilds day view grid
     * @private
     * @return {?}
     */
    CalendarDayViewComponent.prototype.selectNextMonth = /**
     * Method that selects next month
     * Triggered only when the month is changed during changing focus
     * Also triggers event to parent calendar component and rebuilds day view grid
     * @private
     * @return {?}
     */
    function () {
        if (this.currentlyDisplayed.month > 1) {
            this.currentlyDisplayed = tslib_1.__assign({}, this.currentlyDisplayed, { month: this.currentlyDisplayed.month + 1 });
        }
        else {
            this.currentlyDisplayed = { year: this.currentlyDisplayed.year + 1, month: 1 };
        }
        this.buildDayViewGrid();
        this.nextMonthSelect.emit();
    };
    /**
     * Method that creates array of CalendarDay models which will be shown on day grid,
     * depending on current month and year.
     */
    /**
     * Method that creates array of CalendarDay models which will be shown on day grid,
     * depending on current month and year.
     * @private
     * @return {?}
     */
    CalendarDayViewComponent.prototype.populateCalendar = /**
     * Method that creates array of CalendarDay models which will be shown on day grid,
     * depending on current month and year.
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var calendar = [];
        calendar = this.getPreviousMonthDays(calendar);
        calendar = calendar.concat(this.getCurrentMonthDays());
        calendar = this.getNextMonthDays(calendar);
        calendar.forEach((/**
         * @param {?} call
         * @param {?} index
         * @return {?}
         */
        function (call, index) { return call.id = _this.id + '-fd-day-' + (Math.floor(index / 7) + 1) + '' + (index % 7); }));
        return calendar;
    };
    /**
     * Method that builds 2 dimensions day view grid, also sets up currently displayed month, or year,
     * when there is not any.
     */
    /**
     * Method that builds 2 dimensions day view grid, also sets up currently displayed month, or year,
     * when there is not any.
     * @private
     * @return {?}
     */
    CalendarDayViewComponent.prototype.buildDayViewGrid = /**
     * Method that builds 2 dimensions day view grid, also sets up currently displayed month, or year,
     * when there is not any.
     * @private
     * @return {?}
     */
    function () {
        if (!this.currentlyDisplayed) {
            if (this.selectedDate) {
                this.currentlyDisplayed = { month: this.selectedDate.month, year: this.selectedDate.year };
            }
            else {
                this.currentlyDisplayed = { month: FdDate.getToday().month, year: FdDate.getToday().year };
            }
        }
        /** @type {?} */
        var calendarDays = this.populateCalendar();
        /** @type {?} */
        var dayViewGrid = [];
        while (calendarDays.length > 0) {
            dayViewGrid.push(calendarDays.splice(0, 7));
        }
        this.dayViewGrid = dayViewGrid;
        return;
    };
    /**
     * Method which provides array of CalendarDay, which contains every single day of currently shown month/year.
     */
    /**
     * Method which provides array of CalendarDay, which contains every single day of currently shown month/year.
     * @private
     * @return {?}
     */
    CalendarDayViewComponent.prototype.getCurrentMonthDays = /**
     * Method which provides array of CalendarDay, which contains every single day of currently shown month/year.
     * @private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var month = this.currentlyDisplayed.month;
        /** @type {?} */
        var year = this.currentlyDisplayed.year;
        /** @type {?} */
        var calendarDays = [];
        /** @type {?} */
        var amountOfDaysInCurrentMonth = CalendarService.getDaysInMonth(month, year);
        for (var dayNumber = 1; dayNumber <= amountOfDaysInCurrentMonth; dayNumber++) {
            /** @type {?} */
            var fdDate = new FdDate(year, month, dayNumber);
            calendarDays.push(tslib_1.__assign({}, this.getDay(fdDate), { monthStatus: 'current', today: CalendarService.datesEqual(FdDate.getToday(), fdDate) }));
        }
        this.getActiveCell(calendarDays).isTabIndexed = true;
        return calendarDays;
    };
    /**
     * Method that returns active cell, which means:
     * if there is any selected day, return selected day
     * if there is no selected day, but there is today day, return today day
     * if there is no today, or selected, return first one
     */
    /**
     * Method that returns active cell, which means:
     * if there is any selected day, return selected day
     * if there is no selected day, but there is today day, return today day
     * if there is no today, or selected, return first one
     * @private
     * @param {?} calendarDays
     * @return {?}
     */
    CalendarDayViewComponent.prototype.getActiveCell = /**
     * Method that returns active cell, which means:
     * if there is any selected day, return selected day
     * if there is no selected day, but there is today day, return today day
     * if there is no today, or selected, return first one
     * @private
     * @param {?} calendarDays
     * @return {?}
     */
    function (calendarDays) {
        if (calendarDays.find((/**
         * @param {?} cell
         * @return {?}
         */
        function (cell) { return cell.selected; }))) {
            return calendarDays.find((/**
             * @param {?} cell
             * @return {?}
             */
            function (cell) { return cell.selected; }));
        }
        else if (calendarDays.find((/**
         * @param {?} cell
         * @return {?}
         */
        function (cell) { return cell.today; }))) {
            return calendarDays.find((/**
             * @param {?} cell
             * @return {?}
             */
            function (cell) { return cell.today; }));
        }
        else {
            return calendarDays[0];
        }
    };
    /**
     * Method which provides array of CalendarDay, which contains last 0-6 days of previous month/year. Theses days
     * fills the gap between starting startingDayOfWeek and first day of current month
     */
    /**
     * Method which provides array of CalendarDay, which contains last 0-6 days of previous month/year. Theses days
     * fills the gap between starting startingDayOfWeek and first day of current month
     * @private
     * @param {?} calendarDays
     * @return {?}
     */
    CalendarDayViewComponent.prototype.getPreviousMonthDays = /**
     * Method which provides array of CalendarDay, which contains last 0-6 days of previous month/year. Theses days
     * fills the gap between starting startingDayOfWeek and first day of current month
     * @private
     * @param {?} calendarDays
     * @return {?}
     */
    function (calendarDays) {
        /** @type {?} */
        var month = this.currentlyDisplayed.month > 1 ? this.currentlyDisplayed.month - 1 : 12;
        /** @type {?} */
        var year = this.currentlyDisplayed.month > 1 ? this.currentlyDisplayed.year : this.currentlyDisplayed.year - 1;
        /** @type {?} */
        var amountOfDaysInCurrentMonth = CalendarService.getDaysInMonth(month, year);
        /** @type {?} */
        var prevMonthLastDate = new FdDate(year, month, amountOfDaysInCurrentMonth);
        /** @type {?} */
        var prevMonthLastDay = amountOfDaysInCurrentMonth;
        /** @type {?} */
        var prevMonthLastWeekDay = prevMonthLastDate.getDay() - this.startingDayOfWeek;
        /** Checking if there are some days cut by startingDayOfWeek option
         *  If yes, there is whole week added, to avoid hiding
         */
        if (prevMonthLastWeekDay < 0) {
            prevMonthLastWeekDay = prevMonthLastWeekDay + 7;
        }
        if (prevMonthLastWeekDay < 6) {
            while (prevMonthLastWeekDay >= 0) {
                /** @type {?} */
                var prevMonthDay = prevMonthLastDay - prevMonthLastWeekDay;
                /** @type {?} */
                var fdDate = new FdDate(year, month, prevMonthDay);
                calendarDays.push(tslib_1.__assign({}, this.getDay(fdDate), { monthStatus: 'previous' }));
                prevMonthLastWeekDay--;
            }
        }
        return calendarDays;
    };
    /**
     * Method which provides array of CalendarDay, which contains first days of next month/year. Theses days
     * fills the gap between last day of current day and end of 6-weeks calendar grid.
     */
    /**
     * Method which provides array of CalendarDay, which contains first days of next month/year. Theses days
     * fills the gap between last day of current day and end of 6-weeks calendar grid.
     * @private
     * @param {?} calendarDays
     * @return {?}
     */
    CalendarDayViewComponent.prototype.getNextMonthDays = /**
     * Method which provides array of CalendarDay, which contains first days of next month/year. Theses days
     * fills the gap between last day of current day and end of 6-weeks calendar grid.
     * @private
     * @param {?} calendarDays
     * @return {?}
     */
    function (calendarDays) {
        /** @type {?} */
        var month = this.currentlyDisplayed.month < 12 ? this.currentlyDisplayed.month + 1 : 1;
        /** @type {?} */
        var year = this.currentlyDisplayed.month < 12 ? this.currentlyDisplayed.year : this.currentlyDisplayed.year + 1;
        // The calendar grid can have 6 (42 days) weeks
        /** @type {?} */
        var nextMonthDisplayedDays = 42 - calendarDays.length;
        for (var nextD = 1; nextD <= nextMonthDisplayedDays; nextD++) {
            /** @type {?} */
            var fdDate = new FdDate(year, month, nextD);
            calendarDays.push(tslib_1.__assign({}, this.getDay(fdDate), { monthStatus: 'next' }));
        }
        return calendarDays;
    };
    /**
     * Method that generates whole day model basing on fdDate, disabling functions, block functions, and actually
     * chosen range / single date.
     */
    /**
     * Method that generates whole day model basing on fdDate, disabling functions, block functions, and actually
     * chosen range / single date.
     * @private
     * @param {?} fdDate
     * @return {?}
     */
    CalendarDayViewComponent.prototype.getDay = /**
     * Method that generates whole day model basing on fdDate, disabling functions, block functions, and actually
     * chosen range / single date.
     * @private
     * @param {?} fdDate
     * @return {?}
     */
    function (fdDate) {
        /** @type {?} */
        var day = {
            date: fdDate,
            weekDay: fdDate.getDay(),
            disabled: this.disableFunction(fdDate),
            blocked: this.blockFunction(fdDate),
            selected: ((this.calType === 'single' && CalendarService.datesEqual(fdDate, this.selectedDate)) ||
                (this.selectedRangeDate && CalendarService.datesEqual(fdDate, this.selectedRangeDate.start)) ||
                (this.selectedRangeDate && CalendarService.datesEqual(fdDate, this.selectedRangeDate.end))),
            selectedFirst: (this.selectedRangeDate && CalendarService.datesEqual(fdDate, this.selectedRangeDate.start)),
            selectedLast: (this.selectedRangeDate && CalendarService.datesEqual(fdDate, this.selectedRangeDate.end)),
            selectedRange: (this.selectedRangeDate && ((this.selectedRangeDate.start && (this.selectedRangeDate.start.getTimeStamp() < fdDate.getTimeStamp())) &&
                (this.selectedRangeDate.end && (this.selectedRangeDate.end.getTimeStamp() > fdDate.getTimeStamp())))),
            ariaLabel: this.calendarI18n.getDayAriaLabel(fdDate.toDate())
        };
        if (this.calType === 'range' && (this.selectCounter === 0 || this.selectCounter === 2)) {
            if (this.disableRangeStartFunction && !day.disabled) {
                day.disabled = this.disableRangeStartFunction(day.date);
            }
            if (this.blockRangeStartFunction && !day.blocked) {
                day.blocked = this.blockRangeStartFunction(day.date);
            }
        }
        else if (this.selectCounter === 1) {
            if (this.disableRangeEndFunction && !day.disabled) {
                day.disabled = this.disableRangeEndFunction(day.date);
            }
            if (this.blockRangeEndFunction && !day.blocked) {
                day.blocked = this.blockRangeEndFunction(day.date);
            }
        }
        return day;
    };
    Object.defineProperty(CalendarDayViewComponent.prototype, "shortWeekDays", {
        /**
         * Method that returns first letter of every weekday, basing on CalendarI18nDefault. Can be changed by user by
         * providing other class which implements CalendarI18n
         */
        get: /**
         * Method that returns first letter of every weekday, basing on CalendarI18nDefault. Can be changed by user by
         * providing other class which implements CalendarI18n
         * @return {?}
         */
        function () {
            return this._shortWeekDays;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Method that is called to refresh i18n short week days.
     */
    /**
     * Method that is called to refresh i18n short week days.
     * @private
     * @return {?}
     */
    CalendarDayViewComponent.prototype.refreshShortWeekDays = /**
     * Method that is called to refresh i18n short week days.
     * @private
     * @return {?}
     */
    function () {
        this._shortWeekDays = this.calendarI18n.getAllShortWeekdays()
            .slice(this.startingDayOfWeek - 1)
            .concat(this.calendarI18n.getAllShortWeekdays().slice(0, this.startingDayOfWeek - 1))
            .map((/**
         * @param {?} weekday
         * @return {?}
         */
        function (weekday) { return weekday[0].toLocaleUpperCase(); }));
        this.changeDetRef.markForCheck();
    };
    CalendarDayViewComponent.decorators = [
        { type: Component, args: [{
                    selector: 'fd-calendar-day-view',
                    template: "<table class=\"fd-calendar__table\" role=\"grid\">\n    <thead class=\"fd-calendar__group\">\n    <tr class=\"fd-calendar__row\">\n        <th class=\"fd-calendar__column-header\" *ngFor=\"let day of shortWeekDays\">\n            <span class=\"fd-calendar__day-of-week\">{{day}}</span>\n        </th>\n    </tr>\n    </thead>\n    <tbody class=\"fd-calendar__group\">\n    <tr class=\"fd-calendar__row\"\n        *ngFor=\"let row of dayViewGrid; let rowIndex = index;\">\n\n        <td class=\"fd-calendar__item\"\n            role=\"gridcell\"\n            *ngFor=\"let cell of row; let cellIndex = index;\"\n            [ngClass]=\"{\n                    'fd-calendar__item--other-month': cell.monthStatus !== 'current',\n                    'is-selected': cell.selected,\n                    'is-selected-range-last': cell.selectedLast && !cell.selectedFirst,\n                    'is-selected-range-first': cell.selectedFirst && selectCounter == 2,\n                    'is-selected-range': cell.selectedRange && !cell.selectedFirst && !cell.selectedLast,\n                    'fd-calendar__item--current': cell.today,\n                    'is-disabled': cell.disabled,\n                    'is-blocked': cell.blocked\n                }\"\n            [attr.id]=\"cell.id\"\n            [attr.aria-disabled]=\"cell.disabled || cell.blocked\"\n            [attr.tabindex]=\"cell.isTabIndexed ? 0 : -1\"\n            (click)=\"selectDate(cell, $event)\"\n            (keydown)=\"onKeydownDayHandler($event, cell, { x: cellIndex, y: rowIndex })\"\n        >\n            <span class=\"fd-calendar__text\" role=\"button\" [attr.aria-label]=\"cell.ariaLabel\">{{cell.date.day}}</span>\n        </td>\n    </tr>\n    </tbody>\n</table>\n",
                    encapsulation: ViewEncapsulation.None,
                    host: {
                        '[attr.id]': 'id + "-day-view"'
                    },
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    styles: [""]
                }] }
    ];
    /** @nocollapse */
    CalendarDayViewComponent.ctorParameters = function () { return [
        { type: CalendarI18n },
        { type: ElementRef },
        { type: ChangeDetectorRef }
    ]; };
    CalendarDayViewComponent.propDecorators = {
        fdCalendarDateViewClass: [{ type: HostBinding, args: ['class.fd-calendar__dates',] }],
        currentlyDisplayed: [{ type: Input }],
        selectedDate: [{ type: Input }],
        selectedRangeDate: [{ type: Input }],
        startingDayOfWeek: [{ type: Input }],
        calType: [{ type: Input }],
        id: [{ type: Input }],
        focusEscapeFunction: [{ type: Input }],
        selectedRangeDateChange: [{ type: Output }],
        nextMonthSelect: [{ type: Output }],
        previousMonthSelect: [{ type: Output }],
        selectedDateChange: [{ type: Output }],
        disableFunction: [{ type: Input }],
        disableRangeStartFunction: [{ type: Input }],
        disableRangeEndFunction: [{ type: Input }],
        blockRangeStartFunction: [{ type: Input }],
        blockRangeEndFunction: [{ type: Input }],
        blockFunction: [{ type: Input }]
    };
    return CalendarDayViewComponent;
}());
export { CalendarDayViewComponent };
if (false) {
    /**
     * @hidden
     * @type {?}
     */
    CalendarDayViewComponent.prototype.newFocusedDayId;
    /**
     * Actual day grid with previous/current/next month days
     * @type {?}
     */
    CalendarDayViewComponent.prototype.dayViewGrid;
    /**
     * @hidden
     * @type {?}
     */
    CalendarDayViewComponent.prototype.fdCalendarDateViewClass;
    /**
     * Currently displayed month and year for days
     * @type {?}
     */
    CalendarDayViewComponent.prototype.currentlyDisplayed;
    /**
     * The currently selected FdDate model in single mode.
     * @type {?}
     */
    CalendarDayViewComponent.prototype.selectedDate;
    /**
     * The currently selected FdDates model start and end in range mode.
     * @type {?}
     */
    CalendarDayViewComponent.prototype.selectedRangeDate;
    /**
     * The day of the week the calendar should start on. 1 represents Sunday, 2 is Monday, 3 is Tuesday, and so on.
     * @type {?}
     */
    CalendarDayViewComponent.prototype.startingDayOfWeek;
    /**
     * The type of calendar, 'single' for single date selection or 'range' for a range of dates.
     * @type {?}
     */
    CalendarDayViewComponent.prototype.calType;
    /**
     * Id of the calendar. If none is provided, one will be generated.
     * @type {?}
     */
    CalendarDayViewComponent.prototype.id;
    /**
     * Function that allows to specify which function would be called, when focus wants to escape
     * @type {?}
     */
    CalendarDayViewComponent.prototype.focusEscapeFunction;
    /**
     * Event emitted always, when model is changed in range mode
     * @type {?}
     */
    CalendarDayViewComponent.prototype.selectedRangeDateChange;
    /**
     * Event emitted always, when next month is selected, by focus
     * @type {?}
     */
    CalendarDayViewComponent.prototype.nextMonthSelect;
    /**
     * Event emitted always, when previous month is selected, by focus
     * @type {?}
     */
    CalendarDayViewComponent.prototype.previousMonthSelect;
    /**
     * Event emitted always, when model is changed in single mode
     * @type {?}
     */
    CalendarDayViewComponent.prototype.selectedDateChange;
    /**
     * An RxJS Subject that will kill the data stream upon component’s destruction (for unsubscribing)
     * @type {?}
     * @private
     */
    CalendarDayViewComponent.prototype.onDestroy$;
    /**
     * Variable that contains first letter of every weekday, basing on CalendarI18nDefault.
     * @type {?}
     * @private
     */
    CalendarDayViewComponent.prototype._shortWeekDays;
    /**
     * Function used to disable certain dates in the calendar.
     * \@param fdDate FdDate
     * @type {?}
     */
    CalendarDayViewComponent.prototype.disableFunction;
    /**
     * Function used to disable certain dates in the calendar for the range start selection.
     * \@param fdDate FdDate
     * @type {?}
     */
    CalendarDayViewComponent.prototype.disableRangeStartFunction;
    /**
     * Function used to disable certain dates in the calendar for the range end selection.
     * \@param fdDate FdDate
     * @type {?}
     */
    CalendarDayViewComponent.prototype.disableRangeEndFunction;
    /**
     * Function used to block certain dates in the calendar for the range start selection.
     * \@param fdDate FdDate
     * @type {?}
     */
    CalendarDayViewComponent.prototype.blockRangeStartFunction;
    /**
     * Function used to block certain dates in the calendar for the range end selection.
     * \@param fdDate FdDate
     * @type {?}
     */
    CalendarDayViewComponent.prototype.blockRangeEndFunction;
    /**
     * Function used to block certain dates in the calendar.
     * \@param fdDate FdDate
     * @type {?}
     */
    CalendarDayViewComponent.prototype.blockFunction;
    /**
     * @type {?}
     * @private
     */
    CalendarDayViewComponent.prototype.calendarI18n;
    /**
     * @type {?}
     * @private
     */
    CalendarDayViewComponent.prototype.eRef;
    /**
     * @type {?}
     * @private
     */
    CalendarDayViewComponent.prototype.changeDetRef;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2FsZW5kYXItZGF5LXZpZXcuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6Im5nOi8vQGZ1bmRhbWVudGFsLW5neC9jb3JlLyIsInNvdXJjZXMiOlsibGliL2NhbGVuZGFyL2NhbGVuZGFyLXZpZXdzL2NhbGVuZGFyLWRheS12aWV3L2NhbGVuZGFyLWRheS12aWV3LmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxPQUFPLEVBQ0gsdUJBQXVCLEVBQUUsaUJBQWlCLEVBQzFDLFNBQVMsRUFDVCxVQUFVLEVBQ1YsWUFBWSxFQUNaLFdBQVcsRUFDWCxLQUFLLEVBRUwsTUFBTSxFQUNOLGlCQUFpQixFQUNwQixNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sMEJBQTBCLENBQUM7QUFDeEQsT0FBTyxFQUFFLE1BQU0sRUFBRSxNQUFNLHNCQUFzQixDQUFDO0FBSTlDLE9BQU8sRUFBRSxlQUFlLEVBQUUsTUFBTSx3QkFBd0IsQ0FBQztBQUV6RCxPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQy9CLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQzs7OztBQUczQztJQStISSxjQUFjO0lBQ2Qsa0NBQ1ksWUFBMEIsRUFDMUIsSUFBZ0IsRUFDaEIsWUFBK0I7UUFIM0MsaUJBU0M7UUFSVyxpQkFBWSxHQUFaLFlBQVksQ0FBYztRQUMxQixTQUFJLEdBQUosSUFBSSxDQUFZO1FBQ2hCLGlCQUFZLEdBQVosWUFBWSxDQUFtQjs7OztRQXRIM0Msb0JBQWUsR0FBVyxFQUFFLENBQUM7Ozs7UUFPdEIsNEJBQXVCLEdBQVksSUFBSSxDQUFDOzs7O1FBb0IvQyxZQUFPLEdBQWlCLFFBQVEsQ0FBQzs7OztRQVdqQiw0QkFBdUIsR0FBOEIsSUFBSSxZQUFZLEVBQWUsQ0FBQzs7OztRQUlyRixvQkFBZSxHQUF1QixJQUFJLFlBQVksRUFBUSxDQUFDOzs7O1FBSS9ELHdCQUFt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SUUsZ0RBQWtDOzs7OztJQUNsQyx3Q0FBd0I7Ozs7O0lBQ3hCLGdEQUF1QyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gICAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksIENoYW5nZURldGVjdG9yUmVmLFxuICAgIENvbXBvbmVudCxcbiAgICBFbGVtZW50UmVmLFxuICAgIEV2ZW50RW1pdHRlcixcbiAgICBIb3N0QmluZGluZyxcbiAgICBJbnB1dCwgT25DaGFuZ2VzLCBPbkRlc3Ryb3ksXG4gICAgT25Jbml0LFxuICAgIE91dHB1dCxcbiAgICBWaWV3RW5jYXBzdWxhdGlvblxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENhbGVuZGFySTE4biB9IGZyb20gJy4uLy4uL2kxOG4vY2FsZW5kYXItaTE4bic7XG5pbXBvcnQgeyBGZERhdGUgfSBmcm9tICcuLi8uLi9tb2RlbHMvZmQtZGF0ZSc7XG5pbXBvcnQgeyBDYWxlbmRhckN1cnJlbnQgfSBmcm9tICcuLi8uLi9tb2RlbHMvY2FsZW5kYXItY3VycmVudCc7XG5pbXBvcnQgeyBDYWxlbmRhclR5cGUsIERheXNPZldlZWsgfSBmcm9tICcuLi8uLi9jYWxlbmRhci5jb21wb25lbnQnO1xuaW1wb3J0IHsgQ2FsZW5kYXJEYXkgfSBmcm9tICcuLi8uLi9tb2RlbHMvY2FsZW5kYXItZGF5JztcbmltcG9ydCB7IENhbGVuZGFyU2VydmljZSB9IGZyb20gJy4uLy4uL2NhbGVuZGFyLnNlcnZpY2UnO1xuaW1wb3J0IHsgRmRSYW5nZURhdGUgfSBmcm9tICcuLi8uLi9tb2RlbHMvZmQtcmFuZ2UtZGF0ZSc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyB0YWtlVW50aWwgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cbi8qKiBDb21wb25lbnQgcmVwcmVzZW50aW5nIHRoZSBkYXkgdmlldyBvZiB0aGUgY2FsZW5kYXIuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2ZkLWNhbGVuZGFyLWRheS12aWV3JyxcbiAgICB0ZW1wbGF0ZVVybDogJy4vY2FsZW5kYXItZGF5LXZpZXcuY29tcG9uZW50Lmh0bWwnLFxuICAgIHN0eWxlVXJsczogWycuL2NhbGVuZGFyLWRheS12aWV3LmNvbXBvbmVudC5zY3NzJ10sXG4gICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgICBob3N0OiB7XG4gICAgICAgICdbYXR0ci5pZF0nOiAnaWQgKyBcIi1kYXktdmlld1wiJ1xuICAgIH0sXG4gICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcbn0pXG5leHBvcnQgY2xhc3MgQ2FsZW5kYXJEYXlWaWV3Q29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0LCBPbkNoYW5nZXMsIE9uRGVzdHJveSB7XG5cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIG5ld0ZvY3VzZWREYXlJZDogc3RyaW5nID0gJyc7XG5cbiAgICAvKiogQWN0dWFsIGRheSBncmlkIHdpdGggcHJldmlvdXMvY3VycmVudC9uZXh0IG1vbnRoIGRheXMgKi9cbiAgICBwdWJsaWMgZGF5Vmlld0dyaWQ6IENhbGVuZGFyRGF5W11bXTtcblxuICAgIC8qKiBAaGlkZGVuICovXG4gICAgQEhvc3RCaW5kaW5nKCdjbGFzcy5mZC1jYWxlbmRhcl9fZGF0ZXMnKVxuICAgIHB1YmxpYyBmZENhbGVuZGFyRGF0ZVZpZXdDbGFzczogYm9vbGVhbiA9IHRydWU7XG5cbiAgICAvKiogQ3VycmVudGx5IGRpc3BsYXllZCBtb250aCBhbmQgeWVhciBmb3IgZGF5cyAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGN1cnJlbnRseURpc3BsYXllZDogQ2FsZW5kYXJDdXJyZW50O1xuXG4gICAgLyoqIFRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgRmREYXRlIG1vZGVsIGluIHNpbmdsZSBtb2RlLiAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHNlbGVjdGVkRGF0ZTogRmREYXRlO1xuXG4gICAgLyoqIFRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgRmREYXRlcyBtb2RlbCBzdGFydCBhbmQgZW5kIGluIHJhbmdlIG1vZGUuICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgc2VsZWN0ZWRSYW5nZURhdGU6IEZkUmFuZ2VEYXRlO1xuXG4gICAgLyoqIFRoZSBkYXkgb2YgdGhlIHdlZWsgdGhlIGNhbGVuZGFyIHNob3VsZCBzdGFydCBvbi4gMSByZXByZXNlbnRzIFN1bmRheSwgMiBpcyBNb25kYXksIDMgaXMgVHVlc2RheSwgYW5kIHNvIG9uLiAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHN0YXJ0aW5nRGF5T2ZXZWVrOiBEYXlzT2ZXZWVrO1xuXG4gICAgLyoqIFRoZSB0eXBlIG9mIGNhbGVuZGFyLCAnc2luZ2xlJyBmb3Igc2luZ2xlIGRhdGUgc2VsZWN0aW9uIG9yICdyYW5nZScgZm9yIGEgcmFuZ2Ugb2YgZGF0ZXMuICovXG4gICAgQElucHV0KClcbiAgICBjYWxUeXBlOiBDYWxlbmRhclR5cGUgPSAnc2luZ2xlJztcblxuICAgIC8qKiBJZCBvZiB0aGUgY2FsZW5kYXIuIElmIG5vbmUgaXMgcHJvdmlkZWQsIG9uZSB3aWxsIGJlIGdlbmVyYXRlZC4gKi9cbiAgICBASW5wdXQoKSBpZDogc3RyaW5nO1xuXG4gICAgLyoqIEZ1bmN0aW9uIHRoYXQgYWxsb3dzIHRvIHNwZWNpZnkgd2hpY2ggZnVuY3Rpb24gd291bGQgYmUgY2FsbGVkLCB3aGVuIGZvY3VzIHdhbnRzIHRvIGVzY2FwZSAqL1xuICAgIEBJbnB1dCgpXG4gICAgZm9jdXNFc2NhcGVGdW5jdGlvbjogRnVuY3Rpb247XG5cbiAgICAvKiogRXZlbnQgZW1pdHRlZCBhbHdheXMsIHdoZW4gbW9kZWwgaXMgY2hhbmdlZCBpbiByYW5nZSBtb2RlICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIHJlYWRvbmx5IHNlbGVjdGVkUmFuZ2VEYXRlQ2hhbmdlOiBFdmVudEVtaXR0ZXI8RmRSYW5nZURhdGU+ID0gbmV3IEV2ZW50RW1pdHRlcjxGZFJhbmdlRGF0ZT4oKTtcblxuICAgIC8qKiBFdmVudCBlbWl0dGVkIGFsd2F5cywgd2hlbiBuZXh0IG1vbnRoIGlzIHNlbGVjdGVkLCBieSBmb2N1cyAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyByZWFkb25seSBuZXh0TW9udGhTZWxlY3Q6IEV2ZW50RW1pdHRlcjx2b2lkPiA9IG5ldyBFdmVudEVtaXR0ZXI8dm9pZD4oKTtcblxuICAgIC8qKiBFdmVudCBlbWl0dGVkIGFsd2F5cywgd2hlbiBwcmV2aW91cyBtb250aCBpcyBzZWxlY3RlZCwgYnkgZm9jdXMgKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgcmVhZG9ubHkgcHJldmlvdXNNb250aFNlbGVjdDogRXZlbnRFbWl0dGVyPHZvaWQ+ID0gbmV3IEV2ZW50RW1pdHRlcjx2b2lkPigpO1xuXG4gICAgLyoqIEV2ZW50IGVtaXR0ZWQgYWx3YXlzLCB3aGVuIG1vZGVsIGlzIGNoYW5nZWQgaW4gc2luZ2xlIG1vZGUgKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgcmVhZG9ubHkgc2VsZWN0ZWREYXRlQ2hhbmdlOiBFdmVudEVtaXR0ZXI8RmREYXRlPiA9IG5ldyBFdmVudEVtaXR0ZXI8RmREYXRlPigpO1xuXG4gICAgLyoqIEFuIFJ4SlMgU3ViamVjdCB0aGF0IHdpbGwga2lsbCB0aGUgZGF0YSBzdHJlYW0gdXBvbiBjb21wb25lbnTigJlzIGRlc3RydWN0aW9uIChmb3IgdW5zdWJzY3JpYmluZykgICovXG4gICAgcHJpdmF0ZSByZWFkb25seSBvbkRlc3Ryb3kkOiBTdWJqZWN0PHZvaWQ+ID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcblxuICAgIC8qKlxuICAgICAqIFZhcmlhYmxlIHRoYXQgY29udGFpbnMgZmlyc3QgbGV0dGVyIG9mIGV2ZXJ5IHdlZWtkYXksIGJhc2luZyBvbiBDYWxlbmRhckkxOG5EZWZhdWx0LlxuICAgICAqL1xuICAgIHByaXZhdGUgX3Nob3J0V2Vla0RheXM6IHN0cmluZ1tdO1xuXG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gdXNlZCB0byBkaXNhYmxlIGNlcnRhaW4gZGF0ZXMgaW4gdGhlIGNhbGVuZGFyLlxuICAgICAqIEBwYXJhbSBmZERhdGUgRmREYXRlXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBkaXNhYmxlRnVuY3Rpb24gPSBmdW5jdGlvbiAoZmREYXRlOiBGZERhdGUpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiB1c2VkIHRvIGRpc2FibGUgY2VydGFpbiBkYXRlcyBpbiB0aGUgY2FsZW5kYXIgZm9yIHRoZSByYW5nZSBzdGFydCBzZWxlY3Rpb24uXG4gICAgICogQHBhcmFtIGZkRGF0ZSBGZERhdGVcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGRpc2FibGVSYW5nZVN0YXJ0RnVuY3Rpb24gPSBmdW5jdGlvbiAoZmREYXRlOiBGZERhdGUpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiB1c2VkIHRvIGRpc2FibGUgY2VydGFpbiBkYXRlcyBpbiB0aGUgY2FsZW5kYXIgZm9yIHRoZSByYW5nZSBlbmQgc2VsZWN0aW9uLlxuICAgICAqIEBwYXJhbSBmZERhdGUgRmREYXRlXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBkaXNhYmxlUmFuZ2VFbmRGdW5jdGlvbiA9IGZ1bmN0aW9uIChmZERhdGU6IEZkRGF0ZSk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHVzZWQgdG8gYmxvY2sgY2VydGFpbiBkYXRlcyBpbiB0aGUgY2FsZW5kYXIgZm9yIHRoZSByYW5nZSBzdGFydCBzZWxlY3Rpb24uXG4gICAgICogQHBhcmFtIGZkRGF0ZSBGZERhdGVcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGJsb2NrUmFuZ2VTdGFydEZ1bmN0aW9uID0gZnVuY3Rpb24gKGZkRGF0ZTogRmREYXRlKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gdXNlZCB0byBibG9jayBjZXJ0YWluIGRhdGVzIGluIHRoZSBjYWxlbmRhciBmb3IgdGhlIHJhbmdlIGVuZCBzZWxlY3Rpb24uXG4gICAgICogQHBhcmFtIGZkRGF0ZSBGZERhdGVcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGJsb2NrUmFuZ2VFbmRGdW5jdGlvbiA9IGZ1bmN0aW9uIChmZERhdGU6IEZkRGF0ZSk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHVzZWQgdG8gYmxvY2sgY2VydGFpbiBkYXRlcyBpbiB0aGUgY2FsZW5kYXIuXG4gICAgICogQHBhcmFtIGZkRGF0ZSBGZERhdGVcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGJsb2NrRnVuY3Rpb24gPSBmdW5jdGlvbiAoZmREYXRlOiBGZERhdGUpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBwcml2YXRlIGNhbGVuZGFySTE4bjogQ2FsZW5kYXJJMThuLFxuICAgICAgICBwcml2YXRlIGVSZWY6IEVsZW1lbnRSZWYsXG4gICAgICAgIHByaXZhdGUgY2hhbmdlRGV0UmVmOiBDaGFuZ2VEZXRlY3RvclJlZlxuICAgICkge1xuICAgICAgICB0aGlzLmNhbGVuZGFySTE4bi5pMThuQ2hhbmdlXG4gICAgICAgICAgICAucGlwZSh0YWtlVW50aWwodGhpcy5vbkRlc3Ryb3kkKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKCkgPT4gdGhpcy5yZWZyZXNoU2hvcnRXZWVrRGF5cygpKVxuICAgICAgICA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gZm9yIHNlbGVjdGluZyBhIGRhdGUgb24gdGhlIGNhbGVuZGFyLiBUeXBpY2FsbHkgY2FsbGVkIHdoZW4gYSBkYXRlIGlzIGNsaWNrZWQsIGJ1dCBjYW4gYWxzbyBiZSBjYWxsZWQgcHJvZ3JhbW1hdGljYWxseS5cbiAgICAgKiBAcGFyYW0gZGF5IENhbGVuZGFyRGF5IG9iamVjdCB0byBiZSBzZWxlY3RlZC5cbiAgICAgKi9cbiAgICBzZWxlY3REYXRlKGRheTogQ2FsZW5kYXJEYXksIGV2ZW50PzogTW91c2VFdmVudCk6IHZvaWQge1xuICAgICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhlcmUgYXJlIHNvbWUgcHJvYmxlbXMgd2l0aCBwb3B1cCBpbnRlZ3JhdGlvbi4gQWZ0ZXIgY2xpY2tpbmcgaW5zaWRlIGRheSBjb21wb25lbnQsIHRoZSBwb3BvdmVyIGNsb3Nlcy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgdGhpcy5uZXdGb2N1c2VkRGF5SWQgPSBkYXkuaWQ7XG4gICAgICAgICAgICB0aGlzLmZvY3VzRWxlbWVudCh0aGlzLm5ld0ZvY3VzZWREYXlJZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkYXkuYmxvY2tlZCAmJiAhZGF5LmRpc2FibGVkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jYWxUeXBlID09PSAnc2luZ2xlJykge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWREYXRlID0gZGF5LmRhdGU7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZERhdGVDaGFuZ2UuZW1pdChkYXkuZGF0ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5idWlsZERheVZpZXdHcmlkKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdENvdW50ZXIgPT09IDAgfHwgdGhpcy5zZWxlY3RDb3VudGVyID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRSYW5nZURhdGUgPSB7IHN0YXJ0OiBkYXkuZGF0ZSwgZW5kOiBudWxsIH07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRSYW5nZURhdGVDaGFuZ2UuZW1pdCh0aGlzLnNlbGVjdGVkUmFuZ2VEYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idWlsZERheVZpZXdHcmlkKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnNlbGVjdENvdW50ZXIgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgZGF0ZSBwaWNrZWQgaXMgaGlnaGVyIHRoYW4gYWxyZWFkeSBjaG9zZW4sIG90aGVyd2lzZSBqdXN0IHJldmVyc2UgdGhlbVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zZWxlY3RlZFJhbmdlRGF0ZS5zdGFydC5nZXRUaW1lU3RhbXAoKSA8IGRheS5kYXRlLmdldFRpbWVTdGFtcCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkUmFuZ2VEYXRlID0geyBzdGFydDogdGhpcy5zZWxlY3RlZFJhbmdlRGF0ZS5zdGFydCwgZW5kOiBkYXkuZGF0ZSB9O1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZFJhbmdlRGF0ZSA9IHsgc3RhcnQ6IGRheS5kYXRlLCBlbmQ6IHRoaXMuc2VsZWN0ZWRSYW5nZURhdGUuc3RhcnQgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkUmFuZ2VEYXRlQ2hhbmdlLmVtaXQodGhpcy5zZWxlY3RlZFJhbmdlRGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYnVpbGREYXlWaWV3R3JpZCgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBuZ09uSW5pdCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5yZWZyZXNoU2hvcnRXZWVrRGF5cygpO1xuICAgICAgICB0aGlzLmJ1aWxkRGF5Vmlld0dyaWQoKTtcbiAgICB9XG5cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgICAgICB0aGlzLm9uRGVzdHJveSQubmV4dCgpO1xuICAgICAgICB0aGlzLm9uRGVzdHJveSQuY29tcGxldGUoKTtcbiAgICB9XG5cbiAgICAvKiogQGhpZGRlblxuICAgICAqICBBbW91bnQgb2Ygc2VsZWN0ZWQgZGF5c1xuICAgICAqICAwLCB3aGVuIHRoZXJlIGlzIG5vIGRheSBzZWxlY3RlZCwgb3Igc3RhcnQgZGF0ZSBpcyBpbnZhbGlkLFxuICAgICAqICAxLCB3aGVuIHRoZXJlIGlzIG9ubHkgdmFsaWQgc3RhcnQgZGF0ZSwgb3IgZW5kIGRhdGUgaXMgc2FtZSBhcyBzdGFydCBkYXRlLFxuICAgICAqICAyLCB3aGVuIGJvdGggZGF0ZXMgYXJlIHZhbGlkXG4gICAgICovXG4gICAgZ2V0IHNlbGVjdENvdW50ZXIoKTogbnVtYmVyIHtcbiAgICAgICAgaWYgKCF0aGlzLnNlbGVjdGVkUmFuZ2VEYXRlIHx8ICF0aGlzLnNlbGVjdGVkUmFuZ2VEYXRlLnN0YXJ0IHx8ICF0aGlzLnNlbGVjdGVkUmFuZ2VEYXRlLnN0YXJ0LmlzRGF0ZVZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc2VsZWN0ZWRSYW5nZURhdGUuc3RhcnQgJiZcbiAgICAgICAgICAgICghdGhpcy5zZWxlY3RlZFJhbmdlRGF0ZS5lbmQgfHwgIXRoaXMuc2VsZWN0ZWRSYW5nZURhdGUuZW5kLmlzRGF0ZVZhbGlkKCkgfHxcbiAgICAgICAgICAgICAgICBDYWxlbmRhclNlcnZpY2UuZGF0ZXNFcXVhbCh0aGlzLnNlbGVjdGVkUmFuZ2VEYXRlLnN0YXJ0LCB0aGlzLnNlbGVjdGVkUmFuZ2VEYXRlLmVuZClcbiAgICAgICAgICAgIClcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRSYW5nZURhdGUuc3RhcnQgJiYgdGhpcy5zZWxlY3RlZFJhbmdlRGF0ZS5zdGFydC5pc0RhdGVWYWxpZCgpICYmXG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkUmFuZ2VEYXRlLmVuZCAmJiB0aGlzLnNlbGVjdGVkUmFuZ2VEYXRlLmVuZC5pc0RhdGVWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBNZXRob2QgdGhhdCBoYW5kbGVzIGRheSBjZWxscyBrZXlkb3duIGV2ZW50cyxcbiAgICAgKiBAcGFyYW0gZXZlbnQgS2V5Ym9hcmRFdmVudFxuICAgICAqIEBwYXJhbSBjZWxsIENhbGVuZGFyRGF5XG4gICAgICogQHBhcmFtIGdyaWQgd2l0aCBzcGVjaWZpZWQgY29sdW1uIGFuZCByb3cgYXMgYSB4IGFuZCB5XG4gICAgICovXG4gICAgb25LZXlkb3duRGF5SGFuZGxlcihldmVudCwgY2VsbDogQ2FsZW5kYXJEYXksIGdyaWQ6IHsgeDogbnVtYmVyLCB5OiBudW1iZXIgfSk6IHZvaWQge1xuICAgICAgICBpZiAoZXZlbnQua2V5ID09PSAnVGFiJyAmJiAhZXZlbnQuc2hpZnRLZXkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmZvY3VzRXNjYXBlRnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuZm9jdXNFc2NhcGVGdW5jdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3dpdGNoIChldmVudC5rZXkpIHtcbiAgICAgICAgICAgICAgICBjYXNlICgnICcpOlxuICAgICAgICAgICAgICAgIGNhc2UgKCdFbnRlcicpOiB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0RGF0ZShjZWxsKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXdGb2N1c2VkRGF5SWQgPSBjZWxsLmlkO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAoJ0Fycm93VXAnKToge1xuICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZ3JpZC55ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXdGb2N1c2VkRGF5SWQgPSB0aGlzLmRheVZpZXdHcmlkW2dyaWQueSAtIDFdW2dyaWQueF0uaWQ7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdFByZXZpb3VzTW9udGgoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubmV3Rm9jdXNlZERheUlkID0gdGhpcy5kYXlWaWV3R3JpZFt0aGlzLmRheVZpZXdHcmlkLmxlbmd0aCAtIDFdW2dyaWQueF0uaWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgKCdBcnJvd0Rvd24nKToge1xuICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZ3JpZC55IDwgdGhpcy5kYXlWaWV3R3JpZC5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5ld0ZvY3VzZWREYXlJZCA9IHRoaXMuZGF5Vmlld0dyaWRbZ3JpZC55ICsgMV1bZ3JpZC54XS5pZDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0TmV4dE1vbnRoKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5ld0ZvY3VzZWREYXlJZCA9IHRoaXMuZGF5Vmlld0dyaWRbMF1bZ3JpZC54XS5pZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAoJ0Fycm93TGVmdCcpOiB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChncmlkLnggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5ld0ZvY3VzZWREYXlJZCA9IHRoaXMuZGF5Vmlld0dyaWRbZ3JpZC55XVtncmlkLnggLSAxXS5pZDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChncmlkLnkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5ld0ZvY3VzZWREYXlJZCA9IHRoaXMuZGF5Vmlld0dyaWRbZ3JpZC55IC0gMV1bdGhpcy5kYXlWaWV3R3JpZFswXS5sZW5ndGggLSAxXS5pZDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0UHJldmlvdXNNb250aCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXdGb2N1c2VkRGF5SWQgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGF5Vmlld0dyaWRbdGhpcy5kYXlWaWV3R3JpZC5sZW5ndGggLSAxXVt0aGlzLmRheVZpZXdHcmlkWzBdLmxlbmd0aCAtIDFdLmlkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICgnQXJyb3dSaWdodCcpOiB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChncmlkLnggPCB0aGlzLmRheVZpZXdHcmlkWzBdLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubmV3Rm9jdXNlZERheUlkID0gdGhpcy5kYXlWaWV3R3JpZFtncmlkLnldW2dyaWQueCArIDFdLmlkO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGdyaWQueSA8IHRoaXMuZGF5Vmlld0dyaWQubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXdGb2N1c2VkRGF5SWQgPSB0aGlzLmRheVZpZXdHcmlkW2dyaWQueSArIDFdWzBdLmlkO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3ROZXh0TW9udGgoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubmV3Rm9jdXNlZERheUlkID0gdGhpcy5kYXlWaWV3R3JpZFswXVswXS5pZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5uZXdGb2N1c2VkRGF5SWQpIHtcbiAgICAgICAgICAgIHRoaXMuZm9jdXNFbGVtZW50KHRoaXMubmV3Rm9jdXNlZERheUlkKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBAaGlkZGVuICovXG4gICAgcHVibGljIG5nT25DaGFuZ2VzKCk6IHZvaWQge1xuICAgICAgICB0aGlzLmJ1aWxkRGF5Vmlld0dyaWQoKTtcbiAgICB9XG5cbiAgICAvKiogQGhpZGRlblxuICAgICAqICBNZXRob2QgdGhhdCBhbGxvdyB0byBmb2N1cyBlbGVtZW50cyBpbnNpZGUgdGhpcyBjb21wb25lbnRcbiAgICAgKi9cbiAgICBwdWJsaWMgZm9jdXNFbGVtZW50KGVsZW1lbnRTZWxlY3Rvcik6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5uZXdGb2N1c2VkRGF5SWQpIHtcbiAgICAgICAgICAgIHRoaXMubmV3Rm9jdXNlZERheUlkID0gJyc7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbGVtZW50VG9Gb2N1czogSFRNTEVsZW1lbnQgPSB0aGlzLmVSZWYubmF0aXZlRWxlbWVudC5xdWVyeVNlbGVjdG9yKCcjJyArIGVsZW1lbnRTZWxlY3Rvcik7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnRUb0ZvY3VzKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRUb0ZvY3VzLmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogQWN0aXZlIGRheSBtZWFucyB0aGF0IHdpdGggdGFiaW5kZXggPSAwLCBpdCdzIHNlbGVjdGVkIGRheSBvciB0b2RheSBvciBmaXJzdCBkYXkgKi9cbiAgICBwdWJsaWMgZm9jdXNBY3RpdmVEYXkoKTogdm9pZCB7XG4gICAgICAgIHRoaXMubmV3Rm9jdXNlZERheUlkID0gdGhpcy5nZXRBY3RpdmVDZWxsKFxuICAgICAgICAgICAgdGhpcy5jYWxlbmRhckRheUxpc3QuZmlsdGVyKGNlbGwgPT4gY2VsbC5tb250aFN0YXR1cyA9PT0gJ2N1cnJlbnQnKVxuICAgICAgICApLmlkO1xuICAgICAgICB0aGlzLmZvY3VzRWxlbWVudCh0aGlzLm5ld0ZvY3VzZWREYXlJZCk7XG4gICAgfVxuXG4gICAgLyoqIEZ1bmN0aW9uIHRoYXQgZ2l2ZXMgYXJyYXkgb2YgYWxsIGRpc3BsYXllZCBDYWxlbmRhckRheXMgKi9cbiAgICBwdWJsaWMgZ2V0IGNhbGVuZGFyRGF5TGlzdCgpOiBDYWxlbmRhckRheVtdIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF5Vmlld0dyaWQucmVkdWNlKCh0b3RhbENhbGVuZGFyUm93czogQ2FsZW5kYXJEYXlbXSwgY2FsZW5kYXJSb3c6IENhbGVuZGFyRGF5W10pID0+IHtcbiAgICAgICAgICAgIGlmICghY2FsZW5kYXJSb3cpIHtcbiAgICAgICAgICAgICAgICBjYWxlbmRhclJvdyA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRvdGFsQ2FsZW5kYXJSb3dzLmNvbmNhdChjYWxlbmRhclJvdyk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB0aGF0IHNlbGVjdHMgcHJldmlvdXMgbW9udGhcbiAgICAgKiBUcmlnZ2VyZWQgb25seSB3aGVuIHRoZSBtb250aCBpcyBjaGFuZ2VkIGR1cmluZyBjaGFuZ2luZyBmb2N1c1xuICAgICAqIEFsc28gdHJpZ2dlcnMgZXZlbnQgdG8gcGFyZW50IGNhbGVuZGFyIGNvbXBvbmVudCBhbmQgcmVidWlsZHMgZGF5IHZpZXcgZ3JpZFxuICAgICAqL1xuICAgIHByaXZhdGUgc2VsZWN0UHJldmlvdXNNb250aCgpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudGx5RGlzcGxheWVkLm1vbnRoID4gMSkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50bHlEaXNwbGF5ZWQgPSB7IC4uLnRoaXMuY3VycmVudGx5RGlzcGxheWVkLCBtb250aDogdGhpcy5jdXJyZW50bHlEaXNwbGF5ZWQubW9udGggLSAxIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRseURpc3BsYXllZCA9IHsgeWVhcjogdGhpcy5jdXJyZW50bHlEaXNwbGF5ZWQueWVhciAtIDEsIG1vbnRoOiAxMiB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYnVpbGREYXlWaWV3R3JpZCgpO1xuICAgICAgICB0aGlzLnByZXZpb3VzTW9udGhTZWxlY3QuZW1pdCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB0aGF0IHNlbGVjdHMgbmV4dCBtb250aFxuICAgICAqIFRyaWdnZXJlZCBvbmx5IHdoZW4gdGhlIG1vbnRoIGlzIGNoYW5nZWQgZHVyaW5nIGNoYW5naW5nIGZvY3VzXG4gICAgICogQWxzbyB0cmlnZ2VycyBldmVudCB0byBwYXJlbnQgY2FsZW5kYXIgY29tcG9uZW50IGFuZCByZWJ1aWxkcyBkYXkgdmlldyBncmlkXG4gICAgICovXG4gICAgcHJpdmF0ZSBzZWxlY3ROZXh0TW9udGgoKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRseURpc3BsYXllZC5tb250aCA+IDEpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudGx5RGlzcGxheWVkID0geyAuLi50aGlzLmN1cnJlbnRseURpc3BsYXllZCwgbW9udGg6IHRoaXMuY3VycmVudGx5RGlzcGxheWVkLm1vbnRoICsgMSB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50bHlEaXNwbGF5ZWQgPSB7IHllYXI6IHRoaXMuY3VycmVudGx5RGlzcGxheWVkLnllYXIgKyAxLCBtb250aDogMSB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYnVpbGREYXlWaWV3R3JpZCgpO1xuICAgICAgICB0aGlzLm5leHRNb250aFNlbGVjdC5lbWl0KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHRoYXQgY3JlYXRlcyBhcnJheSBvZiBDYWxlbmRhckRheSBtb2RlbHMgd2hpY2ggd2lsbCBiZSBzaG93biBvbiBkYXkgZ3JpZCxcbiAgICAgKiBkZXBlbmRpbmcgb24gY3VycmVudCBtb250aCBhbmQgeWVhci5cbiAgICAgKi9cbiAgICBwcml2YXRlIHBvcHVsYXRlQ2FsZW5kYXIoKTogQ2FsZW5kYXJEYXlbXSB7XG4gICAgICAgIGxldCBjYWxlbmRhcjogQ2FsZW5kYXJEYXlbXSA9IFtdO1xuXG4gICAgICAgIGNhbGVuZGFyID0gdGhpcy5nZXRQcmV2aW91c01vbnRoRGF5cyhjYWxlbmRhcik7XG4gICAgICAgIGNhbGVuZGFyID0gY2FsZW5kYXIuY29uY2F0KHRoaXMuZ2V0Q3VycmVudE1vbnRoRGF5cygpKTtcbiAgICAgICAgY2FsZW5kYXIgPSB0aGlzLmdldE5leHRNb250aERheXMoY2FsZW5kYXIpO1xuXG4gICAgICAgIGNhbGVuZGFyLmZvckVhY2goKGNhbGwsIGluZGV4OiBudW1iZXIpID0+IGNhbGwuaWQgPSB0aGlzLmlkICsgJy1mZC1kYXktJyArIChNYXRoLmZsb29yKGluZGV4IC8gNykgKyAxKSArICcnICsgKGluZGV4ICUgNykpO1xuXG4gICAgICAgIHJldHVybiBjYWxlbmRhcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdGhhdCBidWlsZHMgMiBkaW1lbnNpb25zIGRheSB2aWV3IGdyaWQsIGFsc28gc2V0cyB1cCBjdXJyZW50bHkgZGlzcGxheWVkIG1vbnRoLCBvciB5ZWFyLFxuICAgICAqIHdoZW4gdGhlcmUgaXMgbm90IGFueS5cbiAgICAgKi9cbiAgICBwcml2YXRlIGJ1aWxkRGF5Vmlld0dyaWQoKTogdm9pZCB7XG4gICAgICAgIGlmICghdGhpcy5jdXJyZW50bHlEaXNwbGF5ZWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGVkRGF0ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudGx5RGlzcGxheWVkID0geyBtb250aDogdGhpcy5zZWxlY3RlZERhdGUubW9udGgsIHllYXI6IHRoaXMuc2VsZWN0ZWREYXRlLnllYXIgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50bHlEaXNwbGF5ZWQgPSB7IG1vbnRoOiBGZERhdGUuZ2V0VG9kYXkoKS5tb250aCwgeWVhcjogRmREYXRlLmdldFRvZGF5KCkueWVhciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY2FsZW5kYXJEYXlzID0gdGhpcy5wb3B1bGF0ZUNhbGVuZGFyKCk7XG4gICAgICAgIGNvbnN0IGRheVZpZXdHcmlkOiBDYWxlbmRhckRheVtdW10gPSBbXTtcblxuICAgICAgICB3aGlsZSAoY2FsZW5kYXJEYXlzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGRheVZpZXdHcmlkLnB1c2goY2FsZW5kYXJEYXlzLnNwbGljZSgwLCA3KSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kYXlWaWV3R3JpZCA9IGRheVZpZXdHcmlkO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHdoaWNoIHByb3ZpZGVzIGFycmF5IG9mIENhbGVuZGFyRGF5LCB3aGljaCBjb250YWlucyBldmVyeSBzaW5nbGUgZGF5IG9mIGN1cnJlbnRseSBzaG93biBtb250aC95ZWFyLlxuICAgICAqL1xuICAgIHByaXZhdGUgZ2V0Q3VycmVudE1vbnRoRGF5cygpOiBDYWxlbmRhckRheVtdIHtcbiAgICAgICAgY29uc3QgbW9udGggPSB0aGlzLmN1cnJlbnRseURpc3BsYXllZC5tb250aDtcbiAgICAgICAgY29uc3QgeWVhciA9IHRoaXMuY3VycmVudGx5RGlzcGxheWVkLnllYXI7XG4gICAgICAgIGNvbnN0IGNhbGVuZGFyRGF5czogQ2FsZW5kYXJEYXlbXSA9IFtdO1xuICAgICAgICBjb25zdCBhbW91bnRPZkRheXNJbkN1cnJlbnRNb250aDogbnVtYmVyID0gQ2FsZW5kYXJTZXJ2aWNlLmdldERheXNJbk1vbnRoKG1vbnRoLCB5ZWFyKTtcbiAgICAgICAgZm9yIChsZXQgZGF5TnVtYmVyID0gMTsgZGF5TnVtYmVyIDw9IGFtb3VudE9mRGF5c0luQ3VycmVudE1vbnRoOyBkYXlOdW1iZXIrKykge1xuICAgICAgICAgICAgY29uc3QgZmREYXRlOiBGZERhdGUgPSBuZXcgRmREYXRlKHllYXIsIG1vbnRoLCBkYXlOdW1iZXIpO1xuICAgICAgICAgICAgY2FsZW5kYXJEYXlzLnB1c2goe1xuICAgICAgICAgICAgICAgIC4uLnRoaXMuZ2V0RGF5KGZkRGF0ZSksXG4gICAgICAgICAgICAgICAgbW9udGhTdGF0dXM6ICdjdXJyZW50JyxcbiAgICAgICAgICAgICAgICB0b2RheTogQ2FsZW5kYXJTZXJ2aWNlLmRhdGVzRXF1YWwoRmREYXRlLmdldFRvZGF5KCksIGZkRGF0ZSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZ2V0QWN0aXZlQ2VsbChjYWxlbmRhckRheXMpLmlzVGFiSW5kZXhlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiBjYWxlbmRhckRheXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHRoYXQgcmV0dXJucyBhY3RpdmUgY2VsbCwgd2hpY2ggbWVhbnM6XG4gICAgICogaWYgdGhlcmUgaXMgYW55IHNlbGVjdGVkIGRheSwgcmV0dXJuIHNlbGVjdGVkIGRheVxuICAgICAqIGlmIHRoZXJlIGlzIG5vIHNlbGVjdGVkIGRheSwgYnV0IHRoZXJlIGlzIHRvZGF5IGRheSwgcmV0dXJuIHRvZGF5IGRheVxuICAgICAqIGlmIHRoZXJlIGlzIG5vIHRvZGF5LCBvciBzZWxlY3RlZCwgcmV0dXJuIGZpcnN0IG9uZVxuICAgICAqL1xuICAgIHByaXZhdGUgZ2V0QWN0aXZlQ2VsbChjYWxlbmRhckRheXM6IENhbGVuZGFyRGF5W10pOiBDYWxlbmRhckRheSB7XG4gICAgICAgIGlmIChjYWxlbmRhckRheXMuZmluZChjZWxsID0+IGNlbGwuc2VsZWN0ZWQpKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsZW5kYXJEYXlzLmZpbmQoY2VsbCA9PiBjZWxsLnNlbGVjdGVkKTtcbiAgICAgICAgfSBlbHNlIGlmIChjYWxlbmRhckRheXMuZmluZChjZWxsID0+IGNlbGwudG9kYXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsZW5kYXJEYXlzLmZpbmQoY2VsbCA9PiBjZWxsLnRvZGF5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxlbmRhckRheXNbMF07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2Qgd2hpY2ggcHJvdmlkZXMgYXJyYXkgb2YgQ2FsZW5kYXJEYXksIHdoaWNoIGNvbnRhaW5zIGxhc3QgMC02IGRheXMgb2YgcHJldmlvdXMgbW9udGgveWVhci4gVGhlc2VzIGRheXNcbiAgICAgKiBmaWxscyB0aGUgZ2FwIGJldHdlZW4gc3RhcnRpbmcgc3RhcnRpbmdEYXlPZldlZWsgYW5kIGZpcnN0IGRheSBvZiBjdXJyZW50IG1vbnRoXG4gICAgICovXG4gICAgcHJpdmF0ZSBnZXRQcmV2aW91c01vbnRoRGF5cyhjYWxlbmRhckRheXM6IENhbGVuZGFyRGF5W10pOiBDYWxlbmRhckRheVtdIHtcbiAgICAgICAgY29uc3QgbW9udGggPSB0aGlzLmN1cnJlbnRseURpc3BsYXllZC5tb250aCA+IDEgPyB0aGlzLmN1cnJlbnRseURpc3BsYXllZC5tb250aCAtIDEgOiAxMjtcbiAgICAgICAgY29uc3QgeWVhciA9IHRoaXMuY3VycmVudGx5RGlzcGxheWVkLm1vbnRoID4gMSA/IHRoaXMuY3VycmVudGx5RGlzcGxheWVkLnllYXIgOiB0aGlzLmN1cnJlbnRseURpc3BsYXllZC55ZWFyIC0gMTtcbiAgICAgICAgY29uc3QgYW1vdW50T2ZEYXlzSW5DdXJyZW50TW9udGg6IG51bWJlciA9IENhbGVuZGFyU2VydmljZS5nZXREYXlzSW5Nb250aChtb250aCwgeWVhcik7XG4gICAgICAgIGNvbnN0IHByZXZNb250aExhc3REYXRlID0gbmV3IEZkRGF0ZSh5ZWFyLCBtb250aCwgYW1vdW50T2ZEYXlzSW5DdXJyZW50TW9udGgpO1xuICAgICAgICBjb25zdCBwcmV2TW9udGhMYXN0RGF5ID0gYW1vdW50T2ZEYXlzSW5DdXJyZW50TW9udGg7XG4gICAgICAgIGxldCBwcmV2TW9udGhMYXN0V2Vla0RheSA9IHByZXZNb250aExhc3REYXRlLmdldERheSgpIC0gdGhpcy5zdGFydGluZ0RheU9mV2VlaztcblxuICAgICAgICAvKiogQ2hlY2tpbmcgaWYgdGhlcmUgYXJlIHNvbWUgZGF5cyBjdXQgYnkgc3RhcnRpbmdEYXlPZldlZWsgb3B0aW9uXG4gICAgICAgICAqICBJZiB5ZXMsIHRoZXJlIGlzIHdob2xlIHdlZWsgYWRkZWQsIHRvIGF2b2lkIGhpZGluZ1xuICAgICAgICAgKi9cbiAgICAgICAgaWYgKHByZXZNb250aExhc3RXZWVrRGF5IDwgMCkge1xuICAgICAgICAgICAgcHJldk1vbnRoTGFzdFdlZWtEYXkgPSBwcmV2TW9udGhMYXN0V2Vla0RheSArIDc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJldk1vbnRoTGFzdFdlZWtEYXkgPCA2KSB7XG4gICAgICAgICAgICB3aGlsZSAocHJldk1vbnRoTGFzdFdlZWtEYXkgPj0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByZXZNb250aERheSA9IHByZXZNb250aExhc3REYXkgLSBwcmV2TW9udGhMYXN0V2Vla0RheTtcbiAgICAgICAgICAgICAgICBjb25zdCBmZERhdGUgPSBuZXcgRmREYXRlKHllYXIsIG1vbnRoLCBwcmV2TW9udGhEYXkpO1xuICAgICAgICAgICAgICAgIGNhbGVuZGFyRGF5cy5wdXNoKHsgLi4udGhpcy5nZXREYXkoZmREYXRlKSwgbW9udGhTdGF0dXM6ICdwcmV2aW91cycgfSk7XG4gICAgICAgICAgICAgICAgcHJldk1vbnRoTGFzdFdlZWtEYXktLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FsZW5kYXJEYXlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB3aGljaCBwcm92aWRlcyBhcnJheSBvZiBDYWxlbmRhckRheSwgd2hpY2ggY29udGFpbnMgZmlyc3QgZGF5cyBvZiBuZXh0IG1vbnRoL3llYXIuIFRoZXNlcyBkYXlzXG4gICAgICogZmlsbHMgdGhlIGdhcCBiZXR3ZWVuIGxhc3QgZGF5IG9mIGN1cnJlbnQgZGF5IGFuZCBlbmQgb2YgNi13ZWVrcyBjYWxlbmRhciBncmlkLlxuICAgICAqL1xuICAgIHByaXZhdGUgZ2V0TmV4dE1vbnRoRGF5cyhjYWxlbmRhckRheXM6IENhbGVuZGFyRGF5W10pOiBDYWxlbmRhckRheVtdIHtcbiAgICAgICAgY29uc3QgbW9udGggPSB0aGlzLmN1cnJlbnRseURpc3BsYXllZC5tb250aCA8IDEyID8gdGhpcy5jdXJyZW50bHlEaXNwbGF5ZWQubW9udGggKyAxIDogMTtcbiAgICAgICAgY29uc3QgeWVhciA9IHRoaXMuY3VycmVudGx5RGlzcGxheWVkLm1vbnRoIDwgMTIgPyB0aGlzLmN1cnJlbnRseURpc3BsYXllZC55ZWFyIDogdGhpcy5jdXJyZW50bHlEaXNwbGF5ZWQueWVhciArIDE7XG5cbiAgICAgICAgLy8gVGhlIGNhbGVuZGFyIGdyaWQgY2FuIGhhdmUgNiAoNDIgZGF5cykgd2Vla3NcbiAgICAgICAgY29uc3QgbmV4dE1vbnRoRGlzcGxheWVkRGF5cyA9IDQyIC0gY2FsZW5kYXJEYXlzLmxlbmd0aDtcblxuICAgICAgICBmb3IgKGxldCBuZXh0RCA9IDE7IG5leHREIDw9IG5leHRNb250aERpc3BsYXllZERheXM7IG5leHREKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGZkRGF0ZSA9IG5ldyBGZERhdGUoeWVhciwgbW9udGgsIG5leHREKTtcbiAgICAgICAgICAgIGNhbGVuZGFyRGF5cy5wdXNoKHsgLi4udGhpcy5nZXREYXkoZmREYXRlKSwgbW9udGhTdGF0dXM6ICduZXh0JyB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FsZW5kYXJEYXlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB0aGF0IGdlbmVyYXRlcyB3aG9sZSBkYXkgbW9kZWwgYmFzaW5nIG9uIGZkRGF0ZSwgZGlzYWJsaW5nIGZ1bmN0aW9ucywgYmxvY2sgZnVuY3Rpb25zLCBhbmQgYWN0dWFsbHlcbiAgICAgKiBjaG9zZW4gcmFuZ2UgLyBzaW5nbGUgZGF0ZS5cbiAgICAgKi9cbiAgICBwcml2YXRlIGdldERheShmZERhdGU6IEZkRGF0ZSk6IENhbGVuZGFyRGF5IHtcbiAgICAgICAgY29uc3QgZGF5OiBDYWxlbmRhckRheSA9IHtcbiAgICAgICAgICAgIGRhdGU6IGZkRGF0ZSxcbiAgICAgICAgICAgIHdlZWtEYXk6IGZkRGF0ZS5nZXREYXkoKSxcbiAgICAgICAgICAgIGRpc2FibGVkOiB0aGlzLmRpc2FibGVGdW5jdGlvbihmZERhdGUpLFxuICAgICAgICAgICAgYmxvY2tlZDogdGhpcy5ibG9ja0Z1bmN0aW9uKGZkRGF0ZSksXG4gICAgICAgICAgICBzZWxlY3RlZDogKFxuICAgICAgICAgICAgICAgICh0aGlzLmNhbFR5cGUgPT09ICdzaW5nbGUnICYmIENhbGVuZGFyU2VydmljZS5kYXRlc0VxdWFsKGZkRGF0ZSwgdGhpcy5zZWxlY3RlZERhdGUpKSB8fFxuICAgICAgICAgICAgICAgICh0aGlzLnNlbGVjdGVkUmFuZ2VEYXRlICYmIENhbGVuZGFyU2VydmljZS5kYXRlc0VxdWFsKGZkRGF0ZSwgdGhpcy5zZWxlY3RlZFJhbmdlRGF0ZS5zdGFydCkpIHx8XG4gICAgICAgICAgICAgICAgKHRoaXMuc2VsZWN0ZWRSYW5nZURhdGUgJiYgQ2FsZW5kYXJTZXJ2aWNlLmRhdGVzRXF1YWwoZmREYXRlLCB0aGlzLnNlbGVjdGVkUmFuZ2VEYXRlLmVuZCkpXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgc2VsZWN0ZWRGaXJzdDogKHRoaXMuc2VsZWN0ZWRSYW5nZURhdGUgJiYgQ2FsZW5kYXJTZXJ2aWNlLmRhdGVzRXF1YWwoZmREYXRlLCB0aGlzLnNlbGVjdGVkUmFuZ2VEYXRlLnN0YXJ0KSksXG4gICAgICAgICAgICBzZWxlY3RlZExhc3Q6ICh0aGlzLnNlbGVjdGVkUmFuZ2VEYXRlICYmIENhbGVuZGFyU2VydmljZS5kYXRlc0VxdWFsKGZkRGF0ZSwgdGhpcy5zZWxlY3RlZFJhbmdlRGF0ZS5lbmQpKSxcbiAgICAgICAgICAgIHNlbGVjdGVkUmFuZ2U6ICh0aGlzLnNlbGVjdGVkUmFuZ2VEYXRlICYmIChcbiAgICAgICAgICAgICAgICAodGhpcy5zZWxlY3RlZFJhbmdlRGF0ZS5zdGFydCAmJiAodGhpcy5zZWxlY3RlZFJhbmdlRGF0ZS5zdGFydC5nZXRUaW1lU3RhbXAoKSA8IGZkRGF0ZS5nZXRUaW1lU3RhbXAoKSkpICYmXG4gICAgICAgICAgICAgICAgKHRoaXMuc2VsZWN0ZWRSYW5nZURhdGUuZW5kICYmICh0aGlzLnNlbGVjdGVkUmFuZ2VEYXRlLmVuZC5nZXRUaW1lU3RhbXAoKSA+IGZkRGF0ZS5nZXRUaW1lU3RhbXAoKSkpXG4gICAgICAgICAgICApKSxcbiAgICAgICAgICAgIGFyaWFMYWJlbDogdGhpcy5jYWxlbmRhckkxOG4uZ2V0RGF5QXJpYUxhYmVsKGZkRGF0ZS50b0RhdGUoKSlcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAodGhpcy5jYWxUeXBlID09PSAncmFuZ2UnICYmICh0aGlzLnNlbGVjdENvdW50ZXIgPT09IDAgfHwgdGhpcy5zZWxlY3RDb3VudGVyID09PSAyKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZGlzYWJsZVJhbmdlU3RhcnRGdW5jdGlvbiAmJiAhZGF5LmRpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgZGF5LmRpc2FibGVkID0gdGhpcy5kaXNhYmxlUmFuZ2VTdGFydEZ1bmN0aW9uKGRheS5kYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmJsb2NrUmFuZ2VTdGFydEZ1bmN0aW9uICYmICFkYXkuYmxvY2tlZCkge1xuICAgICAgICAgICAgICAgIGRheS5ibG9ja2VkID0gdGhpcy5ibG9ja1JhbmdlU3RhcnRGdW5jdGlvbihkYXkuZGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5zZWxlY3RDb3VudGVyID09PSAxKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kaXNhYmxlUmFuZ2VFbmRGdW5jdGlvbiAmJiAhZGF5LmRpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgZGF5LmRpc2FibGVkID0gdGhpcy5kaXNhYmxlUmFuZ2VFbmRGdW5jdGlvbihkYXkuZGF0ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmJsb2NrUmFuZ2VFbmRGdW5jdGlvbiAmJiAhZGF5LmJsb2NrZWQpIHtcbiAgICAgICAgICAgICAgICBkYXkuYmxvY2tlZCA9IHRoaXMuYmxvY2tSYW5nZUVuZEZ1bmN0aW9uKGRheS5kYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHRoYXQgcmV0dXJucyBmaXJzdCBsZXR0ZXIgb2YgZXZlcnkgd2Vla2RheSwgYmFzaW5nIG9uIENhbGVuZGFySTE4bkRlZmF1bHQuIENhbiBiZSBjaGFuZ2VkIGJ5IHVzZXIgYnlcbiAgICAgKiBwcm92aWRpbmcgb3RoZXIgY2xhc3Mgd2hpY2ggaW1wbGVtZW50cyBDYWxlbmRhckkxOG5cbiAgICAgKi9cbiAgICBnZXQgc2hvcnRXZWVrRGF5cygpOiBzdHJpbmdbXSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zaG9ydFdlZWtEYXlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB0aGF0IGlzIGNhbGxlZCB0byByZWZyZXNoIGkxOG4gc2hvcnQgd2VlayBkYXlzLlxuICAgICAqL1xuICAgIHByaXZhdGUgcmVmcmVzaFNob3J0V2Vla0RheXMoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX3Nob3J0V2Vla0RheXMgPSB0aGlzLmNhbGVuZGFySTE4bi5nZXRBbGxTaG9ydFdlZWtkYXlzKClcbiAgICAgICAgICAgIC5zbGljZSh0aGlzLnN0YXJ0aW5nRGF5T2ZXZWVrIC0gMSlcbiAgICAgICAgICAgIC5jb25jYXQodGhpcy5jYWxlbmRhckkxOG4uZ2V0QWxsU2hvcnRXZWVrZGF5cygpLnNsaWNlKDAsIHRoaXMuc3RhcnRpbmdEYXlPZldlZWsgLSAxKSlcbiAgICAgICAgICAgIC5tYXAod2Vla2RheSA9PiB3ZWVrZGF5WzBdLnRvTG9jYWxlVXBwZXJDYXNlKCkpO1xuICAgICAgICB0aGlzLmNoYW5nZURldFJlZi5tYXJrRm9yQ2hlY2soKTtcbiAgICB9XG59XG4iXX0=