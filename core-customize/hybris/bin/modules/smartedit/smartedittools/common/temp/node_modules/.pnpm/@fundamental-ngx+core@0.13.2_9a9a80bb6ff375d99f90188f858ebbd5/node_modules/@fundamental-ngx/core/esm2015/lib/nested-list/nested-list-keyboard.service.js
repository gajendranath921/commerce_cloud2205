/**
 * @fileoverview added by tsickle
 * Generated from: lib/nested-list/nested-list-keyboard.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Subject } from 'rxjs';
import { MenuKeyboardService } from '../menu/menu-keyboard.service';
import { Inject, Injectable } from '@angular/core';
import { takeUntil } from 'rxjs/operators';
/**
 * Nested list keyboard service, which uses MenuKeyboardService, to deal with ArrowUp, ArrowDown, Space, Enter.
 * Also has own handling of ArrowLeft and ArrowRight, to open/close the menu if it has any children.
 */
export class NestedListKeyboardService {
    /**
     * @param {?} keyboardService
     */
    constructor(keyboardService) {
        this.keyboardService = keyboardService;
        /**
         * Event, that is thrown always, when the open/close i being called on item components.
         * Also triggers changing of elements, to remove closed/hidden elements
         */
        this.refresh$ = new Subject();
    }
    /**
     * Recursive function to get all of the NestedItem elements in correct order.
     * @private
     * @param {?} item
     * @return {?}
     */
    getItems(item) {
        /** @type {?} */
        const childrenItems = item.expanded ? item.allChildrenItems : [];
        return childrenItems.reduce((/**
         * @param {?} actualArray
         * @param {?} nextItem
         * @return {?}
         */
        (actualArray, nextItem) => [...actualArray, ...this.getItems(nextItem)]), [item]);
    }
    /**
     * Function called after refresh$ event is triggered.
     * Refresh the list of NestedItems, that the keyboard support should be provided for
     * @param {?} lists
     * @return {?}
     */
    refreshItems(lists) {
        /** @type {?} */
        const items = [];
        /** Gathering all of the items */
        lists.forEach((/**
         * @param {?} list
         * @return {?}
         */
        list => items.push(...this.getAllListItems(list))));
        /** Putting the keyboard support function to each of the items */
        items.forEach((/**
         * @param {?} item
         * @param {?} index
         * @return {?}
         */
        (item, index) => {
            item.keyboardTriggered
                .pipe(takeUntil(this.refresh$))
                .subscribe((/**
             * @param {?} keyboardEvent
             * @return {?}
             */
            (keyboardEvent) => this.handleKeyDown(keyboardEvent, index, items)));
        }));
    }
    /**
     * Method that calls the recursive function, getItems() and gathers all of the items in the NestedList
     * @private
     * @param {?} list
     * @return {?}
     */
    getAllListItems(list) {
        /** @type {?} */
        const _items = [];
        if (list && list.nestedItems) {
            list.nestedItems.toArray().forEach((/**
             * @param {?} item
             * @return {?}
             */
            item => {
                _items.push(...this.getItems(item));
            }));
        }
        return _items;
    }
    /**
     * Keyboard handle function. Uses keyboard support service from MenuComponent, to deal with ArrowUp, ArrowDown, Space, Enter.
     * For ArrowRight, if item is not expanded and has children (list or popup), the open function is triggered.
     * Otherwise it follows ArrowDown functionality.
     * For ArrowLeft, if item is expanded and has children (list or popup), the close function is triggered.
     * Otherwise it follows ArrowUp functionality
     * @private
     * @param {?} keyboardEvent
     * @param {?} index
     * @param {?} items
     * @return {?}
     */
    handleKeyDown(keyboardEvent, index, items) {
        /** @type {?} */
        const item = items[index];
        switch (keyboardEvent.key) {
            case ('ArrowRight'): {
                if (!item.expanded && item.hasChildren) {
                    item.triggerOpen();
                }
                else {
                    if (items.length > index + 1) {
                        items[index + 1].focus();
                    }
                    else {
                        items[0].focus();
                    }
                    keyboardEvent.preventDefault();
                }
                break;
            }
            case ('ArrowLeft'): {
                if (item.expanded && item.hasChildren) {
                    item.triggerClose();
                }
                else {
                    if (index > 0) {
                        items[index - 1].focus();
                    }
                    else {
                        items[items.length - 1].focus();
                    }
                    keyboardEvent.preventDefault();
                }
                break;
            }
            default: {
                this.keyboardService.keyDownHandler(keyboardEvent, index, items);
            }
        }
    }
}
NestedListKeyboardService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
NestedListKeyboardService.ctorParameters = () => [
    { type: MenuKeyboardService, decorators: [{ type: Inject, args: [MenuKeyboardService,] }] }
];
if (false) {
    /**
     * Event, that is thrown always, when the open/close i being called on item components.
     * Also triggers changing of elements, to remove closed/hidden elements
     * @type {?}
     */
    NestedListKeyboardService.prototype.refresh$;
    /**
     * @type {?}
     * @private
     */
    NestedListKeyboardService.prototype.keyboardService;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmVzdGVkLWxpc3Qta2V5Ym9hcmQuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BmdW5kYW1lbnRhbC1uZ3gvY29yZS8iLCJzb3VyY2VzIjpbImxpYi9uZXN0ZWQtbGlzdC9uZXN0ZWQtbGlzdC1rZXlib2FyZC5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUMvQixPQUFPLEVBQUUsbUJBQW1CLEVBQUUsTUFBTSwrQkFBK0IsQ0FBQztBQUNwRSxPQUFPLEVBQUUsTUFBTSxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUNuRCxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7Ozs7O0FBUzNDLE1BQU0sT0FBTyx5QkFBeUI7Ozs7SUFFbEMsWUFDeUMsZUFBb0M7UUFBcEMsb0JBQWUsR0FBZixlQUFlLENBQXFCOzs7OztRQU9wRSxhQUFRLEdBQWtCLElBQUksT0FBTyxFQUFRLENBQUM7SUFOcEQsQ0FBQzs7Ozs7OztJQVNJLFFBQVEsQ0FBQyxJQUF5Qjs7Y0FDaEMsYUFBYSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDLENBQUMsRUFBRTtRQUNoRSxPQUFPLGFBQWEsQ0FBQyxNQUFNOzs7OztRQUN2QixDQUFDLFdBQWtDLEVBQUUsUUFBNkIsRUFBRSxFQUFFLENBQ2xFLENBQUMsR0FBRyxXQUFXLEVBQUUsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEdBQUUsQ0FBQyxJQUFJLENBQUMsQ0FDM0QsQ0FBQztJQUNOLENBQUM7Ozs7Ozs7SUFNTSxZQUFZLENBQUMsS0FBNEI7O2NBRXRDLEtBQUssR0FBMEIsRUFBRTtRQUV2QyxpQ0FBaUM7UUFDakMsS0FBSyxDQUFDLE9BQU87Ozs7UUFBQyxJQUFJLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsR0FBRyxJQUFJLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUMsQ0FBQztRQUVqRSxpRUFBaUU7UUFDakUsS0FBSyxDQUFDLE9BQU87Ozs7O1FBQUMsQ0FBQyxJQUFJLEVBQUUsS0FBSyxFQUFFLEVBQUU7WUFDMUIsSUFBSSxDQUFDLGlCQUFpQjtpQkFDakIsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7aUJBQzlCLFNBQVM7Ozs7WUFBQyxDQUFDLGFBQTRCLEVBQUUsRUFBRSxDQUM1QyxJQUFJLENBQUMsYUFBYSxDQUFDLGFBQWEsRUFBRSxLQUFLLEVBQUUsS0FBSyxDQUFDLEVBQ2xELENBQUE7UUFDTCxDQUFDLEVBQUMsQ0FBQztJQUNQLENBQUM7Ozs7Ozs7SUFHTyxlQUFlLENBQUMsSUFBeUI7O2NBRXZDLE1BQU0sR0FBMEIsRUFBRTtRQUN4QyxJQUFJLElBQUksSUFBSSxJQUFJLENBQUMsV0FBVyxFQUFFO1lBQzFCLElBQUksQ0FBQyxXQUFXLENBQUMsT0FBTyxFQUFFLENBQUMsT0FBTzs7OztZQUFDLElBQUksQ0FBQyxFQUFFO2dCQUN0QyxNQUFNLENBQUMsSUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO1lBQ3hDLENBQUMsRUFBQyxDQUFDO1NBQ047UUFFRCxPQUFPLE1BQU0sQ0FBQztJQUNsQixDQUFDOzs7Ozs7Ozs7Ozs7O0lBU08sYUFBYSxDQUFDLGFBQTRCLEVBQUUsS0FBYSxFQUFFLEtBQTRCOztjQUVyRixJQUFJLEdBQXdCLEtBQUssQ0FBQyxLQUFLLENBQUM7UUFFOUMsUUFBUSxhQUFhLENBQUMsR0FBRyxFQUFFO1lBQ3ZCLEtBQUssQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDO2dCQUNqQixJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsSUFBSSxJQUFJLENBQUMsV0FBVyxFQUFFO29CQUNwQyxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUM7aUJBQ3RCO3FCQUFNO29CQUNILElBQUksS0FBSyxDQUFDLE1BQU0sR0FBRyxLQUFLLEdBQUcsQ0FBQyxFQUFFO3dCQUMxQixLQUFLLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQyxDQUFDLEtBQUssRUFBRSxDQUFDO3FCQUM1Qjt5QkFBTTt3QkFDSCxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxFQUFFLENBQUM7cUJBQ3BCO29CQUNELGFBQWEsQ0FBQyxjQUFjLEVBQUUsQ0FBQztpQkFDbEM7Z0JBQ0QsTUFBTTthQUNUO1lBRUQsS0FBSyxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUM7Z0JBQ2hCLElBQUksSUFBSSxDQUFDLFFBQVEsSUFBSSxJQUFJLENBQUMsV0FBVyxFQUFFO29CQUNuQyxJQUFJLENBQUMsWUFBWSxFQUFFLENBQUM7aUJBQ3ZCO3FCQUFNO29CQUNILElBQUksS0FBSyxHQUFHLENBQUMsRUFBRTt3QkFDWCxLQUFLLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQyxDQUFDLEtBQUssRUFBRSxDQUFDO3FCQUM1Qjt5QkFBTTt3QkFDSCxLQUFLLENBQUMsS0FBSyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQyxLQUFLLEVBQUUsQ0FBQztxQkFDbkM7b0JBQ0QsYUFBYSxDQUFDLGNBQWMsRUFBRSxDQUFDO2lCQUNsQztnQkFDRCxNQUFNO2FBQ1Q7WUFFRCxPQUFPLENBQUMsQ0FBQztnQkFDTCxJQUFJLENBQUMsZUFBZSxDQUFDLGNBQWMsQ0FBQyxhQUFhLEVBQUUsS0FBSyxFQUFFLEtBQUssQ0FBQyxDQUFDO2FBQ3BFO1NBQ0o7SUFFTCxDQUFDOzs7WUFyR0osVUFBVTs7OztZQVZGLG1CQUFtQix1QkFjbkIsTUFBTSxTQUFDLG1CQUFtQjs7Ozs7Ozs7SUFPL0IsNkNBQXVEOzs7OztJQVBuRCxvREFBeUUiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBNZW51S2V5Ym9hcmRTZXJ2aWNlIH0gZnJvbSAnLi4vbWVudS9tZW51LWtleWJvYXJkLnNlcnZpY2UnO1xuaW1wb3J0IHsgSW5qZWN0LCBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyB0YWtlVW50aWwgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBOZXN0ZWRJdGVtSW50ZXJmYWNlIH0gZnJvbSAnLi9uZXN0ZWQtaXRlbS9uZXN0ZWQtaXRlbS5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgTmVzdGVkTGlzdEludGVyZmFjZSB9IGZyb20gJy4vbmVzdGVkLWxpc3QvbmVzdGVkLWxpc3QuaW50ZXJmYWNlJztcblxuLyoqXG4gKiBOZXN0ZWQgbGlzdCBrZXlib2FyZCBzZXJ2aWNlLCB3aGljaCB1c2VzIE1lbnVLZXlib2FyZFNlcnZpY2UsIHRvIGRlYWwgd2l0aCBBcnJvd1VwLCBBcnJvd0Rvd24sIFNwYWNlLCBFbnRlci5cbiAqIEFsc28gaGFzIG93biBoYW5kbGluZyBvZiBBcnJvd0xlZnQgYW5kIEFycm93UmlnaHQsIHRvIG9wZW4vY2xvc2UgdGhlIG1lbnUgaWYgaXQgaGFzIGFueSBjaGlsZHJlbi5cbiAqL1xuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIE5lc3RlZExpc3RLZXlib2FyZFNlcnZpY2Uge1xuXG4gICAgY29uc3RydWN0b3IgKFxuICAgICAgICBASW5qZWN0KE1lbnVLZXlib2FyZFNlcnZpY2UpIHByaXZhdGUga2V5Ym9hcmRTZXJ2aWNlOiBNZW51S2V5Ym9hcmRTZXJ2aWNlLFxuICAgICkge31cblxuICAgIC8qKlxuICAgICAqIEV2ZW50LCB0aGF0IGlzIHRocm93biBhbHdheXMsIHdoZW4gdGhlIG9wZW4vY2xvc2UgaSBiZWluZyBjYWxsZWQgb24gaXRlbSBjb21wb25lbnRzLlxuICAgICAqIEFsc28gdHJpZ2dlcnMgY2hhbmdpbmcgb2YgZWxlbWVudHMsIHRvIHJlbW92ZSBjbG9zZWQvaGlkZGVuIGVsZW1lbnRzXG4gICAgICovXG4gICAgcmVhZG9ubHkgcmVmcmVzaCQ6IFN1YmplY3Q8dm9pZD4gPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuXG4gICAgLyoqIFJlY3Vyc2l2ZSBmdW5jdGlvbiB0byBnZXQgYWxsIG9mIHRoZSBOZXN0ZWRJdGVtIGVsZW1lbnRzIGluIGNvcnJlY3Qgb3JkZXIuICovXG4gICAgcHJpdmF0ZSBnZXRJdGVtcyhpdGVtOiBOZXN0ZWRJdGVtSW50ZXJmYWNlKTogTmVzdGVkSXRlbUludGVyZmFjZVtdIHtcbiAgICAgICAgY29uc3QgY2hpbGRyZW5JdGVtcyA9IGl0ZW0uZXhwYW5kZWQgPyBpdGVtLmFsbENoaWxkcmVuSXRlbXMgOiBbXTtcbiAgICAgICAgcmV0dXJuIGNoaWxkcmVuSXRlbXMucmVkdWNlKFxuICAgICAgICAgICAgKGFjdHVhbEFycmF5OiBOZXN0ZWRJdGVtSW50ZXJmYWNlW10sIG5leHRJdGVtOiBOZXN0ZWRJdGVtSW50ZXJmYWNlKSA9PlxuICAgICAgICAgICAgICAgIFsuLi5hY3R1YWxBcnJheSwgLi4udGhpcy5nZXRJdGVtcyhuZXh0SXRlbSldLCBbaXRlbV1cbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiBjYWxsZWQgYWZ0ZXIgcmVmcmVzaCQgZXZlbnQgaXMgdHJpZ2dlcmVkLlxuICAgICAqIFJlZnJlc2ggdGhlIGxpc3Qgb2YgTmVzdGVkSXRlbXMsIHRoYXQgdGhlIGtleWJvYXJkIHN1cHBvcnQgc2hvdWxkIGJlIHByb3ZpZGVkIGZvclxuICAgICAqL1xuICAgIHB1YmxpYyByZWZyZXNoSXRlbXMobGlzdHM6IE5lc3RlZExpc3RJbnRlcmZhY2VbXSk6IHZvaWQge1xuXG4gICAgICAgIGNvbnN0IGl0ZW1zOiBOZXN0ZWRJdGVtSW50ZXJmYWNlW10gPSBbXTtcblxuICAgICAgICAvKiogR2F0aGVyaW5nIGFsbCBvZiB0aGUgaXRlbXMgKi9cbiAgICAgICAgbGlzdHMuZm9yRWFjaChsaXN0ID0+IGl0ZW1zLnB1c2goLi4udGhpcy5nZXRBbGxMaXN0SXRlbXMobGlzdCkpKTtcblxuICAgICAgICAvKiogUHV0dGluZyB0aGUga2V5Ym9hcmQgc3VwcG9ydCBmdW5jdGlvbiB0byBlYWNoIG9mIHRoZSBpdGVtcyAqL1xuICAgICAgICBpdGVtcy5mb3JFYWNoKChpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgaXRlbS5rZXlib2FyZFRyaWdnZXJlZFxuICAgICAgICAgICAgICAgIC5waXBlKHRha2VVbnRpbCh0aGlzLnJlZnJlc2gkKSlcbiAgICAgICAgICAgICAgICAuc3Vic2NyaWJlKChrZXlib2FyZEV2ZW50OiBLZXlib2FyZEV2ZW50KSA9PlxuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlS2V5RG93bihrZXlib2FyZEV2ZW50LCBpbmRleCwgaXRlbXMpXG4gICAgICAgICAgICApXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKiBNZXRob2QgdGhhdCBjYWxscyB0aGUgcmVjdXJzaXZlIGZ1bmN0aW9uLCBnZXRJdGVtcygpIGFuZCBnYXRoZXJzIGFsbCBvZiB0aGUgaXRlbXMgaW4gdGhlIE5lc3RlZExpc3QgKi9cbiAgICBwcml2YXRlIGdldEFsbExpc3RJdGVtcyhsaXN0OiBOZXN0ZWRMaXN0SW50ZXJmYWNlKTogTmVzdGVkSXRlbUludGVyZmFjZVtdIHtcblxuICAgICAgICBjb25zdCBfaXRlbXM6IE5lc3RlZEl0ZW1JbnRlcmZhY2VbXSA9IFtdO1xuICAgICAgICBpZiAobGlzdCAmJiBsaXN0Lm5lc3RlZEl0ZW1zKSB7XG4gICAgICAgICAgICBsaXN0Lm5lc3RlZEl0ZW1zLnRvQXJyYXkoKS5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgICAgIF9pdGVtcy5wdXNoKC4uLnRoaXMuZ2V0SXRlbXMoaXRlbSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gX2l0ZW1zO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEtleWJvYXJkIGhhbmRsZSBmdW5jdGlvbi4gVXNlcyBrZXlib2FyZCBzdXBwb3J0IHNlcnZpY2UgZnJvbSBNZW51Q29tcG9uZW50LCB0byBkZWFsIHdpdGggQXJyb3dVcCwgQXJyb3dEb3duLCBTcGFjZSwgRW50ZXIuXG4gICAgICogRm9yIEFycm93UmlnaHQsIGlmIGl0ZW0gaXMgbm90IGV4cGFuZGVkIGFuZCBoYXMgY2hpbGRyZW4gKGxpc3Qgb3IgcG9wdXApLCB0aGUgb3BlbiBmdW5jdGlvbiBpcyB0cmlnZ2VyZWQuXG4gICAgICogT3RoZXJ3aXNlIGl0IGZvbGxvd3MgQXJyb3dEb3duIGZ1bmN0aW9uYWxpdHkuXG4gICAgICogRm9yIEFycm93TGVmdCwgaWYgaXRlbSBpcyBleHBhbmRlZCBhbmQgaGFzIGNoaWxkcmVuIChsaXN0IG9yIHBvcHVwKSwgdGhlIGNsb3NlIGZ1bmN0aW9uIGlzIHRyaWdnZXJlZC5cbiAgICAgKiBPdGhlcndpc2UgaXQgZm9sbG93cyBBcnJvd1VwIGZ1bmN0aW9uYWxpdHlcbiAgICAgKi9cbiAgICBwcml2YXRlIGhhbmRsZUtleURvd24oa2V5Ym9hcmRFdmVudDogS2V5Ym9hcmRFdmVudCwgaW5kZXg6IG51bWJlciwgaXRlbXM6IE5lc3RlZEl0ZW1JbnRlcmZhY2VbXSk6IHZvaWQge1xuXG4gICAgICAgIGNvbnN0IGl0ZW06IE5lc3RlZEl0ZW1JbnRlcmZhY2UgPSBpdGVtc1tpbmRleF07XG5cbiAgICAgICAgc3dpdGNoIChrZXlib2FyZEV2ZW50LmtleSkge1xuICAgICAgICAgICAgY2FzZSAoJ0Fycm93UmlnaHQnKToge1xuICAgICAgICAgICAgICAgIGlmICghaXRlbS5leHBhbmRlZCAmJiBpdGVtLmhhc0NoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0udHJpZ2dlck9wZW4oKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbXMubGVuZ3RoID4gaW5kZXggKyAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtc1tpbmRleCArIDFdLmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtc1swXS5mb2N1cygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGtleWJvYXJkRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhc2UgKCdBcnJvd0xlZnQnKToge1xuICAgICAgICAgICAgICAgIGlmIChpdGVtLmV4cGFuZGVkICYmIGl0ZW0uaGFzQ2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS50cmlnZ2VyQ2xvc2UoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtc1tpbmRleCAtIDFdLmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtc1tpdGVtcy5sZW5ndGggLSAxXS5mb2N1cygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGtleWJvYXJkRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICB0aGlzLmtleWJvYXJkU2VydmljZS5rZXlEb3duSGFuZGxlcihrZXlib2FyZEV2ZW50LCBpbmRleCwgaXRlbXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9XG5cbn1cbiJdfQ==