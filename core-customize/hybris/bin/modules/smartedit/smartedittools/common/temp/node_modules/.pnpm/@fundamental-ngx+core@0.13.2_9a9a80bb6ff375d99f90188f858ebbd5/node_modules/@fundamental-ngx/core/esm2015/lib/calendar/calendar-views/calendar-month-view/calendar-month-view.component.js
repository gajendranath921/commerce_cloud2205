/**
 * @fileoverview added by tsickle
 * Generated from: lib/calendar/calendar-views/calendar-month-view/calendar-month-view.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Component, Input, Output, ViewEncapsulation, EventEmitter, ElementRef, ChangeDetectorRef, ChangeDetectionStrategy } from '@angular/core';
import { FdDate } from '../../models/fd-date';
import { CalendarI18n } from '../../i18n/calendar-i18n';
import { Subject } from 'rxjs';
import { takeUntil } from 'rxjs/operators';
import { CalendarService } from '../../calendar.service';
/**
 * Component representing the month view of the calendar.
 */
export class CalendarMonthViewComponent {
    /**
     * @param {?} eRef
     * @param {?} cdRef
     * @param {?} calendarI18n
     * @param {?} calendarService
     */
    constructor(eRef, cdRef, calendarI18n, calendarService) {
        this.eRef = eRef;
        this.cdRef = cdRef;
        this.calendarI18n = calendarI18n;
        this.calendarService = calendarService;
        /**
         * A number offset used to achieve the 1-12 representation of the calendar
         */
        this._monthOffset = 1;
        this._amountOfColPerRow = 4;
        /**
         * An RxJS Subject that will kill the data stream upon component’s destruction (for unsubscribing)
         */
        this.onDestroy$ = new Subject();
        /**
         * An event fired when a new month is selected
         */
        this.monthClicked = new EventEmitter();
    }
    /**
     * @hidden
     * @return {?}
     */
    ngOnInit() {
        this.calendarService.focusEscapeFunction = this.focusEscapeFunction;
        this.refreshShortMonthNames();
        this.calendarService.onFocusIdChange
            .pipe(takeUntil(this.onDestroy$))
            .subscribe((/**
         * @param {?} index
         * @return {?}
         */
        index => this.focusElement('#' + this.id + '-fd-month-' + index)));
        this.calendarService.onKeySelect
            .pipe(takeUntil(this.onDestroy$))
            .subscribe((/**
         * @param {?} index
         * @return {?}
         */
        index => this.selectMonth(index)));
        this.calendarI18n.i18nChange
            .pipe(takeUntil(this.onDestroy$))
            .subscribe((/**
         * @return {?}
         */
        () => this.refreshShortMonthNames()));
    }
    /**
     * @hidden
     * @return {?}
     */
    ngOnDestroy() {
        this.onDestroy$.next();
        this.onDestroy$.complete();
    }
    /**
     * Get a number (1-12) representing the current month
     * @return {?}
     */
    get currentMonth() {
        return FdDate.getToday().month;
    }
    /**
     * Getter for the private class member _monthOffset
     * @return {?}
     */
    get monthOffset() {
        return this._monthOffset;
    }
    /**
     * Method for handling the mouse click event when a month is selected
     * @param {?} selectedMonth
     * @param {?=} event
     * @return {?}
     */
    selectMonth(selectedMonth, event) {
        if (event) {
            event.stopPropagation();
        }
        this.monthSelected = selectedMonth + this.monthOffset;
        this.monthClicked.emit(this.monthSelected);
    }
    /**
     * Method for handling the keyboard events (a11y)
     * @param {?} event
     * @param {?} index
     * @return {?}
     */
    onKeydownMonthHandler(event, index) {
        this.calendarService.onKeydownHandler(event, index);
    }
    /**
     * Method that allows to focus elements inside this component
     * @param {?} elementSelector
     * @return {?}
     */
    focusElement(elementSelector) {
        /** @type {?} */
        const elementToFocus = this.eRef.nativeElement.querySelector(elementSelector);
        if (elementToFocus) {
            elementToFocus.focus();
        }
    }
    /**
     * Method returning id of month cell
     * @param {?} rowIndex
     * @param {?} colIndex
     * @return {?}
     */
    getId(rowIndex, colIndex) {
        return rowIndex * this._amountOfColPerRow + colIndex;
    }
    /**
     * Method that checks if this is current month
     * @param {?} id
     * @return {?}
     */
    isCurrent(id) {
        return id + this._monthOffset === this.currentMonth;
    }
    /**
     * Method that check if this is selected month
     * @param {?} id
     * @return {?}
     */
    isSelected(id) {
        return id + this._monthOffset === this.monthSelected;
    }
    /**
     * Method that returns grid of short month names from currently provided calendarI18n service
     * @return {?}
     */
    get shortMonthNames() {
        return this._shortMonthNames;
    }
    /**
     * Method that returns the full name of month for grid element.
     * @param {?} rowIndex
     * @param {?} colIndex
     * @return {?}
     */
    getFullMonthName(rowIndex, colIndex) {
        /** @type {?} */
        const index = this.getId(rowIndex, colIndex);
        return this._fullMonthNames[index];
    }
    /**
     * Method that rewrite short month names, used mostly in case of i18n service language change
     * @private
     * @return {?}
     */
    refreshShortMonthNames() {
        /** @type {?} */
        const monthNames = [...this.calendarI18n.getAllShortMonthNames()];
        this._fullMonthNames = [...this.calendarI18n.getAllFullMonthNames()];
        /** @type {?} */
        const twoDimensionMonthNames = [];
        /** Creating 2d grid */
        while (monthNames.length) {
            twoDimensionMonthNames.push(monthNames.splice(0, this._amountOfColPerRow));
        }
        this._shortMonthNames = twoDimensionMonthNames;
        this.cdRef.markForCheck();
    }
}
CalendarMonthViewComponent.decorators = [
    { type: Component, args: [{
                selector: 'fd-calendar-month-view',
                template: "<div class=\"fd-calendar__months\">\n    <table class=\"fd-calendar__table\" role=\"grid\">\n        <tbody class=\"fd-calendar__group\">\n        <tr class=\"fd-calendar__row\"\n            *ngFor=\"let colMonths of shortMonthNames; let rowIndex = index\">\n            <td class=\"fd-calendar__item\"\n                *ngFor=\"let month of colMonths; let colIndex = index\"\n                [ngClass]=\"{\n                    'fd-calendar__item--current': isCurrent(getId(rowIndex, colIndex)),\n                    'is-selected': isSelected(getId(rowIndex, colIndex))\n                }\"\n                [attr.tabIndex]=\"isSelected(getId(rowIndex, colIndex)) ? 0 : -1\"\n                [attr.id]=\"id + '-fd-month-' + getId(rowIndex, colIndex)\"\n                (keydown)=\"onKeydownMonthHandler($event, getId(rowIndex, colIndex))\"\n                (click)=\"selectMonth(getId(rowIndex, colIndex), $event)\">\n                <span role=\"button\" class=\"fd-calendar__text\" [attr.aria-label]=\"getFullMonthName(rowIndex, colIndex)\">\n                    {{ month }}\n                </span>\n            </td>\n        </tr>\n        </tbody>\n    </table>\n</div>\n",
                encapsulation: ViewEncapsulation.None,
                host: {
                    '[attr.id]': 'id + "-month-view"'
                },
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [""]
            }] }
];
/** @nocollapse */
CalendarMonthViewComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: ChangeDetectorRef },
    { type: CalendarI18n },
    { type: CalendarService }
];
CalendarMonthViewComponent.propDecorators = {
    id: [{ type: Input }],
    monthSelected: [{ type: Input }],
    focusEscapeFunction: [{ type: Input }],
    monthClicked: [{ type: Output }]
};
if (false) {
    /**
     * A number offset used to achieve the 1-12 representation of the calendar
     * @type {?}
     * @private
     */
    CalendarMonthViewComponent.prototype._monthOffset;
    /**
     * @type {?}
     * @private
     */
    CalendarMonthViewComponent.prototype._amountOfColPerRow;
    /**
     * @type {?}
     * @private
     */
    CalendarMonthViewComponent.prototype._shortMonthNames;
    /**
     * @type {?}
     * @private
     */
    CalendarMonthViewComponent.prototype._fullMonthNames;
    /**
     * An RxJS Subject that will kill the data stream upon component’s destruction (for unsubscribing)
     * @type {?}
     * @private
     */
    CalendarMonthViewComponent.prototype.onDestroy$;
    /**
     * The id of the calendar passed from the parent component
     * @type {?}
     */
    CalendarMonthViewComponent.prototype.id;
    /**
     * A number (1-12) representing the selected month
     * @type {?}
     */
    CalendarMonthViewComponent.prototype.monthSelected;
    /**
     * A function that handles escape focus
     * @type {?}
     */
    CalendarMonthViewComponent.prototype.focusEscapeFunction;
    /**
     * An event fired when a new month is selected
     * @type {?}
     */
    CalendarMonthViewComponent.prototype.monthClicked;
    /**
     * @type {?}
     * @private
     */
    CalendarMonthViewComponent.prototype.eRef;
    /**
     * @type {?}
     * @private
     */
    CalendarMonthViewComponent.prototype.cdRef;
    /**
     * @type {?}
     * @private
     */
    CalendarMonthViewComponent.prototype.calendarI18n;
    /**
     * @type {?}
     * @private
     */
    CalendarMonthViewComponent.prototype.calendarService;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2FsZW5kYXItbW9udGgtdmlldy5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AZnVuZGFtZW50YWwtbmd4L2NvcmUvIiwic291cmNlcyI6WyJsaWIvY2FsZW5kYXIvY2FsZW5kYXItdmlld3MvY2FsZW5kYXItbW9udGgtdmlldy9jYWxlbmRhci1tb250aC12aWV3LmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLE9BQU8sRUFDSCxTQUFTLEVBQ1QsS0FBSyxFQUNMLE1BQU0sRUFDTixpQkFBaUIsRUFDakIsWUFBWSxFQUNaLFVBQVUsRUFHVixpQkFBaUIsRUFDakIsdUJBQXVCLEVBQzFCLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBRSxNQUFNLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQUM5QyxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sMEJBQTBCLENBQUM7QUFDeEQsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUMvQixPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDM0MsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLHdCQUF3QixDQUFDOzs7O0FBYXpELE1BQU0sT0FBTywwQkFBMEI7Ozs7Ozs7SUE2Qm5DLFlBQ1ksSUFBZ0IsRUFDaEIsS0FBd0IsRUFDeEIsWUFBMEIsRUFDMUIsZUFBZ0M7UUFIaEMsU0FBSSxHQUFKLElBQUksQ0FBWTtRQUNoQixVQUFLLEdBQUwsS0FBSyxDQUFtQjtRQUN4QixpQkFBWSxHQUFaLFlBQVksQ0FBYztRQUMxQixvQkFBZSxHQUFmLGVBQWUsQ0FBaUI7Ozs7UUE5QjNCLGlCQUFZLEdBQVcsQ0FBQyxDQUFDO1FBRXpCLHVCQUFrQixHQUFXLENBQUMsQ0FBQzs7OztRQU0vQixlQUFVLEdBQWtCLElBQUksT0FBTyxFQUFRLENBQUM7Ozs7UUFnQnhELGlCQUFZLEdBQXlCLElBQUksWUFBWSxFQUFVLENBQUM7SUFRekUsQ0FBQzs7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O0lBRzlCLGtEQUN5RTs7Ozs7SUFHckUsMENBQXdCOzs7OztJQUN4QiwyQ0FBZ0M7Ozs7O0lBQ2hDLGtEQUFrQzs7Ozs7SUFDbEMscURBQXdDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgICBDb21wb25lbnQsXG4gICAgSW5wdXQsXG4gICAgT3V0cHV0LFxuICAgIFZpZXdFbmNhcHN1bGF0aW9uLFxuICAgIEV2ZW50RW1pdHRlcixcbiAgICBFbGVtZW50UmVmLFxuICAgIE9uSW5pdCxcbiAgICBPbkRlc3Ryb3ksXG4gICAgQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3lcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBGZERhdGUgfSBmcm9tICcuLi8uLi9tb2RlbHMvZmQtZGF0ZSc7XG5pbXBvcnQgeyBDYWxlbmRhckkxOG4gfSBmcm9tICcuLi8uLi9pMThuL2NhbGVuZGFyLWkxOG4nO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgdGFrZVVudGlsIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgQ2FsZW5kYXJTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vY2FsZW5kYXIuc2VydmljZSc7XG5cbi8qKiBDb21wb25lbnQgcmVwcmVzZW50aW5nIHRoZSBtb250aCB2aWV3IG9mIHRoZSBjYWxlbmRhci4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnZmQtY2FsZW5kYXItbW9udGgtdmlldycsXG4gICAgdGVtcGxhdGVVcmw6ICcuL2NhbGVuZGFyLW1vbnRoLXZpZXcuY29tcG9uZW50Lmh0bWwnLFxuICAgIHN0eWxlVXJsczogWycuL2NhbGVuZGFyLW1vbnRoLXZpZXcuY29tcG9uZW50LnNjc3MnXSxcbiAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICAgIGhvc3Q6IHtcbiAgICAgICAgJ1thdHRyLmlkXSc6ICdpZCArIFwiLW1vbnRoLXZpZXdcIidcbiAgICB9LFxuICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXG59KVxuZXhwb3J0IGNsYXNzIENhbGVuZGFyTW9udGhWaWV3Q29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0LCBPbkRlc3Ryb3kge1xuXG4gICAgLyoqIEEgbnVtYmVyIG9mZnNldCB1c2VkIHRvIGFjaGlldmUgdGhlIDEtMTIgcmVwcmVzZW50YXRpb24gb2YgdGhlIGNhbGVuZGFyICovXG4gICAgcHJpdmF0ZSByZWFkb25seSBfbW9udGhPZmZzZXQ6IG51bWJlciA9IDE7XG5cbiAgICBwcml2YXRlIHJlYWRvbmx5IF9hbW91bnRPZkNvbFBlclJvdzogbnVtYmVyID0gNDtcblxuICAgIHByaXZhdGUgX3Nob3J0TW9udGhOYW1lczogc3RyaW5nW11bXTtcbiAgICBwcml2YXRlIF9mdWxsTW9udGhOYW1lczogc3RyaW5nW107XG5cbiAgICAvKiogQW4gUnhKUyBTdWJqZWN0IHRoYXQgd2lsbCBraWxsIHRoZSBkYXRhIHN0cmVhbSB1cG9uIGNvbXBvbmVudOKAmXMgZGVzdHJ1Y3Rpb24gKGZvciB1bnN1YnNjcmliaW5nKSAgKi9cbiAgICBwcml2YXRlIHJlYWRvbmx5IG9uRGVzdHJveSQ6IFN1YmplY3Q8dm9pZD4gPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuXG4gICAgLyoqIFRoZSBpZCBvZiB0aGUgY2FsZW5kYXIgcGFzc2VkIGZyb20gdGhlIHBhcmVudCBjb21wb25lbnQgKi9cbiAgICBASW5wdXQoKVxuICAgIGlkOiBzdHJpbmc7XG5cbiAgICAvKiogQSBudW1iZXIgKDEtMTIpIHJlcHJlc2VudGluZyB0aGUgc2VsZWN0ZWQgbW9udGggKi9cbiAgICBASW5wdXQoKVxuICAgIG1vbnRoU2VsZWN0ZWQ6IG51bWJlcjtcblxuICAgIC8qKiBBIGZ1bmN0aW9uIHRoYXQgaGFuZGxlcyBlc2NhcGUgZm9jdXMgKi9cbiAgICBASW5wdXQoKVxuICAgIGZvY3VzRXNjYXBlRnVuY3Rpb246IEZ1bmN0aW9uO1xuXG4gICAgLyoqIEFuIGV2ZW50IGZpcmVkIHdoZW4gYSBuZXcgbW9udGggaXMgc2VsZWN0ZWQgKi9cbiAgICBAT3V0cHV0KClcbiAgICByZWFkb25seSBtb250aENsaWNrZWQ6IEV2ZW50RW1pdHRlcjxudW1iZXI+ID0gbmV3IEV2ZW50RW1pdHRlcjxudW1iZXI+KCk7XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHJpdmF0ZSBlUmVmOiBFbGVtZW50UmVmLFxuICAgICAgICBwcml2YXRlIGNkUmVmOiBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICAgICAgcHJpdmF0ZSBjYWxlbmRhckkxOG46IENhbGVuZGFySTE4bixcbiAgICAgICAgcHJpdmF0ZSBjYWxlbmRhclNlcnZpY2U6IENhbGVuZGFyU2VydmljZVxuICAgICkge1xuICAgIH1cblxuICAgIC8qKiBAaGlkZGVuICovXG4gICAgbmdPbkluaXQoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuY2FsZW5kYXJTZXJ2aWNlLmZvY3VzRXNjYXBlRnVuY3Rpb24gPSB0aGlzLmZvY3VzRXNjYXBlRnVuY3Rpb247XG4gICAgICAgIHRoaXMucmVmcmVzaFNob3J0TW9udGhOYW1lcygpO1xuXG4gICAgICAgIHRoaXMuY2FsZW5kYXJTZXJ2aWNlLm9uRm9jdXNJZENoYW5nZVxuICAgICAgICAgICAgLnBpcGUodGFrZVVudGlsKHRoaXMub25EZXN0cm95JCkpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKGluZGV4ID0+IHRoaXMuZm9jdXNFbGVtZW50KCcjJyArIHRoaXMuaWQgKyAnLWZkLW1vbnRoLScgKyBpbmRleCkpXG4gICAgICAgIDtcblxuICAgICAgICB0aGlzLmNhbGVuZGFyU2VydmljZS5vbktleVNlbGVjdFxuICAgICAgICAgICAgLnBpcGUodGFrZVVudGlsKHRoaXMub25EZXN0cm95JCkpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKGluZGV4ID0+IHRoaXMuc2VsZWN0TW9udGgoaW5kZXgpKVxuICAgICAgICA7XG5cbiAgICAgICAgdGhpcy5jYWxlbmRhckkxOG4uaTE4bkNoYW5nZVxuICAgICAgICAgICAgLnBpcGUodGFrZVVudGlsKHRoaXMub25EZXN0cm95JCkpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKCgpID0+IHRoaXMucmVmcmVzaFNob3J0TW9udGhOYW1lcygpKVxuICAgICAgICA7XG4gICAgfVxuXG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5vbkRlc3Ryb3kkLm5leHQoKTtcbiAgICAgICAgdGhpcy5vbkRlc3Ryb3kkLmNvbXBsZXRlKCk7XG4gICAgfVxuXG4gICAgLyoqIEdldCBhIG51bWJlciAoMS0xMikgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IG1vbnRoICAqL1xuICAgIGdldCBjdXJyZW50TW9udGgoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIEZkRGF0ZS5nZXRUb2RheSgpLm1vbnRoO1xuICAgIH1cblxuICAgIC8qKiAgR2V0dGVyIGZvciB0aGUgcHJpdmF0ZSBjbGFzcyBtZW1iZXIgX21vbnRoT2Zmc2V0ICovXG4gICAgZ2V0IG1vbnRoT2Zmc2V0KCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tb250aE9mZnNldDtcbiAgICB9XG5cbiAgICAvKiogTWV0aG9kIGZvciBoYW5kbGluZyB0aGUgbW91c2UgY2xpY2sgZXZlbnQgd2hlbiBhIG1vbnRoIGlzIHNlbGVjdGVkICAqL1xuICAgIHNlbGVjdE1vbnRoKHNlbGVjdGVkTW9udGg6IG51bWJlciwgZXZlbnQ/OiBNb3VzZUV2ZW50KTogdm9pZCB7XG4gICAgICAgIGlmIChldmVudCkge1xuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tb250aFNlbGVjdGVkID0gc2VsZWN0ZWRNb250aCArIHRoaXMubW9udGhPZmZzZXQ7XG4gICAgICAgIHRoaXMubW9udGhDbGlja2VkLmVtaXQodGhpcy5tb250aFNlbGVjdGVkKTtcbiAgICB9XG5cbiAgICAvKiogTWV0aG9kIGZvciBoYW5kbGluZyB0aGUga2V5Ym9hcmQgZXZlbnRzIChhMTF5KSAqL1xuICAgIG9uS2V5ZG93bk1vbnRoSGFuZGxlcihldmVudCwgaW5kZXg6IG51bWJlcik6IHZvaWQge1xuICAgICAgICB0aGlzLmNhbGVuZGFyU2VydmljZS5vbktleWRvd25IYW5kbGVyKGV2ZW50LCBpbmRleCk7XG4gICAgfVxuXG4gICAgLyoqIE1ldGhvZCB0aGF0IGFsbG93cyB0byBmb2N1cyBlbGVtZW50cyBpbnNpZGUgdGhpcyBjb21wb25lbnQgKi9cbiAgICBmb2N1c0VsZW1lbnQoZWxlbWVudFNlbGVjdG9yOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgZWxlbWVudFRvRm9jdXM6IEhUTUxFbGVtZW50ID0gdGhpcy5lUmVmLm5hdGl2ZUVsZW1lbnQucXVlcnlTZWxlY3RvcihlbGVtZW50U2VsZWN0b3IpO1xuICAgICAgICBpZiAoZWxlbWVudFRvRm9jdXMpIHtcbiAgICAgICAgICAgIGVsZW1lbnRUb0ZvY3VzLmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogTWV0aG9kIHJldHVybmluZyBpZCBvZiBtb250aCBjZWxsICovXG4gICAgZ2V0SWQocm93SW5kZXg6IG51bWJlciwgY29sSW5kZXg6IG51bWJlcik6IG51bWJlciB7XG4gICAgICAgIHJldHVybiByb3dJbmRleCAqIHRoaXMuX2Ftb3VudE9mQ29sUGVyUm93ICsgY29sSW5kZXg7XG4gICAgfVxuXG4gICAgLyoqIE1ldGhvZCB0aGF0IGNoZWNrcyBpZiB0aGlzIGlzIGN1cnJlbnQgbW9udGggKi9cbiAgICBpc0N1cnJlbnQoaWQ6IG51bWJlcik6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gaWQgKyB0aGlzLl9tb250aE9mZnNldCA9PT0gdGhpcy5jdXJyZW50TW9udGg7XG4gICAgfVxuXG4gICAgLyoqIE1ldGhvZCB0aGF0IGNoZWNrIGlmIHRoaXMgaXMgc2VsZWN0ZWQgbW9udGggKi9cbiAgICBpc1NlbGVjdGVkKGlkOiBudW1iZXIpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIGlkICsgdGhpcy5fbW9udGhPZmZzZXQgPT09IHRoaXMubW9udGhTZWxlY3RlZDtcbiAgICB9XG5cbiAgICAvKiogTWV0aG9kIHRoYXQgcmV0dXJucyBncmlkIG9mIHNob3J0IG1vbnRoIG5hbWVzIGZyb20gY3VycmVudGx5IHByb3ZpZGVkIGNhbGVuZGFySTE4biBzZXJ2aWNlICovXG4gICAgZ2V0IHNob3J0TW9udGhOYW1lcygpOiBzdHJpbmdbXVtdIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Nob3J0TW9udGhOYW1lcztcbiAgICB9XG5cbiAgICAvKiogTWV0aG9kIHRoYXQgcmV0dXJucyB0aGUgZnVsbCBuYW1lIG9mIG1vbnRoIGZvciBncmlkIGVsZW1lbnQuICovXG4gICAgZ2V0RnVsbE1vbnRoTmFtZShyb3dJbmRleDogbnVtYmVyLCBjb2xJbmRleDogbnVtYmVyKTogc3RyaW5nIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmdldElkKHJvd0luZGV4LCBjb2xJbmRleCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9mdWxsTW9udGhOYW1lc1tpbmRleF07XG4gICAgfVxuXG4gICAgLyoqIE1ldGhvZCB0aGF0IHJld3JpdGUgc2hvcnQgbW9udGggbmFtZXMsIHVzZWQgbW9zdGx5IGluIGNhc2Ugb2YgaTE4biBzZXJ2aWNlIGxhbmd1YWdlIGNoYW5nZSAqL1xuICAgIHByaXZhdGUgcmVmcmVzaFNob3J0TW9udGhOYW1lcygpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgbW9udGhOYW1lczogc3RyaW5nW10gPSBbLi4udGhpcy5jYWxlbmRhckkxOG4uZ2V0QWxsU2hvcnRNb250aE5hbWVzKCldO1xuICAgICAgICB0aGlzLl9mdWxsTW9udGhOYW1lcyA9IFsuLi50aGlzLmNhbGVuZGFySTE4bi5nZXRBbGxGdWxsTW9udGhOYW1lcygpXTtcbiAgICAgICAgY29uc3QgdHdvRGltZW5zaW9uTW9udGhOYW1lczogc3RyaW5nW11bXSA9IFtdO1xuICAgICAgICAvKiogQ3JlYXRpbmcgMmQgZ3JpZCAqL1xuICAgICAgICB3aGlsZSAobW9udGhOYW1lcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHR3b0RpbWVuc2lvbk1vbnRoTmFtZXMucHVzaChtb250aE5hbWVzLnNwbGljZSgwLCB0aGlzLl9hbW91bnRPZkNvbFBlclJvdykpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Nob3J0TW9udGhOYW1lcyA9IHR3b0RpbWVuc2lvbk1vbnRoTmFtZXM7XG4gICAgICAgIHRoaXMuY2RSZWYubWFya0ZvckNoZWNrKCk7XG4gICAgfVxufVxuIl19