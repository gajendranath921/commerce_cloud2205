/**
 * @fileoverview added by tsickle
 * Generated from: lib/nested-list/nested-link/nested-link.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { ChangeDetectorRef, ContentChild, Directive, ElementRef, EventEmitter, HostBinding, Input, Output, Renderer2 } from '@angular/core';
import { NestedListTitleDirective } from '../nested-list-directives';
import { NestedListStateService } from '../nested-list-state.service';
export class NestedLinkDirective {
    /**
     * @hidden
     * @param {?} renderer
     * @param {?} elementRef
     * @param {?} nestedListStateService
     * @param {?} changeDetRef
     */
    constructor(renderer, elementRef, nestedListStateService, changeDetRef) {
        this.renderer = renderer;
        this.elementRef = elementRef;
        this.nestedListStateService = nestedListStateService;
        this.changeDetRef = changeDetRef;
        /**
         * @hidden
         */
        this.fdNestedListItemClass = true;
        /**
         * Event that is thrown, when any keyboard event is dispatched on this element
         */
        this.keyboardTriggered = new EventEmitter();
        /**
         * Event that is thrown, when this element is clicked
         */
        this.clicked = new EventEmitter();
        /**
         *
         */
        this.controlSelected = this._selected;
        /**
         * @hidden
         * Attribute controlled by the parent `NestedItemDirective`
         */
        this.expanded = false;
        /**
         * @hidden
         * Attribute controlled by the parent `NestedItemDirective`
         */
        this.hasChildren = false;
    }
    /**
     * Whether this element is selected, the `selected` state is propagated to all of parent elements
     * @param {?} selected
     * @return {?}
     */
    set selected(selected) {
        if (this._selected !== selected) {
            this._selected = selected;
            this.controlSelected = selected;
            this.nestedListStateService.refresh$.next();
        }
    }
    /**
     * @return {?}
     */
    get selected() {
        return this._selected;
    }
    /**
     * Set focus on the element.
     * @return {?}
     */
    focus() {
        this.elementRef.nativeElement.focus();
    }
    /**
     * Dispatches the click event on the element
     * @return {?}
     */
    click() {
        this.elementRef.nativeElement.click();
    }
    /**
     * @hidden
     * @return {?}
     */
    ngOnInit() {
        /** Add event listeners on the element */
        /** Keyboard */
        this.renderer.listen(this.elementRef.nativeElement, 'keydown', (/**
         * @param {?} event
         * @return {?}
         */
        (event) => this.keyboardTriggered.emit(event)));
        /** Mouse Click */
        this.renderer.listen(this.elementRef.nativeElement, 'click', (/**
         * @param {?} event
         * @return {?}
         */
        (event) => {
            if (this.onClickCallback) {
                this.onClickCallback();
            }
            this.clicked.emit(event);
        }));
    }
    /**
     * Returns the title value of the title directive
     * @return {?}
     */
    getTitle() {
        return this.title && this.title.getInnerText();
    }
}
NestedLinkDirective.decorators = [
    { type: Directive, args: [{
                selector: '[fdNestedLink], [fd-nested-list-link]',
                host: {
                    'tabindex': '0',
                }
            },] }
];
/** @nocollapse */
NestedLinkDirective.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef },
    { type: NestedListStateService },
    { type: ChangeDetectorRef }
];
NestedLinkDirective.propDecorators = {
    fdNestedListItemClass: [{ type: HostBinding, args: ['class.fd-nested-list__link',] }],
    title: [{ type: ContentChild, args: [NestedListTitleDirective, { static: false },] }],
    keyboardTriggered: [{ type: Output }],
    clicked: [{ type: Output }],
    selected: [{ type: Input }],
    onClickCallback: [{ type: Input }],
    controlSelected: [{ type: HostBinding, args: ['class.is-selected',] }],
    expanded: [{ type: HostBinding, args: ['class.is-expanded',] }, { type: HostBinding, args: ['attr.aria-expanded',] }],
    hasChildren: [{ type: HostBinding, args: ['class.has-child',] }, { type: HostBinding, args: ['attr.aria-haspopup',] }]
};
if (false) {
    /**
     * @hidden
     * @type {?}
     */
    NestedLinkDirective.prototype.fdNestedListItemClass;
    /**
     * @hidden
     *  Reference to title element, it is used, to get title for condensed mode.
     * @type {?}
     */
    NestedLinkDirective.prototype.title;
    /**
     * Event that is thrown, when any keyboard event is dispatched on this element
     * @type {?}
     */
    NestedLinkDirective.prototype.keyboardTriggered;
    /**
     * Event that is thrown, when this element is clicked
     * @type {?}
     */
    NestedLinkDirective.prototype.clicked;
    /** @type {?} */
    NestedLinkDirective.prototype._selected;
    /**
     * Function that is called on click event dispatch on this element.
     * @type {?}
     */
    NestedLinkDirective.prototype.onClickCallback;
    /**
     *
     * @type {?}
     */
    NestedLinkDirective.prototype.controlSelected;
    /**
     * @hidden
     * Attribute controlled by the parent `NestedItemDirective`
     * @type {?}
     */
    NestedLinkDirective.prototype.expanded;
    /**
     * @hidden
     * Attribute controlled by the parent `NestedItemDirective`
     * @type {?}
     */
    NestedLinkDirective.prototype.hasChildren;
    /**
     * @type {?}
     * @private
     */
    NestedLinkDirective.prototype.renderer;
    /**
     * @type {?}
     * @private
     */
    NestedLinkDirective.prototype.elementRef;
    /**
     * @type {?}
     * @private
     */
    NestedLinkDirective.prototype.nestedListStateService;
    /** @type {?} */
    NestedLinkDirective.prototype.changeDetRef;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmVzdGVkLWxpbmsuZGlyZWN0aXZlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQGZ1bmRhbWVudGFsLW5neC9jb3JlLyIsInNvdXJjZXMiOlsibGliL25lc3RlZC1saXN0L25lc3RlZC1saW5rL25lc3RlZC1saW5rLmRpcmVjdGl2ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLE9BQU8sRUFDSCxpQkFBaUIsRUFDakIsWUFBWSxFQUNaLFNBQVMsRUFDVCxVQUFVLEVBQ1YsWUFBWSxFQUNaLFdBQVcsRUFDWCxLQUFLLEVBRUwsTUFBTSxFQUNOLFNBQVMsRUFDWixNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUUsd0JBQXdCLEVBQUUsTUFBTSwyQkFBMkIsQ0FBQztBQUNyRSxPQUFPLEVBQUUsc0JBQXNCLEVBQUUsTUFBTSw4QkFBOEIsQ0FBQztBQVF0RSxNQUFNLE9BQU8sbUJBQW1COzs7Ozs7OztJQXNFNUIsWUFDWSxRQUFtQixFQUNuQixVQUFzQixFQUN0QixzQkFBOEMsRUFDL0MsWUFBK0I7UUFIOUIsYUFBUSxHQUFSLFFBQVEsQ0FBVztRQUNuQixlQUFVLEdBQVYsVUFBVSxDQUFZO1FBQ3RCLDJCQUFzQixHQUF0QixzQkFBc0IsQ0FBd0I7UUFDL0MsaUJBQVksR0FBWixZQUFZLENBQW1COzs7O1FBdEUxQywwQkFBcUIsR0FBWSxJQUFJLENBQUM7Ozs7UUFXN0Isc0JBQWlCLEdBQWdDLElBQUksWUFBWSxFQUFpQixDQUFDOzs7O1FBSW5GLFlBQU8sR0FBNkIsSUFBSSxZQUFZLEVBQWMsQ0FBQzs7OztRQXNCNUUsb0JBQWUsR0FBWSxJQUFJLENBQUMsU0FBUyxDQUFDOzs7OztRQVExQyxhQUFRLEdBQVksS0FBSyxDQUFDOzs7OztRQVExQixnQkFBVyxHQUFZLEtBQUssQ0FBQztJQWtCMUIsQ0FBQzs7Ozs7O0lBckRKLElBQ0ksUUFBUSxDQUFDLFFBQWlCO1FBQzFCLElBQUksSUFBSSxDQUFDLFNBQVMsS0FBSyxRQUFRLEVBQUU7WUFDN0IsSUFBSSxDQUFDLFNBQVMsR0FBRyxRQUFRLENBQUM7WUFDMUIsSUFBSSxDQUFDLGVBQWUsR0FBRyxRQUFRLENBQUM7WUFDaEMsSUFBSSxDQUFDLHNCQUFzQixDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsQ0FBQztTQUMvQztJQUNMLENBQUM7Ozs7SUFDRCxJQUFJLFFBQVE7UUFDUixPQUFPLElBQUksQ0FBQyxTQUFTLENBQUM7SUFDMUIsQ0FBQzs7Ozs7SUE0QkQsS0FBSztRQUNELElBQUksQ0FBQyxVQUFVLENBQUMsYUFBYSxDQUFDLEtBQUssRUFBRSxDQUFDO0lBQzFDLENBQUM7Ozs7O0lBR0QsS0FBSztRQUNELElBQUksQ0FBQyxVQUFVLENBQUMsYUFBYSxDQUFDLEtBQUssRUFBRSxDQUFDO0lBQzFDLENBQUM7Ozs7O0lBV0QsUUFBUTtRQUNKLHlDQUF5QztRQUV6QyxlQUFlO1FBQ2YsSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxhQUFhLEVBQUUsU0FBUzs7OztRQUFFLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FDckUsSUFBSSxDQUFDLGlCQUFpQixDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsRUFDckMsQ0FBQztRQUVGLGtCQUFrQjtRQUNsQixJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLGFBQWEsRUFBRSxPQUFPOzs7O1FBQUUsQ0FBQyxLQUFLLEVBQUUsRUFBRTtZQUNuRSxJQUFJLElBQUksQ0FBQyxlQUFlLEVBQUU7Z0JBQ3RCLElBQUksQ0FBQyxlQUFlLEVBQUUsQ0FBQzthQUMxQjtZQUNELElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQzdCLENBQUMsRUFBQyxDQUFDO0lBQ1AsQ0FBQzs7Ozs7SUFHRCxRQUFRO1FBQ0osT0FBTyxJQUFJLENBQUMsS0FBSyxJQUFJLElBQUksQ0FBQyxLQUFLLENBQUMsWUFBWSxFQUFFLENBQUM7SUFDbkQsQ0FBQzs7O1lBeEdKLFNBQVMsU0FBQztnQkFDUCxRQUFRLEVBQUUsdUNBQXVDO2dCQUNqRCxJQUFJLEVBQUU7b0JBQ0YsVUFBVSxFQUFFLEdBQUc7aUJBQ2xCO2FBQ0o7Ozs7WUFWRyxTQUFTO1lBTlQsVUFBVTtZQVNMLHNCQUFzQjtZQVozQixpQkFBaUI7OztvQ0F1QmhCLFdBQVcsU0FBQyw0QkFBNEI7b0JBT3hDLFlBQVksU0FBQyx3QkFBd0IsRUFBRSxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUU7Z0NBSXhELE1BQU07c0JBSU4sTUFBTTt1QkFJTixLQUFLOzhCQWNMLEtBQUs7OEJBSUwsV0FBVyxTQUFDLG1CQUFtQjt1QkFPL0IsV0FBVyxTQUFDLG1CQUFtQixjQUMvQixXQUFXLFNBQUMsb0JBQW9COzBCQU9oQyxXQUFXLFNBQUMsaUJBQWlCLGNBQzdCLFdBQVcsU0FBQyxvQkFBb0I7Ozs7Ozs7SUFyRGpDLG9EQUNzQzs7Ozs7O0lBTXRDLG9DQUNnQzs7Ozs7SUFHaEMsZ0RBQzRGOzs7OztJQUc1RixzQ0FDNEU7O0lBYzVFLHdDQUFtQjs7Ozs7SUFHbkIsOENBQzBCOzs7OztJQUcxQiw4Q0FDMEM7Ozs7OztJQU0xQyx1Q0FFMEI7Ozs7OztJQU0xQiwwQ0FFNkI7Ozs7O0lBY3pCLHVDQUEyQjs7Ozs7SUFDM0IseUNBQThCOzs7OztJQUM5QixxREFBc0Q7O0lBQ3RELDJDQUFzQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gICAgQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgQ29udGVudENoaWxkLFxuICAgIERpcmVjdGl2ZSxcbiAgICBFbGVtZW50UmVmLFxuICAgIEV2ZW50RW1pdHRlcixcbiAgICBIb3N0QmluZGluZyxcbiAgICBJbnB1dCxcbiAgICBPbkluaXQsXG4gICAgT3V0cHV0LFxuICAgIFJlbmRlcmVyMlxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE5lc3RlZExpc3RUaXRsZURpcmVjdGl2ZSB9IGZyb20gJy4uL25lc3RlZC1saXN0LWRpcmVjdGl2ZXMnO1xuaW1wb3J0IHsgTmVzdGVkTGlzdFN0YXRlU2VydmljZSB9IGZyb20gJy4uL25lc3RlZC1saXN0LXN0YXRlLnNlcnZpY2UnO1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ1tmZE5lc3RlZExpbmtdLCBbZmQtbmVzdGVkLWxpc3QtbGlua10nLFxuICAgIGhvc3Q6IHtcbiAgICAgICAgJ3RhYmluZGV4JzogJzAnLFxuICAgIH1cbn0pXG5leHBvcnQgY2xhc3MgTmVzdGVkTGlua0RpcmVjdGl2ZSBpbXBsZW1lbnRzIE9uSW5pdCB7XG5cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIEBIb3N0QmluZGluZygnY2xhc3MuZmQtbmVzdGVkLWxpc3RfX2xpbmsnKVxuICAgIGZkTmVzdGVkTGlzdEl0ZW1DbGFzczogYm9vbGVhbiA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiAgQGhpZGRlblxuICAgICAqICBSZWZlcmVuY2UgdG8gdGl0bGUgZWxlbWVudCwgaXQgaXMgdXNlZCwgdG8gZ2V0IHRpdGxlIGZvciBjb25kZW5zZWQgbW9kZS5cbiAgICAgKi9cbiAgICBAQ29udGVudENoaWxkKE5lc3RlZExpc3RUaXRsZURpcmVjdGl2ZSwgeyBzdGF0aWM6IGZhbHNlIH0pXG4gICAgdGl0bGU6IE5lc3RlZExpc3RUaXRsZURpcmVjdGl2ZTtcblxuICAgIC8qKiBFdmVudCB0aGF0IGlzIHRocm93biwgd2hlbiBhbnkga2V5Ym9hcmQgZXZlbnQgaXMgZGlzcGF0Y2hlZCBvbiB0aGlzIGVsZW1lbnQgKi9cbiAgICBAT3V0cHV0KClcbiAgICByZWFkb25seSBrZXlib2FyZFRyaWdnZXJlZDogRXZlbnRFbWl0dGVyPEtleWJvYXJkRXZlbnQ+ID0gbmV3IEV2ZW50RW1pdHRlcjxLZXlib2FyZEV2ZW50PigpO1xuXG4gICAgLyoqIEV2ZW50IHRoYXQgaXMgdGhyb3duLCB3aGVuIHRoaXMgZWxlbWVudCBpcyBjbGlja2VkICovXG4gICAgQE91dHB1dCgpXG4gICAgcmVhZG9ubHkgY2xpY2tlZDogRXZlbnRFbWl0dGVyPE1vdXNlRXZlbnQ+ID0gbmV3IEV2ZW50RW1pdHRlcjxNb3VzZUV2ZW50PigpO1xuXG4gICAgLyoqIFdoZXRoZXIgdGhpcyBlbGVtZW50IGlzIHNlbGVjdGVkLCB0aGUgYHNlbGVjdGVkYCBzdGF0ZSBpcyBwcm9wYWdhdGVkIHRvIGFsbCBvZiBwYXJlbnQgZWxlbWVudHMgKi9cbiAgICBASW5wdXQoKVxuICAgIHNldCBzZWxlY3RlZChzZWxlY3RlZDogYm9vbGVhbikge1xuICAgICAgICBpZiAodGhpcy5fc2VsZWN0ZWQgIT09IHNlbGVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9zZWxlY3RlZCA9IHNlbGVjdGVkO1xuICAgICAgICAgICAgdGhpcy5jb250cm9sU2VsZWN0ZWQgPSBzZWxlY3RlZDtcbiAgICAgICAgICAgIHRoaXMubmVzdGVkTGlzdFN0YXRlU2VydmljZS5yZWZyZXNoJC5uZXh0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IHNlbGVjdGVkKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2VsZWN0ZWQ7XG4gICAgfVxuICAgIF9zZWxlY3RlZDogYm9vbGVhbjtcblxuICAgIC8qKiBGdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCBvbiBjbGljayBldmVudCBkaXNwYXRjaCBvbiB0aGlzIGVsZW1lbnQuICovXG4gICAgQElucHV0KClcbiAgICBvbkNsaWNrQ2FsbGJhY2s6IEZ1bmN0aW9uO1xuXG4gICAgLyoqICovXG4gICAgQEhvc3RCaW5kaW5nKCdjbGFzcy5pcy1zZWxlY3RlZCcpXG4gICAgY29udHJvbFNlbGVjdGVkOiBib29sZWFuID0gdGhpcy5fc2VsZWN0ZWQ7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogQXR0cmlidXRlIGNvbnRyb2xsZWQgYnkgdGhlIHBhcmVudCBgTmVzdGVkSXRlbURpcmVjdGl2ZWBcbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLmlzLWV4cGFuZGVkJylcbiAgICBASG9zdEJpbmRpbmcoJ2F0dHIuYXJpYS1leHBhbmRlZCcpXG4gICAgZXhwYW5kZWQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBBdHRyaWJ1dGUgY29udHJvbGxlZCBieSB0aGUgcGFyZW50IGBOZXN0ZWRJdGVtRGlyZWN0aXZlYFxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZygnY2xhc3MuaGFzLWNoaWxkJylcbiAgICBASG9zdEJpbmRpbmcoJ2F0dHIuYXJpYS1oYXNwb3B1cCcpXG4gICAgaGFzQ2hpbGRyZW46IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIC8qKiBTZXQgZm9jdXMgb24gdGhlIGVsZW1lbnQuICovXG4gICAgZm9jdXMoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmZvY3VzKCk7XG4gICAgfVxuXG4gICAgLyoqIERpc3BhdGNoZXMgdGhlIGNsaWNrIGV2ZW50IG9uIHRoZSBlbGVtZW50ICovXG4gICAgY2xpY2soKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmNsaWNrKCk7XG4gICAgfVxuXG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHJpdmF0ZSByZW5kZXJlcjogUmVuZGVyZXIyLFxuICAgICAgICBwcml2YXRlIGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYsXG4gICAgICAgIHByaXZhdGUgbmVzdGVkTGlzdFN0YXRlU2VydmljZTogTmVzdGVkTGlzdFN0YXRlU2VydmljZSxcbiAgICAgICAgcHVibGljIGNoYW5nZURldFJlZjogQ2hhbmdlRGV0ZWN0b3JSZWZcbiAgICApIHt9XG5cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIG5nT25Jbml0KCk6IHZvaWQge1xuICAgICAgICAvKiogQWRkIGV2ZW50IGxpc3RlbmVycyBvbiB0aGUgZWxlbWVudCAqL1xuXG4gICAgICAgIC8qKiBLZXlib2FyZCAqL1xuICAgICAgICB0aGlzLnJlbmRlcmVyLmxpc3Rlbih0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgJ2tleWRvd24nLCAoZXZlbnQpID0+XG4gICAgICAgICAgICB0aGlzLmtleWJvYXJkVHJpZ2dlcmVkLmVtaXQoZXZlbnQpXG4gICAgICAgICk7XG5cbiAgICAgICAgLyoqIE1vdXNlIENsaWNrICovXG4gICAgICAgIHRoaXMucmVuZGVyZXIubGlzdGVuKHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCAnY2xpY2snLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLm9uQ2xpY2tDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHRoaXMub25DbGlja0NhbGxiYWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNsaWNrZWQuZW1pdChldmVudCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKiBSZXR1cm5zIHRoZSB0aXRsZSB2YWx1ZSBvZiB0aGUgdGl0bGUgZGlyZWN0aXZlICovXG4gICAgZ2V0VGl0bGUoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGl0bGUgJiYgdGhpcy50aXRsZS5nZXRJbm5lclRleHQoKTtcbiAgICB9XG5cbn1cbiJdfQ==