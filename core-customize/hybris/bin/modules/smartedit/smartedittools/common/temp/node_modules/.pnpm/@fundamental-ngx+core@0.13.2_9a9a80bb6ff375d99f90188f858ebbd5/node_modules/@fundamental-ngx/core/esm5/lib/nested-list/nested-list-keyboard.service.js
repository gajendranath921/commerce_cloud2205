/**
 * @fileoverview added by tsickle
 * Generated from: lib/nested-list/nested-list-keyboard.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { Subject } from 'rxjs';
import { MenuKeyboardService } from '../menu/menu-keyboard.service';
import { Inject, Injectable } from '@angular/core';
import { takeUntil } from 'rxjs/operators';
/**
 * Nested list keyboard service, which uses MenuKeyboardService, to deal with ArrowUp, ArrowDown, Space, Enter.
 * Also has own handling of ArrowLeft and ArrowRight, to open/close the menu if it has any children.
 */
var NestedListKeyboardService = /** @class */ (function () {
    function NestedListKeyboardService(keyboardService) {
        this.keyboardService = keyboardService;
        /**
         * Event, that is thrown always, when the open/close i being called on item components.
         * Also triggers changing of elements, to remove closed/hidden elements
         */
        this.refresh$ = new Subject();
    }
    /** Recursive function to get all of the NestedItem elements in correct order. */
    /**
     * Recursive function to get all of the NestedItem elements in correct order.
     * @private
     * @param {?} item
     * @return {?}
     */
    NestedListKeyboardService.prototype.getItems = /**
     * Recursive function to get all of the NestedItem elements in correct order.
     * @private
     * @param {?} item
     * @return {?}
     */
    function (item) {
        var _this = this;
        /** @type {?} */
        var childrenItems = item.expanded ? item.allChildrenItems : [];
        return childrenItems.reduce((/**
         * @param {?} actualArray
         * @param {?} nextItem
         * @return {?}
         */
        function (actualArray, nextItem) {
            return tslib_1.__spread(actualArray, _this.getItems(nextItem));
        }), [item]);
    };
    /**
     * Function called after refresh$ event is triggered.
     * Refresh the list of NestedItems, that the keyboard support should be provided for
     */
    /**
     * Function called after refresh$ event is triggered.
     * Refresh the list of NestedItems, that the keyboard support should be provided for
     * @param {?} lists
     * @return {?}
     */
    NestedListKeyboardService.prototype.refreshItems = /**
     * Function called after refresh$ event is triggered.
     * Refresh the list of NestedItems, that the keyboard support should be provided for
     * @param {?} lists
     * @return {?}
     */
    function (lists) {
        var _this = this;
        /** @type {?} */
        var items = [];
        /** Gathering all of the items */
        lists.forEach((/**
         * @param {?} list
         * @return {?}
         */
        function (list) { return items.push.apply(items, tslib_1.__spread(_this.getAllListItems(list))); }));
        /** Putting the keyboard support function to each of the items */
        items.forEach((/**
         * @param {?} item
         * @param {?} index
         * @return {?}
         */
        function (item, index) {
            item.keyboardTriggered
                .pipe(takeUntil(_this.refresh$))
                .subscribe((/**
             * @param {?} keyboardEvent
             * @return {?}
             */
            function (keyboardEvent) {
                return _this.handleKeyDown(keyboardEvent, index, items);
            }));
        }));
    };
    /** Method that calls the recursive function, getItems() and gathers all of the items in the NestedList */
    /**
     * Method that calls the recursive function, getItems() and gathers all of the items in the NestedList
     * @private
     * @param {?} list
     * @return {?}
     */
    NestedListKeyboardService.prototype.getAllListItems = /**
     * Method that calls the recursive function, getItems() and gathers all of the items in the NestedList
     * @private
     * @param {?} list
     * @return {?}
     */
    function (list) {
        var _this = this;
        /** @type {?} */
        var _items = [];
        if (list && list.nestedItems) {
            list.nestedItems.toArray().forEach((/**
             * @param {?} item
             * @return {?}
             */
            function (item) {
                _items.push.apply(_items, tslib_1.__spread(_this.getItems(item)));
            }));
        }
        return _items;
    };
    /**
     * Keyboard handle function. Uses keyboard support service from MenuComponent, to deal with ArrowUp, ArrowDown, Space, Enter.
     * For ArrowRight, if item is not expanded and has children (list or popup), the open function is triggered.
     * Otherwise it follows ArrowDown functionality.
     * For ArrowLeft, if item is expanded and has children (list or popup), the close function is triggered.
     * Otherwise it follows ArrowUp functionality
     */
    /**
     * Keyboard handle function. Uses keyboard support service from MenuComponent, to deal with ArrowUp, ArrowDown, Space, Enter.
     * For ArrowRight, if item is not expanded and has children (list or popup), the open function is triggered.
     * Otherwise it follows ArrowDown functionality.
     * For ArrowLeft, if item is expanded and has children (list or popup), the close function is triggered.
     * Otherwise it follows ArrowUp functionality
     * @private
     * @param {?} keyboardEvent
     * @param {?} index
     * @param {?} items
     * @return {?}
     */
    NestedListKeyboardService.prototype.handleKeyDown = /**
     * Keyboard handle function. Uses keyboard support service from MenuComponent, to deal with ArrowUp, ArrowDown, Space, Enter.
     * For ArrowRight, if item is not expanded and has children (list or popup), the open function is triggered.
     * Otherwise it follows ArrowDown functionality.
     * For ArrowLeft, if item is expanded and has children (list or popup), the close function is triggered.
     * Otherwise it follows ArrowUp functionality
     * @private
     * @param {?} keyboardEvent
     * @param {?} index
     * @param {?} items
     * @return {?}
     */
    function (keyboardEvent, index, items) {
        /** @type {?} */
        var item = items[index];
        switch (keyboardEvent.key) {
            case ('ArrowRight'): {
                if (!item.expanded && item.hasChildren) {
                    item.triggerOpen();
                }
                else {
                    if (items.length > index + 1) {
                        items[index + 1].focus();
                    }
                    else {
                        items[0].focus();
                    }
                    keyboardEvent.preventDefault();
                }
                break;
            }
            case ('ArrowLeft'): {
                if (item.expanded && item.hasChildren) {
                    item.triggerClose();
                }
                else {
                    if (index > 0) {
                        items[index - 1].focus();
                    }
                    else {
                        items[items.length - 1].focus();
                    }
                    keyboardEvent.preventDefault();
                }
                break;
            }
            default: {
                this.keyboardService.keyDownHandler(keyboardEvent, index, items);
            }
        }
    };
    NestedListKeyboardService.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    NestedListKeyboardService.ctorParameters = function () { return [
        { type: MenuKeyboardService, decorators: [{ type: Inject, args: [MenuKeyboardService,] }] }
    ]; };
    return NestedListKeyboardService;
}());
export { NestedListKeyboardService };
if (false) {
    /**
     * Event, that is thrown always, when the open/close i being called on item components.
     * Also triggers changing of elements, to remove closed/hidden elements
     * @type {?}
     */
    NestedListKeyboardService.prototype.refresh$;
    /**
     * @type {?}
     * @private
     */
    NestedListKeyboardService.prototype.keyboardService;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmVzdGVkLWxpc3Qta2V5Ym9hcmQuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BmdW5kYW1lbnRhbC1uZ3gvY29yZS8iLCJzb3VyY2VzIjpbImxpYi9uZXN0ZWQtbGlzdC9uZXN0ZWQtbGlzdC1rZXlib2FyZC5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDL0IsT0FBTyxFQUFFLG1CQUFtQixFQUFFLE1BQU0sK0JBQStCLENBQUM7QUFDcEUsT0FBTyxFQUFFLE1BQU0sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDbkQsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLGdCQUFnQixDQUFDOzs7OztBQVEzQztJQUdJLG1DQUN5QyxlQUFvQztRQUFwQyxvQkFBZSxHQUFmLGVBQWUsQ0FBcUI7Ozs7O1FBT3BFLGFBQVEsR0FBa0IsSUFBSSxPQUFPLEVBQVEsQ0FBQztJQU5wRCxDQUFDO0lBUUosaUZBQWlGOzs7Ozs7O0lBQ3pFLDRDQUFROzs7Ozs7SUFBaEIsVUFBaUIsSUFBeUI7UUFBMUMsaUJBTUM7O1lBTFMsYUFBYSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDLENBQUMsRUFBRTtRQUNoRSxPQUFPLGFBQWEsQ0FBQyxNQUFNOzs7OztRQUN2QixVQUFDLFdBQWtDLEVBQUUsUUFBNkI7WUFDOUQsd0JBQUksV0FBVyxFQUFLLEtBQUksQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDO1FBQTNDLENBQTRDLEdBQUUsQ0FBQyxJQUFJLENBQUMsQ0FDM0QsQ0FBQztJQUNOLENBQUM7SUFFRDs7O09BR0c7Ozs7Ozs7SUFDSSxnREFBWTs7Ozs7O0lBQW5CLFVBQW9CLEtBQTRCO1FBQWhELGlCQWVDOztZQWJTLEtBQUssR0FBMEIsRUFBRTtRQUV2QyxpQ0FBaUM7UUFDakMsS0FBSyxDQUFD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O1NBdEdZLHlCQUF5Qjs7Ozs7OztJQVVsQyw2Q0FBdUQ7Ozs7O0lBUG5ELG9EQUF5RSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IE1lbnVLZXlib2FyZFNlcnZpY2UgfSBmcm9tICcuLi9tZW51L21lbnUta2V5Ym9hcmQuc2VydmljZSc7XG5pbXBvcnQgeyBJbmplY3QsIEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IHRha2VVbnRpbCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IE5lc3RlZEl0ZW1JbnRlcmZhY2UgfSBmcm9tICcuL25lc3RlZC1pdGVtL25lc3RlZC1pdGVtLmludGVyZmFjZSc7XG5pbXBvcnQgeyBOZXN0ZWRMaXN0SW50ZXJmYWNlIH0gZnJvbSAnLi9uZXN0ZWQtbGlzdC9uZXN0ZWQtbGlzdC5pbnRlcmZhY2UnO1xuXG4vKipcbiAqIE5lc3RlZCBsaXN0IGtleWJvYXJkIHNlcnZpY2UsIHdoaWNoIHVzZXMgTWVudUtleWJvYXJkU2VydmljZSwgdG8gZGVhbCB3aXRoIEFycm93VXAsIEFycm93RG93biwgU3BhY2UsIEVudGVyLlxuICogQWxzbyBoYXMgb3duIGhhbmRsaW5nIG9mIEFycm93TGVmdCBhbmQgQXJyb3dSaWdodCwgdG8gb3Blbi9jbG9zZSB0aGUgbWVudSBpZiBpdCBoYXMgYW55IGNoaWxkcmVuLlxuICovXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgTmVzdGVkTGlzdEtleWJvYXJkU2VydmljZSB7XG5cbiAgICBjb25zdHJ1Y3RvciAoXG4gICAgICAgIEBJbmplY3QoTWVudUtleWJvYXJkU2VydmljZSkgcHJpdmF0ZSBrZXlib2FyZFNlcnZpY2U6IE1lbnVLZXlib2FyZFNlcnZpY2UsXG4gICAgKSB7fVxuXG4gICAgLyoqXG4gICAgICogRXZlbnQsIHRoYXQgaXMgdGhyb3duIGFsd2F5cywgd2hlbiB0aGUgb3Blbi9jbG9zZSBpIGJlaW5nIGNhbGxlZCBvbiBpdGVtIGNvbXBvbmVudHMuXG4gICAgICogQWxzbyB0cmlnZ2VycyBjaGFuZ2luZyBvZiBlbGVtZW50cywgdG8gcmVtb3ZlIGNsb3NlZC9oaWRkZW4gZWxlbWVudHNcbiAgICAgKi9cbiAgICByZWFkb25seSByZWZyZXNoJDogU3ViamVjdDx2b2lkPiA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG5cbiAgICAvKiogUmVjdXJzaXZlIGZ1bmN0aW9uIHRvIGdldCBhbGwgb2YgdGhlIE5lc3RlZEl0ZW0gZWxlbWVudHMgaW4gY29ycmVjdCBvcmRlci4gKi9cbiAgICBwcml2YXRlIGdldEl0ZW1zKGl0ZW06IE5lc3RlZEl0ZW1JbnRlcmZhY2UpOiBOZXN0ZWRJdGVtSW50ZXJmYWNlW10ge1xuICAgICAgICBjb25zdCBjaGlsZHJlbkl0ZW1zID0gaXRlbS5leHBhbmRlZCA/IGl0ZW0uYWxsQ2hpbGRyZW5JdGVtcyA6IFtdO1xuICAgICAgICByZXR1cm4gY2hpbGRyZW5JdGVtcy5yZWR1Y2UoXG4gICAgICAgICAgICAoYWN0dWFsQXJyYXk6IE5lc3RlZEl0ZW1JbnRlcmZhY2VbXSwgbmV4dEl0ZW06IE5lc3RlZEl0ZW1JbnRlcmZhY2UpID0+XG4gICAgICAgICAgICAgICAgWy4uLmFjdHVhbEFycmF5LCAuLi50aGlzLmdldEl0ZW1zKG5leHRJdGVtKV0sIFtpdGVtXVxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIGNhbGxlZCBhZnRlciByZWZyZXNoJCBldmVudCBpcyB0cmlnZ2VyZWQuXG4gICAgICogUmVmcmVzaCB0aGUgbGlzdCBvZiBOZXN0ZWRJdGVtcywgdGhhdCB0aGUga2V5Ym9hcmQgc3VwcG9ydCBzaG91bGQgYmUgcHJvdmlkZWQgZm9yXG4gICAgICovXG4gICAgcHVibGljIHJlZnJlc2hJdGVtcyhsaXN0czogTmVzdGVkTGlzdEludGVyZmFjZVtdKTogdm9pZCB7XG5cbiAgICAgICAgY29uc3QgaXRlbXM6IE5lc3RlZEl0ZW1JbnRlcmZhY2VbXSA9IFtdO1xuXG4gICAgICAgIC8qKiBHYXRoZXJpbmcgYWxsIG9mIHRoZSBpdGVtcyAqL1xuICAgICAgICBsaXN0cy5mb3JFYWNoKGxpc3QgPT4gaXRlbXMucHVzaCguLi50aGlzLmdldEFsbExpc3RJdGVtcyhsaXN0KSkpO1xuXG4gICAgICAgIC8qKiBQdXR0aW5nIHRoZSBrZXlib2FyZCBzdXBwb3J0IGZ1bmN0aW9uIHRvIGVhY2ggb2YgdGhlIGl0ZW1zICovXG4gICAgICAgIGl0ZW1zLmZvckVhY2goKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBpdGVtLmtleWJvYXJkVHJpZ2dlcmVkXG4gICAgICAgICAgICAgICAgLnBpcGUodGFrZVVudGlsKHRoaXMucmVmcmVzaCQpKVxuICAgICAgICAgICAgICAgIC5zdWJzY3JpYmUoKGtleWJvYXJkRXZlbnQ6IEtleWJvYXJkRXZlbnQpID0+XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVLZXlEb3duKGtleWJvYXJkRXZlbnQsIGluZGV4LCBpdGVtcylcbiAgICAgICAgICAgIClcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqIE1ldGhvZCB0aGF0IGNhbGxzIHRoZSByZWN1cnNpdmUgZnVuY3Rpb24sIGdldEl0ZW1zKCkgYW5kIGdhdGhlcnMgYWxsIG9mIHRoZSBpdGVtcyBpbiB0aGUgTmVzdGVkTGlzdCAqL1xuICAgIHByaXZhdGUgZ2V0QWxsTGlzdEl0ZW1zKGxpc3Q6IE5lc3RlZExpc3RJbnRlcmZhY2UpOiBOZXN0ZWRJdGVtSW50ZXJmYWNlW10ge1xuXG4gICAgICAgIGNvbnN0IF9pdGVtczogTmVzdGVkSXRlbUludGVyZmFjZVtdID0gW107XG4gICAgICAgIGlmIChsaXN0ICYmIGxpc3QubmVzdGVkSXRlbXMpIHtcbiAgICAgICAgICAgIGxpc3QubmVzdGVkSXRlbXMudG9BcnJheSgpLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICAgICAgX2l0ZW1zLnB1c2goLi4udGhpcy5nZXRJdGVtcyhpdGVtKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBfaXRlbXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogS2V5Ym9hcmQgaGFuZGxlIGZ1bmN0aW9uLiBVc2VzIGtleWJvYXJkIHN1cHBvcnQgc2VydmljZSBmcm9tIE1lbnVDb21wb25lbnQsIHRvIGRlYWwgd2l0aCBBcnJvd1VwLCBBcnJvd0Rvd24sIFNwYWNlLCBFbnRlci5cbiAgICAgKiBGb3IgQXJyb3dSaWdodCwgaWYgaXRlbSBpcyBub3QgZXhwYW5kZWQgYW5kIGhhcyBjaGlsZHJlbiAobGlzdCBvciBwb3B1cCksIHRoZSBvcGVuIGZ1bmN0aW9uIGlzIHRyaWdnZXJlZC5cbiAgICAgKiBPdGhlcndpc2UgaXQgZm9sbG93cyBBcnJvd0Rvd24gZnVuY3Rpb25hbGl0eS5cbiAgICAgKiBGb3IgQXJyb3dMZWZ0LCBpZiBpdGVtIGlzIGV4cGFuZGVkIGFuZCBoYXMgY2hpbGRyZW4gKGxpc3Qgb3IgcG9wdXApLCB0aGUgY2xvc2UgZnVuY3Rpb24gaXMgdHJpZ2dlcmVkLlxuICAgICAqIE90aGVyd2lzZSBpdCBmb2xsb3dzIEFycm93VXAgZnVuY3Rpb25hbGl0eVxuICAgICAqL1xuICAgIHByaXZhdGUgaGFuZGxlS2V5RG93bihrZXlib2FyZEV2ZW50OiBLZXlib2FyZEV2ZW50LCBpbmRleDogbnVtYmVyLCBpdGVtczogTmVzdGVkSXRlbUludGVyZmFjZVtdKTogdm9pZCB7XG5cbiAgICAgICAgY29uc3QgaXRlbTogTmVzdGVkSXRlbUludGVyZmFjZSA9IGl0ZW1zW2luZGV4XTtcblxuICAgICAgICBzd2l0Y2ggKGtleWJvYXJkRXZlbnQua2V5KSB7XG4gICAgICAgICAgICBjYXNlICgnQXJyb3dSaWdodCcpOiB7XG4gICAgICAgICAgICAgICAgaWYgKCFpdGVtLmV4cGFuZGVkICYmIGl0ZW0uaGFzQ2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS50cmlnZ2VyT3BlbigpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtcy5sZW5ndGggPiBpbmRleCArIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zW2luZGV4ICsgMV0uZm9jdXMoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zWzBdLmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAga2V5Ym9hcmRFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2FzZSAoJ0Fycm93TGVmdCcpOiB7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0uZXhwYW5kZWQgJiYgaXRlbS5oYXNDaGlsZHJlbikge1xuICAgICAgICAgICAgICAgICAgICBpdGVtLnRyaWdnZXJDbG9zZSgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zW2luZGV4IC0gMV0uZm9jdXMoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zW2l0ZW1zLmxlbmd0aCAtIDFdLmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAga2V5Ym9hcmRFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgIHRoaXMua2V5Ym9hcmRTZXJ2aWNlLmtleURvd25IYW5kbGVyKGtleWJvYXJkRXZlbnQsIGluZGV4LCBpdGVtcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH1cblxufVxuIl19