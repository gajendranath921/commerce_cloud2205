/**
 * @fileoverview added by tsickle
 * Generated from: lib/datetime-picker/format/datetime-parser.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Injectable } from '@angular/core';
import { FdDatetime } from '../models/fd-datetime';
import { FdDate } from '../../calendar/models/fd-date';
import * as i0 from "@angular/core";
/**
 * @return {?}
 */
export function DATE_TIME_FORMAT_FACTORY() {
    return new DateTimeFormatParserDefault();
}
/**
 * Abstract class which defines the behaviour of the datetime format and parser.
 * @abstract
 */
export class DateTimeFormatParser {
}
DateTimeFormatParser.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
                useFactory: DATE_TIME_FORMAT_FACTORY
            },] }
];
/** @nocollapse */ DateTimeFormatParser.ngInjectableDef = i0.ɵɵdefineInjectable({ factory: DATE_TIME_FORMAT_FACTORY, token: DateTimeFormatParser, providedIn: "root" });
if (false) {
    /**
     * Should take in a string value and return a FdDatetime model object.
     * @abstract
     * @param {?} value String to concert to a FdDatetime model object.
     * @return {?}
     */
    DateTimeFormatParser.prototype.parse = function (value) { };
    /**
     * Should take in a FdDatetime model object and return a string representation.
     * @abstract
     * @param {?} date FdDatetime object to concert to a date string.
     * Return null, to keep default angular DatePipe as a formatter.
     * @return {?}
     */
    DateTimeFormatParser.prototype.format = function (date) { };
}
/**
 * Default implementation of the DateFormatParser service.
 */
export class DateTimeFormatParserDefault extends DateTimeFormatParser {
    /**
     * Takes in a string representation of a date and returns a FdDatetime object.
     * @param {?} value String to convert to a FdDatetime model object.
     * @return {?}
     */
    parse(value) {
        if (!value) {
            return FdDatetime.getToday();
        }
        else {
            /** @type {?} */
            const date = new Date(value);
            return new FdDatetime(new FdDate(date.getFullYear(), date.getMonth() + 1, date.getDate()), {
                hour: date.getHours(),
                minute: date.getMinutes(),
                second: date.getSeconds()
            });
        }
    }
    /**
     * Takes in a FdDatetime object and returns the string representation.
     * @param {?} date FdDatetime model object to convert to a string.
     * Return null, to keep default angular DatePipe as a formatter.
     * @return {?}
     */
    format(date) {
        return null;
    }
}
DateTimeFormatParserDefault.decorators = [
    { type: Injectable }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0ZXRpbWUtcGFyc2VyLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQGZ1bmRhbWVudGFsLW5neC9jb3JlLyIsInNvdXJjZXMiOlsibGliL2RhdGV0aW1lLXBpY2tlci9mb3JtYXQvZGF0ZXRpbWUtcGFyc2VyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUMzQyxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFDbkQsT0FBTyxFQUFFLE1BQU0sRUFBRSxNQUFNLCtCQUErQixDQUFDOzs7OztBQUd2RCxNQUFNLFVBQVUsd0JBQXdCO0lBQ3BDLE9BQU8sSUFBSSwyQkFBMkIsRUFBRSxDQUFDO0FBQzdDLENBQUM7Ozs7O0FBU0QsTUFBTSxPQUFnQixvQkFBb0I7OztZQUp6QyxVQUFVLFNBQUM7Z0JBQ1IsVUFBVSxFQUFFLE1BQU07Z0JBQ2xCLFVBQVUsRUFBRSx3QkFBd0I7YUFDdkM7Ozs7Ozs7Ozs7SUFPRyw0REFBMEM7Ozs7Ozs7O0lBTzFDLDREQUEwQzs7Ozs7QUFPOUMsTUFBTSxPQUFPLDJCQUE0QixTQUFRLG9CQUFvQjs7Ozs7O0lBTTFELEtBQUssQ0FBQyxLQUFhO1FBQ3RCLElBQUksQ0FBQyxLQUFLLEVBQUU7WUFDUixPQUFPLFVBQVUsQ0FBQyxRQUFRLEVBQUUsQ0FBQztTQUNoQzthQUFNOztrQkFDRyxJQUFJLEdBQVMsSUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDO1lBQ2xDLE9BQU8sSUFBSSxVQUFVLENBQ2pCLElBQUksTUFBTSxDQUFDLElBQUksQ0FBQyxXQUFXLEVBQUUsRUFBRSxJQUFJLENBQUMsUUFBUSxFQUFFLEdBQUcsQ0FBQyxFQUFFLElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQyxFQUNuRTtnQkFDSSxJQUFJLEVBQUUsSUFBSSxDQUFDLFFBQVEsRUFBRTtnQkFDckIsTUFBTSxFQUFFLElBQUksQ0FBQyxVQUFVLEVBQUU7Z0JBQ3pCLE1BQU0sRUFBRSxJQUFJLENBQUMsVUFBVSxFQUFFO2FBQzVCLENBQ0osQ0FBQztTQUNMO0lBQ0wsQ0FBQzs7Ozs7OztJQU9NLE1BQU0sQ0FBQyxJQUFnQjtRQUMxQixPQUFPLElBQUksQ0FBQztJQUNoQixDQUFDOzs7WUE5QkosVUFBVSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEZkRGF0ZXRpbWUgfSBmcm9tICcuLi9tb2RlbHMvZmQtZGF0ZXRpbWUnO1xuaW1wb3J0IHsgRmREYXRlIH0gZnJvbSAnLi4vLi4vY2FsZW5kYXIvbW9kZWxzL2ZkLWRhdGUnO1xuaW1wb3J0IHsgRGF0ZVBpcGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuXG5leHBvcnQgZnVuY3Rpb24gREFURV9USU1FX0ZPUk1BVF9GQUNUT1JZKCkge1xuICAgIHJldHVybiBuZXcgRGF0ZVRpbWVGb3JtYXRQYXJzZXJEZWZhdWx0KCk7XG59XG5cbi8qKlxuICogQWJzdHJhY3QgY2xhc3Mgd2hpY2ggZGVmaW5lcyB0aGUgYmVoYXZpb3VyIG9mIHRoZSBkYXRldGltZSBmb3JtYXQgYW5kIHBhcnNlci5cbiAqL1xuQEluamVjdGFibGUoe1xuICAgIHByb3ZpZGVkSW46ICdyb290JyxcbiAgICB1c2VGYWN0b3J5OiBEQVRFX1RJTUVfRk9STUFUX0ZBQ1RPUllcbn0pXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgRGF0ZVRpbWVGb3JtYXRQYXJzZXIge1xuXG4gICAgLyoqXG4gICAgICogU2hvdWxkIHRha2UgaW4gYSBzdHJpbmcgdmFsdWUgYW5kIHJldHVybiBhIEZkRGF0ZXRpbWUgbW9kZWwgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB2YWx1ZSBTdHJpbmcgdG8gY29uY2VydCB0byBhIEZkRGF0ZXRpbWUgbW9kZWwgb2JqZWN0LlxuICAgICAqL1xuICAgIGFic3RyYWN0IHBhcnNlKHZhbHVlOiBzdHJpbmcpOiBGZERhdGV0aW1lO1xuXG4gICAgLyoqXG4gICAgICogU2hvdWxkIHRha2UgaW4gYSBGZERhdGV0aW1lIG1vZGVsIG9iamVjdCBhbmQgcmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uLlxuICAgICAqIEBwYXJhbSBkYXRlIEZkRGF0ZXRpbWUgb2JqZWN0IHRvIGNvbmNlcnQgdG8gYSBkYXRlIHN0cmluZy5cbiAgICAgKiBSZXR1cm4gbnVsbCwgdG8ga2VlcCBkZWZhdWx0IGFuZ3VsYXIgRGF0ZVBpcGUgYXMgYSBmb3JtYXR0ZXIuXG4gICAgICovXG4gICAgYWJzdHJhY3QgZm9ybWF0KGRhdGU6IEZkRGF0ZXRpbWUpOiBzdHJpbmc7XG59XG5cbi8qKlxuICogRGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgRGF0ZUZvcm1hdFBhcnNlciBzZXJ2aWNlLlxuICovXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgRGF0ZVRpbWVGb3JtYXRQYXJzZXJEZWZhdWx0IGV4dGVuZHMgRGF0ZVRpbWVGb3JtYXRQYXJzZXIge1xuXG4gICAgLyoqXG4gICAgICogVGFrZXMgaW4gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBkYXRlIGFuZCByZXR1cm5zIGEgRmREYXRldGltZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHZhbHVlIFN0cmluZyB0byBjb252ZXJ0IHRvIGEgRmREYXRldGltZSBtb2RlbCBvYmplY3QuXG4gICAgICovXG4gICAgcHVibGljIHBhcnNlKHZhbHVlOiBzdHJpbmcpOiBGZERhdGV0aW1lIHtcbiAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIEZkRGF0ZXRpbWUuZ2V0VG9kYXkoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGU6IERhdGUgPSBuZXcgRGF0ZSh2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZkRGF0ZXRpbWUoXG4gICAgICAgICAgICAgICAgbmV3IEZkRGF0ZShkYXRlLmdldEZ1bGxZZWFyKCksIGRhdGUuZ2V0TW9udGgoKSArIDEsIGRhdGUuZ2V0RGF0ZSgpKSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGhvdXI6IGRhdGUuZ2V0SG91cnMoKSxcbiAgICAgICAgICAgICAgICAgICAgbWludXRlOiBkYXRlLmdldE1pbnV0ZXMoKSxcbiAgICAgICAgICAgICAgICAgICAgc2Vjb25kOiBkYXRlLmdldFNlY29uZHMoKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUYWtlcyBpbiBhIEZkRGF0ZXRpbWUgb2JqZWN0IGFuZCByZXR1cm5zIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24uXG4gICAgICogQHBhcmFtIGRhdGUgRmREYXRldGltZSBtb2RlbCBvYmplY3QgdG8gY29udmVydCB0byBhIHN0cmluZy5cbiAgICAgKiBSZXR1cm4gbnVsbCwgdG8ga2VlcCBkZWZhdWx0IGFuZ3VsYXIgRGF0ZVBpcGUgYXMgYSBmb3JtYXR0ZXIuXG4gICAgICovXG4gICAgcHVibGljIGZvcm1hdChkYXRlOiBGZERhdGV0aW1lKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuIl19