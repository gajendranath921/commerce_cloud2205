/**
 * @fileoverview added by tsickle
 * Generated from: lib/date-picker/date-picker.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { ChangeDetectionStrategy, ChangeDetectorRef, Component, EventEmitter, forwardRef, Input, Optional, Output, ViewChild, ViewEncapsulation } from '@angular/core';
import { CalendarComponent } from '../calendar/calendar.component';
import { NG_VALIDATORS, NG_VALUE_ACCESSOR } from '@angular/forms';
import { FdDate } from '../calendar/models/fd-date';
import { CalendarService } from '../calendar/calendar.service';
import { DateFormatParser } from './format/date-parser';
import { DatePipe } from '@angular/common';
/**
 * The datetime picker component is an opinionated composition of the fd-popover and
 * fd-calendar components to accomplish the UI pattern for picking a date.
 *
 * Supports Angular Forms.
 * ```html
 * <fd-date-picker [(ngModel)]="date"></fd-date-picker>
 * ```
 */
export class DatePickerComponent {
    /**
     * @hidden
     * @param {?} dateAdapter
     * @param {?} _changeDetectionRef
     * @param {?} _datePipe
     */
    constructor(dateAdapter, _changeDetectionRef, _datePipe) {
        this.dateAdapter = dateAdapter;
        this._changeDetectionRef = _changeDetectionRef;
        this._datePipe = _datePipe;
        /**
         * @hidden The value of the input
         */
        this.inputFieldDate = null;
        /**
         * @hidden Whether the date input is invalid
         */
        this.isInvalidDateInput = false;
        /**
         * @hidden Whether the date picker is open
         */
        this.isOpen = false;
        /**
         * The type of calendar, 'single' for single date selection or 'range' for a range of dates.
         */
        this.type = 'single';
        /**
         * Date picker input placeholder string
         */
        this.placeholder = 'mm/dd/yyyy';
        /**
         * Date Format displayed on input. See more options: https://angular.io/api/common/DatePipe
         */
        this.format = 'MM/dd/yyyy';
        /**
         * Whether this is the compact input date picker
         */
        this.compact = false;
        /**
         * The currently selected FdDates model start and end in range mode.
         */
        this.selectedRangeDate = { start: null, end: null };
        /**
         * The day of the week the calendar should start on. 1 represents Sunday, 2 is Monday, 3 is Tuesday, and so on.
         */
        this.startingDayOfWeek = 1;
        /**
         * Whether to validate the date picker input.
         */
        this.useValidation = true;
        /**
         * Aria label for the datepicker input.
         */
        this.dateInputLabel = 'Date input';
        /**
         * Aria label for the button to show/hide the calendar.
         */
        this.displayCalendarToggleLabel = 'Display calendar toggle';
        /**
         * Whether a null input is considered valid.
         */
        this.allowNull = true;
        /**
         * Actually shown active view one of 'day' | 'month' | 'year' in calendar component
         */
        this.activeView = 'day';
        /**
         *  The placement of the popover. It can be one of: top, top-start, top-end, bottom,
         *  bottom-start, bottom-end, right, right-start, right-end, left, left-start, left-end.
         */
        this.placement = 'bottom-start';
        /**
         * Whether AddOn Button should be focusable, set to true by default
         */
        this.buttonFocusable = true;
        /**
         * Fired when a new date is selected.
         */
        this.selectedDateChange = new EventEmitter();
        /**
         * Event thrown every time selected first or last date in range mode is changed
         */
        this.selectedRangeDateChange = new EventEmitter();
        /**
         * Event thrown every time calendar active view is changed
         */
        this.activeViewChange = new EventEmitter();
        /**
         * @hidden
         */
        this.onChange = (/**
         * @param {?} selected
         * @return {?}
         */
        (selected) => {
        });
        /**
         * @hidden
         */
        this.onTouched = (/**
         * @return {?}
         */
        () => {
        });
        /**
         * Function used to disable certain dates in the calendar.
         * @param fdDate FdDate
         */
        this.disableFunction = (/**
         * @param {?} fdDate
         * @return {?}
         */
        function (fdDate) {
            return false;
        });
        /**
         * Function used to disable certain dates in the calendar for the range start selection.
         * @param fdDate FdDate
         */
        this.disableRangeStartFunction = (/**
         * @param {?} fdDate
         * @return {?}
         */
        function (fdDate) {
            return false;
        });
        /**
         * Function used to disable certain dates in the calendar for the range end selection.
         * @param fdDate FdDate
         */
        this.disableRangeEndFunction = (/**
         * @param {?} fdDate
         * @return {?}
         */
        function (fdDate) {
            return false;
        });
        /**
         * Function used to block certain dates in the calendar for the range start selection.
         * @param fdDate FdDate
         */
        this.blockRangeStartFunction = (/**
         * @param {?} fdDate
         * @return {?}
         */
        function (fdDate) {
            return false;
        });
        /**
         * Function used to block certain dates in the calendar for the range end selection.
         * @param fdDate FdDate
         */
        this.blockRangeEndFunction = (/**
         * @param {?} fdDate
         * @return {?}
         */
        function (fdDate) {
            return false;
        });
        /**
         * Function used to block certain dates in the calendar.
         * @param fdDate FdDate
         */
        this.blockFunction = (/**
         * @param {?} fdDate
         * @return {?}
         */
        function (fdDate) {
            return false;
        });
    }
    /**
     * Method that handle calendar active view change and throws event.
     * @param {?} activeView
     * @return {?}
     */
    handleCalendarActiveViewChange(activeView) {
        this.activeViewChange.emit(activeView);
    }
    /**
     * @hidden
     * @return {?}
     */
    closeFromCalendar() {
        if (this.type === 'single') {
            this.closeCalendar();
        }
    }
    /**
     * Opens the calendar
     * @return {?}
     */
    openCalendar() {
        if (!this.disabled) {
            this.onTouched();
            this.isOpen = true;
        }
    }
    /**
     * Toggles the calendar open or closed
     * @return {?}
     */
    toggleCalendar() {
        this.onTouched();
        this.isOpen = !this.isOpen;
    }
    /**
     * Closes the calendar if it is open
     * @return {?}
     */
    closeCalendar() {
        if (this.isOpen) {
            this.isOpen = false;
        }
    }
    /**
     * @hidden
     * Method that is triggered by events from calendar component, when there is selected single date changed
     * @param {?} date
     * @return {?}
     */
    handleSingleDateChange(date) {
        if (date) {
            this.inputFieldDate = this._formatDate(date);
            this.selectedDate = date;
            this.selectedDateChange.emit(date);
            this.onChange(date);
            this.isInvalidDateInput = !this.isModelValid();
        }
    }
    /**
     * @hidden
     * Method that is triggered by events from calendar component, when there is selected range date changed
     * @param {?} dates
     * @return {?}
     */
    handleRangeDateChange(dates) {
        if (dates &&
            (!CalendarService.datesEqual(this.selectedRangeDate.start, dates.start) ||
                !CalendarService.datesEqual(this.selectedRangeDate.end, dates.end))) {
            this.inputFieldDate = this._formatDate(dates.start)
                + this.dateAdapter.rangeDelimiter
                + this._formatDate(dates.end);
            this.selectedRangeDate = { start: dates.start, end: dates.end };
            this.selectedRangeDateChange.emit(this.selectedRangeDate);
            this.onChange(this.selectedRangeDate);
            this.isInvalidDateInput = !this.isModelValid();
        }
    }
    /**
     * @hidden
     * Method that is triggered when the text input is confirmed to ba changed, by clicking enter, or blur
     * @param {?} strDate
     * @return {?}
     */
    handleInputChange(strDate) {
        this.dateStringUpdate(strDate);
    }
    /**
     * @hidden
     * Function that implements Validator Interface, adds validation support for forms
     * @param {?} control
     * @return {?}
     */
    validate(control) {
        return this.isModelValid() ? null : {
            dateValidation: {
                valid: false
            }
        };
    }
    /**
     * @hidden
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onChange = fn;
    }
    /**
     * @hidden
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    /**
     * @hidden
     * @param {?} isDisabled
     * @return {?}
     */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
        this._changeDetectionRef.detectChanges();
    }
    /**
     * @hidden
     * Function that provides support for ControlValueAccessor that allows to use [(ngModel)] or forms
     * @param {?} selected
     * @return {?}
     */
    writeValue(selected) {
        /** If written value is not defined, null, empty string */
        if (!selected) {
            this.inputFieldDate = '';
            return;
        }
        if (this.type === 'single') {
            /**
             * For single mode, if the date is invalid, model is changed, it refresh currently
             * input field text, but it does not refresh currently displayed day
             */
            selected = (/** @type {?} */ (selected));
            this.selectedDate = selected;
            if (this._isSingleModelValid(this.selectedDate)) {
                this.inputFieldDate = this._formatDate(selected);
                this._refreshCurrentlyDisplayedCalendarDate(selected);
            }
            else {
                this.inputFieldDate = '';
            }
        }
        else {
            /**
             * For range mode, if the date is invalid, model is changed, but it does not refresh currently
             * displayed day view, or input field text
             */
            selected = (/** @type {?} */ (selected));
            if (selected.start) {
                this.selectedRangeDate = { start: selected.start, end: selected.end };
                if (this._isRangeModelValid(this.selectedRangeDate)) {
                    this._refreshCurrentlyDisplayedCalendarDate(selected.start);
                    this.inputFieldDate = this._formatDate(selected.start) +
                        this.dateAdapter.rangeDelimiter + this._formatDate(selected.end);
                }
                else {
                    this.inputFieldDate = '';
                }
            }
            else {
                this.inputFieldDate = '';
            }
        }
        this._changeDetectionRef.detectChanges();
        this.isInvalidDateInput = !this.isModelValid();
    }
    /**
     * @hidden
     * Method, which is responsible for transforming string to date, depending on type or
     * validation the results are different. It also changes to state of isInvalidDateInput
     * @param {?} date
     * @return {?}
     */
    dateStringUpdate(date) {
        this.inputFieldDate = date;
        /** Case when there is single mode */
        if (this.type === 'single') {
            /** @type {?} */
            let fdDate = this.dateAdapter.parse(date);
            /** Check if dates are equal, if so, there is no need to make any changes */
            if (!CalendarService.datesEqual(fdDate, this.selectedDate)) {
                this.isInvalidDateInput = !this._isSingleModelValid(fdDate);
                /** Check if date is valid, if it's not, there is no need to refresh calendar */
                if (!this.isInvalidDateInput && date) {
                    this._refreshCurrentlyDisplayedCalendarDate(fdDate);
                }
                else {
                    /** Whether string is invalid, by passed block or disable functions there is forced Invalid Object, */
                    fdDate = this._invalidDate();
                }
                /**
                 * Date in model is changed no matter if the parsed date from string is valid or not.
                 */
                this.selectedDate = fdDate;
                this.onChange(this.selectedDate);
                this.selectedDateChange.emit(this.selectedDate);
            }
            /** Case when there is range mode */
        }
        else {
            /** @type {?} */
            const currentDates = date.split(this.dateAdapter.rangeDelimiter);
            /** @type {?} */
            const firstDate = this.dateAdapter.parse(currentDates[0]);
            /** @type {?} */
            const secondDate = this.dateAdapter.parse(currentDates[1]);
            /**
             * Check if dates are equal, if dates are the same there is no need to make any changes
             * Date in model is changed no matter if the parsed dates from string are valid or not.
             */
            if (!CalendarService.datesEqual(firstDate, this.selectedRangeDate.start) ||
                !CalendarService.datesEqual(secondDate, this.selectedRangeDate.end)) {
                /** @type {?} */
                let selectedRangeDate = null;
                /** If the end date is before the start date, there is need to replace them  */
                if ((firstDate.getTimeStamp() > secondDate.getTimeStamp()) && secondDate.isDateValid()) {
                    selectedRangeDate = { start: secondDate, end: firstDate };
                }
                else {
                    selectedRangeDate = { start: firstDate, end: secondDate };
                }
                this.isInvalidDateInput = !this._isRangeModelValid(selectedRangeDate);
                /** If start date is invalid, because of format, block or disable function, there is invalidDate forced */
                if (!this._isStartDateValid(selectedRangeDate.start)) {
                    selectedRangeDate.start = this._invalidDate();
                }
                /** If end date is invalid, because of format, block or disable function, there is invalidDate forced */
                if (!this._isEndDateValid(selectedRangeDate.end)) {
                    selectedRangeDate.end = this._invalidDate();
                }
                /** Whole object is changed, even it's invalid */
                this.selectedRangeDate = selectedRangeDate;
                this.selectedRangeDateChange.emit(this.selectedRangeDate);
                this.onChange(this.selectedRangeDate);
                /** Check if start date is valid, if it's not, there is no need o refresh calendar */
                if (this._isStartDateValid(this.selectedRangeDate.start)) {
                    this._refreshCurrentlyDisplayedCalendarDate(this.selectedRangeDate.start);
                }
            }
        }
        if (!date && this.allowNull) {
            this.isInvalidDateInput = false;
        }
    }
    /**
     * Method that provides information if model selected date/dates have properly types and are valid
     * @return {?}
     */
    isModelValid() {
        if (this.type === 'single') {
            return this._isSingleModelValid(this.selectedDate);
        }
        else {
            return this._isRangeModelValid(this.selectedRangeDate);
        }
    }
    /**
     * Method that returns info if single model given is valid
     * @private
     * @param {?} fdDate
     * @return {?}
     */
    _isSingleModelValid(fdDate) {
        return (this._isFdDateValid(fdDate) &&
            !this.disableFunction(fdDate) &&
            !this.blockFunction(fdDate)) || (!this.inputFieldDate && this.allowNull);
    }
    /**
     * Method that returns info if range date model given is valid
     * @private
     * @param {?} fdRangeDate
     * @return {?}
     */
    _isRangeModelValid(fdRangeDate) {
        return (fdRangeDate &&
            this._isStartDateValid(fdRangeDate.start) &&
            this._isEndDateValid(fdRangeDate.end)) || (!this.inputFieldDate && this.allowNull);
    }
    /**
     * Method that returns info if end date model given is valid
     * @private
     * @param {?} endDate
     * @return {?}
     */
    _isEndDateValid(endDate) {
        return this._isFdDateValid(endDate) &&
            !this.disableRangeEndFunction(endDate) &&
            !this.blockRangeEndFunction(endDate);
    }
    /**
     * Method that returns info if start date model given is valid
     * @private
     * @param {?} startDate
     * @return {?}
     */
    _isStartDateValid(startDate) {
        return this._isFdDateValid(startDate) &&
            !this.disableRangeStartFunction(startDate) &&
            !this.blockRangeStartFunction(startDate);
    }
    /**
     * Method that returns info if end date model given is valid
     * @private
     * @param {?} fdDate
     * @return {?}
     */
    _isFdDateValid(fdDate) {
        return fdDate &&
            fdDate instanceof FdDate &&
            fdDate.isDateValid();
    }
    /**
     * @private
     * @return {?}
     */
    _invalidDate() {
        return this.dateAdapter.parse('InVaLiDDaTe');
    }
    /**
     * @hidden
     * @private
     * @param {?} date
     * @return {?}
     */
    _refreshCurrentlyDisplayedCalendarDate(date) {
        if (this.calendarComponent) {
            this.calendarComponent.setCurrentlyDisplayed(date);
        }
    }
    /**
     * @hidden
     * If there is any format function provided, it is used. Otherwise date format follows angular DatePipe functionality.
     * @private
     * @param {?} fdDate
     * @return {?}
     */
    _formatDate(fdDate) {
        /** @type {?} */
        const customFormattedDate = this.dateAdapter.format(fdDate);
        if (customFormattedDate) {
            return customFormattedDate;
        }
        else {
            return this._datePipe.transform(fdDate.toDate(), this.format, null, this.locale);
        }
    }
}
DatePickerComponent.decorators = [
    { type: Component, args: [{
                selector: 'fd-date-picker',
                template: "<fd-popover [(isOpen)]=\"isOpen\"\n            (isOpenChange)=\"handleInputChange(datePicker.value)\"\n            [triggers]=\"[]\"\n            [placement]=\"placement\"\n            [closeOnEscapeKey]=\"true\"\n            [disabled]=\"disabled\">\n    <fd-popover-control>\n        <fd-input-group [compact]=\"compact\" [state]=\"state\" [disabled]=\"disabled\">\n            <input #datePicker\n                   class=\"fd-input\"\n                   fd-input-group-input\n                   type=\"text\"\n                   [attr.aria-label]=\"dateInputLabel\"\n                   [value]=\"inputFieldDate\"\n                   [placeholder]=\"placeholder\"\n                   (keyup.enter)=\"handleInputChange(datePicker.value)\"\n                   (click)=\"openCalendar()\"\n                   [compact]=\"compact\"\n                   [ngClass]=\"{ 'is-invalid': isInvalidDateInput && useValidation }\">\n            <span fd-input-group-addon [button]=\"true\" [compact]=\"compact\">\n                <button fd-button\n                        [attr.tabindex]=\"buttonFocusable ? 0 : -1\"\n                        [glyph]=\"'calendar'\"\n                        [options]=\"'light'\"\n                        [compact]=\"compact\"\n                        (click)=\"toggleCalendar()\" [attr.aria-label]=\"displayCalendarToggleLabel\"\n                        [attr.aria-expanded]=\"isOpen\">\n                </button>\n            </span>\n        </fd-input-group>\n    </fd-popover-control>\n    <fd-popover-body\n        [style.display]=\"'block'\"\n        [attr.aria-expanded]=\"isOpen\"\n        [attr.aria-hidden]=\"!isOpen\">\n        <fd-calendar (closeCalendar)=\"closeFromCalendar()\"\n                     [activeView]=\"activeView\"\n                     (activeViewChange)=\"handleCalendarActiveViewChange($event)\"\n                     [calType]=\"type\"\n                     [disableFunction]=\"disableFunction ? disableFunction : null\"\n                     [blockFunction]=\"blockFunction ? blockFunction : null\"\n                     [disableRangeStartFunction]=\"disableRangeStartFunction ? disableRangeStartFunction : null\"\n                     [disableRangeEndFunction]=\"disableRangeEndFunction ? disableRangeEndFunction : null\"\n                     [blockRangeStartFunction]=\"blockRangeStartFunction ? blockRangeStartFunction : null\"\n                     [blockRangeEndFunction]=\"blockRangeEndFunction ? blockRangeEndFunction : null\"\n                     [selectedDate]=\"selectedDate\"\n                     [selectedRangeDate]=\"selectedRangeDate\"\n                     (selectedRangeDateChange)=\"handleRangeDateChange($event)\"\n                     (selectedDateChange)=\"handleSingleDateChange($event)\"\n                     [startingDayOfWeek]=\"startingDayOfWeek\"></fd-calendar>\n    </fd-popover-body>\n</fd-popover>\n",
                host: {
                    '(blur)': 'onTouched()',
                    '[class.fd-date-picker]': 'true',
                    '[class.fd-date-picker-custom]': 'true'
                },
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => DatePickerComponent)),
                        multi: true
                    },
                    {
                        provide: NG_VALIDATORS,
                        useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => DatePickerComponent)),
                        multi: true
                    },
                    DatePipe
                ],
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [".fd-date-picker-custom{display:inline-block}.fd-date-picker-custom fd-popover{display:block}"]
            }] }
];
/** @nocollapse */
DatePickerComponent.ctorParameters = () => [
    { type: DateFormatParser },
    { type: ChangeDetectorRef },
    { type: DatePipe, decorators: [{ type: Optional }] }
];
DatePickerComponent.propDecorators = {
    calendarComponent: [{ type: ViewChild, args: [CalendarComponent, { static: false },] }],
    type: [{ type: Input }],
    placeholder: [{ type: Input }],
    format: [{ type: Input }],
    locale: [{ type: Input }],
    compact: [{ type: Input }],
    selectedDate: [{ type: Input }],
    selectedRangeDate: [{ type: Input }],
    startingDayOfWeek: [{ type: Input }],
    useValidation: [{ type: Input }],
    dateInputLabel: [{ type: Input }],
    displayCalendarToggleLabel: [{ type: Input }],
    allowNull: [{ type: Input }],
    activeView: [{ type: Input }],
    placement: [{ type: Input }],
    disabled: [{ type: Input }],
    state: [{ type: Input }],
    buttonFocusable: [{ type: Input }],
    selectedDateChange: [{ type: Output }],
    selectedRangeDateChange: [{ type: Output }],
    activeViewChange: [{ type: Output }],
    disableFunction: [{ type: Input }],
    disableRangeStartFunction: [{ type: Input }],
    disableRangeEndFunction: [{ type: Input }],
    blockRangeStartFunction: [{ type: Input }],
    blockRangeEndFunction: [{ type: Input }],
    blockFunction: [{ type: Input }]
};
if (false) {
    /**
     * @hidden The value of the input
     * @type {?}
     */
    DatePickerComponent.prototype.inputFieldDate;
    /**
     * @hidden Whether the date input is invalid
     * @type {?}
     */
    DatePickerComponent.prototype.isInvalidDateInput;
    /**
     * @hidden Whether the date picker is open
     * @type {?}
     */
    DatePickerComponent.prototype.isOpen;
    /**
     * @hidden
     * @type {?}
     */
    DatePickerComponent.prototype.calendarComponent;
    /**
     * The type of calendar, 'single' for single date selection or 'range' for a range of dates.
     * @type {?}
     */
    DatePickerComponent.prototype.type;
    /**
     * Date picker input placeholder string
     * @type {?}
     */
    DatePickerComponent.prototype.placeholder;
    /**
     * Date Format displayed on input. See more options: https://angular.io/api/common/DatePipe
     * @type {?}
     */
    DatePickerComponent.prototype.format;
    /**
     * Locale for date pipe. See more https://angular.io/guide/i18n
     * @type {?}
     */
    DatePickerComponent.prototype.locale;
    /**
     * Whether this is the compact input date picker
     * @type {?}
     */
    DatePickerComponent.prototype.compact;
    /**
     * The currently selected CalendarDay model
     * @type {?}
     */
    DatePickerComponent.prototype.selectedDate;
    /**
     * The currently selected FdDates model start and end in range mode.
     * @type {?}
     */
    DatePickerComponent.prototype.selectedRangeDate;
    /**
     * The day of the week the calendar should start on. 1 represents Sunday, 2 is Monday, 3 is Tuesday, and so on.
     * @type {?}
     */
    DatePickerComponent.prototype.startingDayOfWeek;
    /**
     * Whether to validate the date picker input.
     * @type {?}
     */
    DatePickerComponent.prototype.useValidation;
    /**
     * Aria label for the datepicker input.
     * @type {?}
     */
    DatePickerComponent.prototype.dateInputLabel;
    /**
     * Aria label for the button to show/hide the calendar.
     * @type {?}
     */
    DatePickerComponent.prototype.displayCalendarToggleLabel;
    /**
     * Whether a null input is considered valid.
     * @type {?}
     */
    DatePickerComponent.prototype.allowNull;
    /**
     * Actually shown active view one of 'day' | 'month' | 'year' in calendar component
     * @type {?}
     */
    DatePickerComponent.prototype.activeView;
    /**
     *  The placement of the popover. It can be one of: top, top-start, top-end, bottom,
     *  bottom-start, bottom-end, right, right-start, right-end, left, left-start, left-end.
     * @type {?}
     */
    DatePickerComponent.prototype.placement;
    /**
     * Whether the date picker is disabled.
     * @type {?}
     */
    DatePickerComponent.prototype.disabled;
    /**
     *  The state of the form control - applies css classes.
     *  Can be `valid`, `invalid`, `warning`, `information` or blank for default.
     * @type {?}
     */
    DatePickerComponent.prototype.state;
    /**
     * Whether AddOn Button should be focusable, set to true by default
     * @type {?}
     */
    DatePickerComponent.prototype.buttonFocusable;
    /**
     * Fired when a new date is selected.
     * @type {?}
     */
    DatePickerComponent.prototype.selectedDateChange;
    /**
     * Event thrown every time selected first or last date in range mode is changed
     * @type {?}
     */
    DatePickerComponent.prototype.selectedRangeDateChange;
    /**
     * Event thrown every time calendar active view is changed
     * @type {?}
     */
    DatePickerComponent.prototype.activeViewChange;
    /**
     * @hidden
     * @type {?}
     */
    DatePickerComponent.prototype.onChange;
    /**
     * @hidden
     * @type {?}
     */
    DatePickerComponent.prototype.onTouched;
    /**
     * Function used to disable certain dates in the calendar.
     * \@param fdDate FdDate
     * @type {?}
     */
    DatePickerComponent.prototype.disableFunction;
    /**
     * Function used to disable certain dates in the calendar for the range start selection.
     * \@param fdDate FdDate
     * @type {?}
     */
    DatePickerComponent.prototype.disableRangeStartFunction;
    /**
     * Function used to disable certain dates in the calendar for the range end selection.
     * \@param fdDate FdDate
     * @type {?}
     */
    DatePickerComponent.prototype.disableRangeEndFunction;
    /**
     * Function used to block certain dates in the calendar for the range start selection.
     * \@param fdDate FdDate
     * @type {?}
     */
    DatePickerComponent.prototype.blockRangeStartFunction;
    /**
     * Function used to block certain dates in the calendar for the range end selection.
     * \@param fdDate FdDate
     * @type {?}
     */
    DatePickerComponent.prototype.blockRangeEndFunction;
    /**
     * Function used to block certain dates in the calendar.
     * \@param fdDate FdDate
     * @type {?}
     */
    DatePickerComponent.prototype.blockFunction;
    /** @type {?} */
    DatePickerComponent.prototype.dateAdapter;
    /**
     * @type {?}
     * @private
     */
    DatePickerComponent.prototype._changeDetectionRef;
    /**
     * @type {?}
     * @private
     */
    DatePickerComponent.prototype._datePipe;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0ZS1waWNrZXIuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6Im5nOi8vQGZ1bmRhbWVudGFsLW5neC9jb3JlLyIsInNvdXJjZXMiOlsibGliL2RhdGUtcGlja2VyL2RhdGUtcGlja2VyLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLE9BQU8sRUFDSCx1QkFBdUIsRUFDdkIsaUJBQWlCLEVBQ2pCLFNBQVMsRUFDVCxZQUFZLEVBQ1osVUFBVSxFQUNWLEtBQUssRUFBRSxRQUFRLEVBQ2YsTUFBTSxFQUFFLFNBQVMsRUFDakIsaUJBQWlCLEVBQ3BCLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBRSxpQkFBaUIsRUFBNEMsTUFBTSxnQ0FBZ0MsQ0FBQztBQUM3RyxPQUFPLEVBQXlDLGFBQWEsRUFBRSxpQkFBaUIsRUFBYSxNQUFNLGdCQUFnQixDQUFDO0FBRXBILE9BQU8sRUFBRSxNQUFNLEVBQUUsTUFBTSw0QkFBNEIsQ0FBQztBQUNwRCxPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0sOEJBQThCLENBQUM7QUFFL0QsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0sc0JBQXNCLENBQUM7QUFDeEQsT0FBTyxFQUFFLFFBQVEsRUFBRSxNQUFNLGlCQUFpQixDQUFDOzs7Ozs7Ozs7O0FBcUMzQyxNQUFNLE9BQU8sbUJBQW1COzs7Ozs7O0lBbVA1QixZQUNXLFdBQTZCLEVBQzVCLG1CQUFzQyxFQUMxQixTQUFtQjtRQUZoQyxnQkFBVyxHQUFYLFdBQVcsQ0FBa0I7UUFDNUIsd0JBQW1CLEdBQW5CLG1CQUFtQixDQUFtQjtRQUMxQixjQUFTLEdBQVQsU0FBUyxDQUFVOzs7O1FBblAzQyxtQkFBYyxHQUFXLElBQUksQ0FBQzs7OztRQUc5Qix1QkFBa0IsR0FBWSxLQUFLLENBQUM7Ozs7UUFHcEMsV0FBTSxHQUFZLEtBQUssQ0FBQzs7OztRQVF4QixTQUFJLEdBQWlCLFFBQVEsQ0FBQzs7OztRQUk5QixnQkFBVyxHQUFXLFlB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ekIsMkNBQ3FCOzs7OztJQUdyQixnREFDbUU7Ozs7O0lBR25FLGdEQUNrQzs7Ozs7SUFHbEMsNENBQzhCOzs7OztJQUc5Qiw2Q0FDc0M7Ozs7O0lBR3RDLHlEQUMrRDs7Ozs7SUFHL0Qsd0NBQzBCOzs7OztJQUcxQix5Q0FDMEM7Ozs7OztJQU0xQyx3Q0FDc0M7Ozs7O0lBR3RDLHVDQUNrQjs7Ozs7O0lBTWxCLG9DQUNrQjs7Ozs7SUFLbEIsOENBQ2dDOzs7OztJQUdoQyxpREFDc0Y7Ozs7O0lBR3RGLHNEQUNxRzs7Ozs7SUFHckcsK0NBQ29HOzs7OztJQUdwRyx1Q0FDRTs7Ozs7SUFHRix3Q0FDRTs7Ozs7O0lBTUYsOENBR0U7Ozs7OztJQU1GLHdEQUdFOzs7Ozs7SUFNRixzREFHRTs7Ozs7O0lBTUYsc0RBR0U7Ozs7OztJQU1GLG9EQUdFOzs7Ozs7SUFNRiw0Q0FHRTs7SUFpRkUsMENBQW9DOzs7OztJQUNwQyxrREFBOEM7Ozs7O0lBQzlDLHdDQUF1QyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gICAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXG4gICAgQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgQ29tcG9uZW50LFxuICAgIEV2ZW50RW1pdHRlcixcbiAgICBmb3J3YXJkUmVmLFxuICAgIElucHV0LCBPcHRpb25hbCxcbiAgICBPdXRwdXQsIFZpZXdDaGlsZCxcbiAgICBWaWV3RW5jYXBzdWxhdGlvblxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENhbGVuZGFyQ29tcG9uZW50LCBDYWxlbmRhclR5cGUsIERheXNPZldlZWssIEZkQ2FsZW5kYXJWaWV3IH0gZnJvbSAnLi4vY2FsZW5kYXIvY2FsZW5kYXIuY29tcG9uZW50JztcbmltcG9ydCB7IEFic3RyYWN0Q29udHJvbCwgQ29udHJvbFZhbHVlQWNjZXNzb3IsIE5HX1ZBTElEQVRPUlMsIE5HX1ZBTFVFX0FDQ0VTU09SLCBWYWxpZGF0b3IgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyBQbGFjZW1lbnQgfSBmcm9tICdwb3BwZXIuanMnO1xuaW1wb3J0IHsgRmREYXRlIH0gZnJvbSAnLi4vY2FsZW5kYXIvbW9kZWxzL2ZkLWRhdGUnO1xuaW1wb3J0IHsgQ2FsZW5kYXJTZXJ2aWNlIH0gZnJvbSAnLi4vY2FsZW5kYXIvY2FsZW5kYXIuc2VydmljZSc7XG5pbXBvcnQgeyBGZFJhbmdlRGF0ZSB9IGZyb20gJy4uL2NhbGVuZGFyL21vZGVscy9mZC1yYW5nZS1kYXRlJztcbmltcG9ydCB7IERhdGVGb3JtYXRQYXJzZXIgfSBmcm9tICcuL2Zvcm1hdC9kYXRlLXBhcnNlcic7XG5pbXBvcnQgeyBEYXRlUGlwZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBGb3JtU3RhdGVzIH0gZnJvbSAnLi4vZm9ybS9mb3JtLWNvbnRyb2wvZm9ybS1zdGF0ZXMnO1xuXG4vKipcbiAqIFRoZSBkYXRldGltZSBwaWNrZXIgY29tcG9uZW50IGlzIGFuIG9waW5pb25hdGVkIGNvbXBvc2l0aW9uIG9mIHRoZSBmZC1wb3BvdmVyIGFuZFxuICogZmQtY2FsZW5kYXIgY29tcG9uZW50cyB0byBhY2NvbXBsaXNoIHRoZSBVSSBwYXR0ZXJuIGZvciBwaWNraW5nIGEgZGF0ZS5cbiAqXG4gKiBTdXBwb3J0cyBBbmd1bGFyIEZvcm1zLlxuICogYGBgaHRtbFxuICogPGZkLWRhdGUtcGlja2VyIFsobmdNb2RlbCldPVwiZGF0ZVwiPjwvZmQtZGF0ZS1waWNrZXI+XG4gKiBgYGBcbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdmZC1kYXRlLXBpY2tlcicsXG4gICAgdGVtcGxhdGVVcmw6ICcuL2RhdGUtcGlja2VyLmNvbXBvbmVudC5odG1sJyxcbiAgICBzdHlsZVVybHM6IFsnLi9kYXRlLXBpY2tlci5jb21wb25lbnQuc2NzcyddLFxuICAgIGhvc3Q6IHtcbiAgICAgICAgJyhibHVyKSc6ICdvblRvdWNoZWQoKScsXG4gICAgICAgICdbY2xhc3MuZmQtZGF0ZS1waWNrZXJdJzogJ3RydWUnLFxuICAgICAgICAnW2NsYXNzLmZkLWRhdGUtcGlja2VyLWN1c3RvbV0nOiAndHJ1ZSdcbiAgICB9LFxuICAgIHByb3ZpZGVyczogW1xuICAgICAgICB7XG4gICAgICAgICAgICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcbiAgICAgICAgICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IERhdGVQaWNrZXJDb21wb25lbnQpLFxuICAgICAgICAgICAgbXVsdGk6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgcHJvdmlkZTogTkdfVkFMSURBVE9SUyxcbiAgICAgICAgICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IERhdGVQaWNrZXJDb21wb25lbnQpLFxuICAgICAgICAgICAgbXVsdGk6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgRGF0ZVBpcGVcbiAgICBdLFxuICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcbn0pXG5leHBvcnQgY2xhc3MgRGF0ZVBpY2tlckNvbXBvbmVudCBpbXBsZW1lbnRzIENvbnRyb2xWYWx1ZUFjY2Vzc29yLCBWYWxpZGF0b3Ige1xuXG4gICAgLyoqIEBoaWRkZW4gVGhlIHZhbHVlIG9mIHRoZSBpbnB1dCAqL1xuICAgIGlucHV0RmllbGREYXRlOiBzdHJpbmcgPSBudWxsO1xuXG4gICAgLyoqIEBoaWRkZW4gV2hldGhlciB0aGUgZGF0ZSBpbnB1dCBpcyBpbnZhbGlkICovXG4gICAgaXNJbnZhbGlkRGF0ZUlucHV0OiBib29sZWFuID0gZmFsc2U7XG5cbiAgICAvKiogQGhpZGRlbiBXaGV0aGVyIHRoZSBkYXRlIHBpY2tlciBpcyBvcGVuICovXG4gICAgaXNPcGVuOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIEBWaWV3Q2hpbGQoQ2FsZW5kYXJDb21wb25lbnQsIHsgc3RhdGljOiBmYWxzZSB9KVxuICAgIGNhbGVuZGFyQ29tcG9uZW50OiBDYWxlbmRhckNvbXBvbmVudDtcblxuICAgIC8qKiBUaGUgdHlwZSBvZiBjYWxlbmRhciwgJ3NpbmdsZScgZm9yIHNpbmdsZSBkYXRlIHNlbGVjdGlvbiBvciAncmFuZ2UnIGZvciBhIHJhbmdlIG9mIGRhdGVzLiAqL1xuICAgIEBJbnB1dCgpXG4gICAgdHlwZTogQ2FsZW5kYXJUeXBlID0gJ3NpbmdsZSc7XG5cbiAgICAvKiogRGF0ZSBwaWNrZXIgaW5wdXQgcGxhY2Vob2xkZXIgc3RyaW5nICovXG4gICAgQElucHV0KClcbiAgICBwbGFjZWhvbGRlcjogc3RyaW5nID0gJ21tL2RkL3l5eXknO1xuXG4gICAgLyoqIERhdGUgRm9ybWF0IGRpc3BsYXllZCBvbiBpbnB1dC4gU2VlIG1vcmUgb3B0aW9uczogaHR0cHM6Ly9hbmd1bGFyLmlvL2FwaS9jb21tb24vRGF0ZVBpcGUgKi9cbiAgICBASW5wdXQoKVxuICAgIGZvcm1hdDogc3RyaW5nID0gJ01NL2RkL3l5eXknO1xuXG4gICAgLyoqIExvY2FsZSBmb3IgZGF0ZSBwaXBlLiBTZWUgbW9yZSBodHRwczovL2FuZ3VsYXIuaW8vZ3VpZGUvaTE4biAqL1xuICAgIEBJbnB1dCgpXG4gICAgbG9jYWxlOiBzdHJpbmc7XG5cbiAgICAvKiogV2hldGhlciB0aGlzIGlzIHRoZSBjb21wYWN0IGlucHV0IGRhdGUgcGlja2VyICovXG4gICAgQElucHV0KClcbiAgICBjb21wYWN0OiBib29sZWFuID0gZmFsc2U7XG5cbiAgICAvKiogVGhlIGN1cnJlbnRseSBzZWxlY3RlZCBDYWxlbmRhckRheSBtb2RlbCAqL1xuICAgIEBJbnB1dCgpXG4gICAgc2VsZWN0ZWREYXRlOiBGZERhdGU7XG5cbiAgICAvKiogVGhlIGN1cnJlbnRseSBzZWxlY3RlZCBGZERhdGVzIG1vZGVsIHN0YXJ0IGFuZCBlbmQgaW4gcmFuZ2UgbW9kZS4gKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBzZWxlY3RlZFJhbmdlRGF0ZTogRmRSYW5nZURhdGUgPSB7IHN0YXJ0OiBudWxsLCBlbmQ6IG51bGwgfTtcblxuICAgIC8qKiBUaGUgZGF5IG9mIHRoZSB3ZWVrIHRoZSBjYWxlbmRhciBzaG91bGQgc3RhcnQgb24uIDEgcmVwcmVzZW50cyBTdW5kYXksIDIgaXMgTW9uZGF5LCAzIGlzIFR1ZXNkYXksIGFuZCBzbyBvbi4gKi9cbiAgICBASW5wdXQoKVxuICAgIHN0YXJ0aW5nRGF5T2ZXZWVrOiBEYXlzT2ZXZWVrID0gMTtcblxuICAgIC8qKiBXaGV0aGVyIHRvIHZhbGlkYXRlIHRoZSBkYXRlIHBpY2tlciBpbnB1dC4gKi9cbiAgICBASW5wdXQoKVxuICAgIHVzZVZhbGlkYXRpb246IGJvb2xlYW4gPSB0cnVlO1xuXG4gICAgLyoqIEFyaWEgbGFiZWwgZm9yIHRoZSBkYXRlcGlja2VyIGlucHV0LiAqL1xuICAgIEBJbnB1dCgpXG4gICAgZGF0ZUlucHV0TGFiZWw6IHN0cmluZyA9ICdEYXRlIGlucHV0JztcblxuICAgIC8qKiBBcmlhIGxhYmVsIGZvciB0aGUgYnV0dG9uIHRvIHNob3cvaGlkZSB0aGUgY2FsZW5kYXIuICovXG4gICAgQElucHV0KClcbiAgICBkaXNwbGF5Q2FsZW5kYXJUb2dnbGVMYWJlbDogc3RyaW5nID0gJ0Rpc3BsYXkgY2FsZW5kYXIgdG9nZ2xlJztcblxuICAgIC8qKiBXaGV0aGVyIGEgbnVsbCBpbnB1dCBpcyBjb25zaWRlcmVkIHZhbGlkLiAqL1xuICAgIEBJbnB1dCgpXG4gICAgYWxsb3dOdWxsOiBib29sZWFuID0gdHJ1ZTtcblxuICAgIC8qKiBBY3R1YWxseSBzaG93biBhY3RpdmUgdmlldyBvbmUgb2YgJ2RheScgfCAnbW9udGgnIHwgJ3llYXInIGluIGNhbGVuZGFyIGNvbXBvbmVudCovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgYWN0aXZlVmlldzogRmRDYWxlbmRhclZpZXcgPSAnZGF5JztcblxuICAgIC8qKlxuICAgICAqICBUaGUgcGxhY2VtZW50IG9mIHRoZSBwb3BvdmVyLiBJdCBjYW4gYmUgb25lIG9mOiB0b3AsIHRvcC1zdGFydCwgdG9wLWVuZCwgYm90dG9tLFxuICAgICAqICBib3R0b20tc3RhcnQsIGJvdHRvbS1lbmQsIHJpZ2h0LCByaWdodC1zdGFydCwgcmlnaHQtZW5kLCBsZWZ0LCBsZWZ0LXN0YXJ0LCBsZWZ0LWVuZC5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHBsYWNlbWVudDogUGxhY2VtZW50ID0gJ2JvdHRvbS1zdGFydCc7XG5cbiAgICAvKiogV2hldGhlciB0aGUgZGF0ZSBwaWNrZXIgaXMgZGlzYWJsZWQuICovXG4gICAgQElucHV0KClcbiAgICBkaXNhYmxlZDogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqICBUaGUgc3RhdGUgb2YgdGhlIGZvcm0gY29udHJvbCAtIGFwcGxpZXMgY3NzIGNsYXNzZXMuXG4gICAgICogIENhbiBiZSBgdmFsaWRgLCBgaW52YWxpZGAsIGB3YXJuaW5nYCwgYGluZm9ybWF0aW9uYCBvciBibGFuayBmb3IgZGVmYXVsdC5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHN0YXRlOiBGb3JtU3RhdGVzO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciBBZGRPbiBCdXR0b24gc2hvdWxkIGJlIGZvY3VzYWJsZSwgc2V0IHRvIHRydWUgYnkgZGVmYXVsdFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgYnV0dG9uRm9jdXNhYmxlOiBib29sZWFuID0gdHJ1ZTtcblxuICAgIC8qKiBGaXJlZCB3aGVuIGEgbmV3IGRhdGUgaXMgc2VsZWN0ZWQuICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIHJlYWRvbmx5IHNlbGVjdGVkRGF0ZUNoYW5nZTogRXZlbnRFbWl0dGVyPEZkRGF0ZT4gPSBuZXcgRXZlbnRFbWl0dGVyPEZkRGF0ZT4oKTtcblxuICAgIC8qKiBFdmVudCB0aHJvd24gZXZlcnkgdGltZSBzZWxlY3RlZCBmaXJzdCBvciBsYXN0IGRhdGUgaW4gcmFuZ2UgbW9kZSBpcyBjaGFuZ2VkICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIHJlYWRvbmx5IHNlbGVjdGVkUmFuZ2VEYXRlQ2hhbmdlOiBFdmVudEVtaXR0ZXI8RmRSYW5nZURhdGU+ID0gbmV3IEV2ZW50RW1pdHRlcjxGZFJhbmdlRGF0ZT4oKTtcblxuICAgIC8qKiBFdmVudCB0aHJvd24gZXZlcnkgdGltZSBjYWxlbmRhciBhY3RpdmUgdmlldyBpcyBjaGFuZ2VkICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIHJlYWRvbmx5IGFjdGl2ZVZpZXdDaGFuZ2U6IEV2ZW50RW1pdHRlcjxGZENhbGVuZGFyVmlldz4gPSBuZXcgRXZlbnRFbWl0dGVyPEZkQ2FsZW5kYXJWaWV3PigpO1xuXG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBvbkNoYW5nZTogYW55ID0gKHNlbGVjdGVkOiBhbnkpID0+IHtcbiAgICB9O1xuXG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBvblRvdWNoZWQ6IGFueSA9ICgpID0+IHtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gdXNlZCB0byBkaXNhYmxlIGNlcnRhaW4gZGF0ZXMgaW4gdGhlIGNhbGVuZGFyLlxuICAgICAqIEBwYXJhbSBmZERhdGUgRmREYXRlXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBkaXNhYmxlRnVuY3Rpb24gPSBmdW5jdGlvbihmZERhdGU6IEZkRGF0ZSk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHVzZWQgdG8gZGlzYWJsZSBjZXJ0YWluIGRhdGVzIGluIHRoZSBjYWxlbmRhciBmb3IgdGhlIHJhbmdlIHN0YXJ0IHNlbGVjdGlvbi5cbiAgICAgKiBAcGFyYW0gZmREYXRlIEZkRGF0ZVxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgZGlzYWJsZVJhbmdlU3RhcnRGdW5jdGlvbiA9IGZ1bmN0aW9uKGZkRGF0ZTogRmREYXRlKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gdXNlZCB0byBkaXNhYmxlIGNlcnRhaW4gZGF0ZXMgaW4gdGhlIGNhbGVuZGFyIGZvciB0aGUgcmFuZ2UgZW5kIHNlbGVjdGlvbi5cbiAgICAgKiBAcGFyYW0gZmREYXRlIEZkRGF0ZVxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgZGlzYWJsZVJhbmdlRW5kRnVuY3Rpb24gPSBmdW5jdGlvbihmZERhdGU6IEZkRGF0ZSk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHVzZWQgdG8gYmxvY2sgY2VydGFpbiBkYXRlcyBpbiB0aGUgY2FsZW5kYXIgZm9yIHRoZSByYW5nZSBzdGFydCBzZWxlY3Rpb24uXG4gICAgICogQHBhcmFtIGZkRGF0ZSBGZERhdGVcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGJsb2NrUmFuZ2VTdGFydEZ1bmN0aW9uID0gZnVuY3Rpb24oZmREYXRlOiBGZERhdGUpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiB1c2VkIHRvIGJsb2NrIGNlcnRhaW4gZGF0ZXMgaW4gdGhlIGNhbGVuZGFyIGZvciB0aGUgcmFuZ2UgZW5kIHNlbGVjdGlvbi5cbiAgICAgKiBAcGFyYW0gZmREYXRlIEZkRGF0ZVxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgYmxvY2tSYW5nZUVuZEZ1bmN0aW9uID0gZnVuY3Rpb24oZmREYXRlOiBGZERhdGUpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiB1c2VkIHRvIGJsb2NrIGNlcnRhaW4gZGF0ZXMgaW4gdGhlIGNhbGVuZGFyLlxuICAgICAqIEBwYXJhbSBmZERhdGUgRmREYXRlXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBibG9ja0Z1bmN0aW9uID0gZnVuY3Rpb24oZmREYXRlOiBGZERhdGUpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdGhhdCBoYW5kbGUgY2FsZW5kYXIgYWN0aXZlIHZpZXcgY2hhbmdlIGFuZCB0aHJvd3MgZXZlbnQuXG4gICAgICovXG4gICAgcHVibGljIGhhbmRsZUNhbGVuZGFyQWN0aXZlVmlld0NoYW5nZShhY3RpdmVWaWV3OiBGZENhbGVuZGFyVmlldyk6IHZvaWQge1xuICAgICAgICB0aGlzLmFjdGl2ZVZpZXdDaGFuZ2UuZW1pdChhY3RpdmVWaWV3KTtcbiAgICB9XG5cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIHB1YmxpYyBjbG9zZUZyb21DYWxlbmRhcigpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ3NpbmdsZScpIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VDYWxlbmRhcigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIE9wZW5zIHRoZSBjYWxlbmRhciAqL1xuICAgIG9wZW5DYWxlbmRhcigpOiB2b2lkIHtcbiAgICAgICAgaWYgKCF0aGlzLmRpc2FibGVkKSB7XG4gICAgICAgICAgICB0aGlzLm9uVG91Y2hlZCgpO1xuICAgICAgICAgICAgdGhpcy5pc09wZW4gPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIFRvZ2dsZXMgdGhlIGNhbGVuZGFyIG9wZW4gb3IgY2xvc2VkICovXG4gICAgcHVibGljIHRvZ2dsZUNhbGVuZGFyKCk6IHZvaWQge1xuICAgICAgICB0aGlzLm9uVG91Y2hlZCgpO1xuICAgICAgICB0aGlzLmlzT3BlbiA9ICF0aGlzLmlzT3BlbjtcbiAgICB9XG5cbiAgICAvKiogQ2xvc2VzIHRoZSBjYWxlbmRhciBpZiBpdCBpcyBvcGVuICovXG4gICAgcHVibGljIGNsb3NlQ2FsZW5kYXIoKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLmlzT3Blbikge1xuICAgICAgICAgICAgdGhpcy5pc09wZW4gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBNZXRob2QgdGhhdCBpcyB0cmlnZ2VyZWQgYnkgZXZlbnRzIGZyb20gY2FsZW5kYXIgY29tcG9uZW50LCB3aGVuIHRoZXJlIGlzIHNlbGVjdGVkIHNpbmdsZSBkYXRlIGNoYW5nZWRcbiAgICAgKi9cbiAgICBwdWJsaWMgaGFuZGxlU2luZ2xlRGF0ZUNoYW5nZShkYXRlOiBGZERhdGUpOiB2b2lkIHtcbiAgICAgICAgaWYgKGRhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuaW5wdXRGaWVsZERhdGUgPSB0aGlzLl9mb3JtYXREYXRlKGRhdGUpO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZERhdGUgPSBkYXRlO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZERhdGVDaGFuZ2UuZW1pdChkYXRlKTtcbiAgICAgICAgICAgIHRoaXMub25DaGFuZ2UoZGF0ZSk7XG4gICAgICAgICAgICB0aGlzLmlzSW52YWxpZERhdGVJbnB1dCA9ICF0aGlzLmlzTW9kZWxWYWxpZCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIE1ldGhvZCB0aGF0IGlzIHRyaWdnZXJlZCBieSBldmVudHMgZnJvbSBjYWxlbmRhciBjb21wb25lbnQsIHdoZW4gdGhlcmUgaXMgc2VsZWN0ZWQgcmFuZ2UgZGF0ZSBjaGFuZ2VkXG4gICAgICovXG4gICAgcHVibGljIGhhbmRsZVJhbmdlRGF0ZUNoYW5nZShkYXRlczogRmRSYW5nZURhdGUpOiB2b2lkIHtcbiAgICAgICAgaWYgKGRhdGVzICYmXG4gICAgICAgICAgICAoIUNhbGVuZGFyU2VydmljZS5kYXRlc0VxdWFsKHRoaXMuc2VsZWN0ZWRSYW5nZURhdGUuc3RhcnQsIGRhdGVzLnN0YXJ0KSB8fFxuICAgICAgICAgICAgICAgICFDYWxlbmRhclNlcnZpY2UuZGF0ZXNFcXVhbCh0aGlzLnNlbGVjdGVkUmFuZ2VEYXRlLmVuZCwgZGF0ZXMuZW5kKSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgICB0aGlzLmlucHV0RmllbGREYXRlID0gdGhpcy5fZm9ybWF0RGF0ZShkYXRlcy5zdGFydClcbiAgICAgICAgICAgICAgICArIHRoaXMuZGF0ZUFkYXB0ZXIucmFuZ2VEZWxpbWl0ZXJcbiAgICAgICAgICAgICAgICArIHRoaXMuX2Zvcm1hdERhdGUoZGF0ZXMuZW5kKVxuICAgICAgICAgICAgO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZFJhbmdlRGF0ZSA9IHsgc3RhcnQ6IGRhdGVzLnN0YXJ0LCBlbmQ6IGRhdGVzLmVuZCB9O1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZFJhbmdlRGF0ZUNoYW5nZS5lbWl0KHRoaXMuc2VsZWN0ZWRSYW5nZURhdGUpO1xuICAgICAgICAgICAgdGhpcy5vbkNoYW5nZSh0aGlzLnNlbGVjdGVkUmFuZ2VEYXRlKTtcbiAgICAgICAgICAgIHRoaXMuaXNJbnZhbGlkRGF0ZUlucHV0ID0gIXRoaXMuaXNNb2RlbFZhbGlkKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogTWV0aG9kIHRoYXQgaXMgdHJpZ2dlcmVkIHdoZW4gdGhlIHRleHQgaW5wdXQgaXMgY29uZmlybWVkIHRvIGJhIGNoYW5nZWQsIGJ5IGNsaWNraW5nIGVudGVyLCBvciBibHVyXG4gICAgICovXG4gICAgcHVibGljIGhhbmRsZUlucHV0Q2hhbmdlKHN0ckRhdGU6IHN0cmluZyk6IHZvaWQge1xuICAgICAgICB0aGlzLmRhdGVTdHJpbmdVcGRhdGUoc3RyRGF0ZSk7XG4gICAgfVxuXG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHVibGljIGRhdGVBZGFwdGVyOiBEYXRlRm9ybWF0UGFyc2VyLFxuICAgICAgICBwcml2YXRlIF9jaGFuZ2VEZXRlY3Rpb25SZWY6IENoYW5nZURldGVjdG9yUmVmLFxuICAgICAgICBAT3B0aW9uYWwoKSBwcml2YXRlIF9kYXRlUGlwZTogRGF0ZVBpcGVcbiAgICApIHtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogRnVuY3Rpb24gdGhhdCBpbXBsZW1lbnRzIFZhbGlkYXRvciBJbnRlcmZhY2UsIGFkZHMgdmFsaWRhdGlvbiBzdXBwb3J0IGZvciBmb3Jtc1xuICAgICAqL1xuICAgIHZhbGlkYXRlKGNvbnRyb2w6IEFic3RyYWN0Q29udHJvbCk6IHtcbiAgICAgICAgW2tleTogc3RyaW5nXTogYW55XG4gICAgfSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzTW9kZWxWYWxpZCgpID8gbnVsbCA6IHtcbiAgICAgICAgICAgIGRhdGVWYWxpZGF0aW9uOiB7XG4gICAgICAgICAgICAgICAgdmFsaWQ6IGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICByZWdpc3Rlck9uQ2hhbmdlKGZuOiAoc2VsZWN0ZWQ6IGFueSkgPT4geyB2b2lkIH0pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5vbkNoYW5nZSA9IGZuO1xuICAgIH1cblxuICAgIC8qKiBAaGlkZGVuICovXG4gICAgcmVnaXN0ZXJPblRvdWNoZWQoZm46IGFueSk6IHZvaWQge1xuICAgICAgICB0aGlzLm9uVG91Y2hlZCA9IGZuO1xuICAgIH1cblxuICAgIC8qKiBAaGlkZGVuICovXG4gICAgc2V0RGlzYWJsZWRTdGF0ZShpc0Rpc2FibGVkOiBib29sZWFuKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSBpc0Rpc2FibGVkO1xuICAgICAgICB0aGlzLl9jaGFuZ2VEZXRlY3Rpb25SZWYuZGV0ZWN0Q2hhbmdlcygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBGdW5jdGlvbiB0aGF0IHByb3ZpZGVzIHN1cHBvcnQgZm9yIENvbnRyb2xWYWx1ZUFjY2Vzc29yIHRoYXQgYWxsb3dzIHRvIHVzZSBbKG5nTW9kZWwpXSBvciBmb3Jtc1xuICAgICAqL1xuICAgIHdyaXRlVmFsdWUoc2VsZWN0ZWQ6IEZkUmFuZ2VEYXRlIHwgRmREYXRlKTogdm9pZCB7XG4gICAgICAgIC8qKiBJZiB3cml0dGVuIHZhbHVlIGlzIG5vdCBkZWZpbmVkLCBudWxsLCBlbXB0eSBzdHJpbmcgKi9cbiAgICAgICAgaWYgKCFzZWxlY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5pbnB1dEZpZWxkRGF0ZSA9ICcnO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT09ICdzaW5nbGUnKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEZvciBzaW5nbGUgbW9kZSwgaWYgdGhlIGRhdGUgaXMgaW52YWxpZCwgbW9kZWwgaXMgY2hhbmdlZCwgaXQgcmVmcmVzaCBjdXJyZW50bHlcbiAgICAgICAgICAgICAqIGlucHV0IGZpZWxkIHRleHQsIGJ1dCBpdCBkb2VzIG5vdCByZWZyZXNoIGN1cnJlbnRseSBkaXNwbGF5ZWQgZGF5XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHNlbGVjdGVkID0gPEZkRGF0ZT5zZWxlY3RlZDtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWREYXRlID0gc2VsZWN0ZWQ7XG4gICAgICAgICAgICBpZiAodGhpcy5faXNTaW5nbGVNb2RlbFZhbGlkKHRoaXMuc2VsZWN0ZWREYXRlKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5wdXRGaWVsZERhdGUgPSB0aGlzLl9mb3JtYXREYXRlKHNlbGVjdGVkKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWZyZXNoQ3VycmVudGx5RGlzcGxheWVkQ2FsZW5kYXJEYXRlKHNlbGVjdGVkKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnB1dEZpZWxkRGF0ZSA9ICcnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEZvciByYW5nZSBtb2RlLCBpZiB0aGUgZGF0ZSBpcyBpbnZhbGlkLCBtb2RlbCBpcyBjaGFuZ2VkLCBidXQgaXQgZG9lcyBub3QgcmVmcmVzaCBjdXJyZW50bHlcbiAgICAgICAgICAgICAqIGRpc3BsYXllZCBkYXkgdmlldywgb3IgaW5wdXQgZmllbGQgdGV4dFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBzZWxlY3RlZCA9IDxGZFJhbmdlRGF0ZT5zZWxlY3RlZDtcblxuICAgICAgICAgICAgaWYgKHNlbGVjdGVkLnN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZFJhbmdlRGF0ZSA9IHsgc3RhcnQ6IHNlbGVjdGVkLnN0YXJ0LCBlbmQ6IHNlbGVjdGVkLmVuZCB9O1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2lzUmFuZ2VNb2RlbFZhbGlkKHRoaXMuc2VsZWN0ZWRSYW5nZURhdGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlZnJlc2hDdXJyZW50bHlEaXNwbGF5ZWRDYWxlbmRhckRhdGUoc2VsZWN0ZWQuc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlucHV0RmllbGREYXRlID0gdGhpcy5fZm9ybWF0RGF0ZShzZWxlY3RlZC5zdGFydCkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRlQWRhcHRlci5yYW5nZURlbGltaXRlciArIHRoaXMuX2Zvcm1hdERhdGUoc2VsZWN0ZWQuZW5kKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlucHV0RmllbGREYXRlID0gJyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlucHV0RmllbGREYXRlID0gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY2hhbmdlRGV0ZWN0aW9uUmVmLmRldGVjdENoYW5nZXMoKTtcbiAgICAgICAgdGhpcy5pc0ludmFsaWREYXRlSW5wdXQgPSAhdGhpcy5pc01vZGVsVmFsaWQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogTWV0aG9kLCB3aGljaCBpcyByZXNwb25zaWJsZSBmb3IgdHJhbnNmb3JtaW5nIHN0cmluZyB0byBkYXRlLCBkZXBlbmRpbmcgb24gdHlwZSBvclxuICAgICAqIHZhbGlkYXRpb24gdGhlIHJlc3VsdHMgYXJlIGRpZmZlcmVudC4gSXQgYWxzbyBjaGFuZ2VzIHRvIHN0YXRlIG9mIGlzSW52YWxpZERhdGVJbnB1dFxuICAgICAqL1xuICAgIGRhdGVTdHJpbmdVcGRhdGUoZGF0ZTogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIHRoaXMuaW5wdXRGaWVsZERhdGUgPSBkYXRlO1xuICAgICAgICAvKiogQ2FzZSB3aGVuIHRoZXJlIGlzIHNpbmdsZSBtb2RlICovXG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT09ICdzaW5nbGUnKSB7XG5cbiAgICAgICAgICAgIGxldCBmZERhdGUgPSB0aGlzLmRhdGVBZGFwdGVyLnBhcnNlKGRhdGUpO1xuXG4gICAgICAgICAgICAvKiogQ2hlY2sgaWYgZGF0ZXMgYXJlIGVxdWFsLCBpZiBzbywgdGhlcmUgaXMgbm8gbmVlZCB0byBtYWtlIGFueSBjaGFuZ2VzICovXG4gICAgICAgICAgICBpZiAoIUNhbGVuZGFyU2VydmljZS5kYXRlc0VxdWFsKGZkRGF0ZSwgdGhpcy5zZWxlY3RlZERhdGUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pc0ludmFsaWREYXRlSW5wdXQgPSAhdGhpcy5faXNTaW5nbGVNb2RlbFZhbGlkKGZkRGF0ZSk7XG5cbiAgICAgICAgICAgICAgICAvKiogQ2hlY2sgaWYgZGF0ZSBpcyB2YWxpZCwgaWYgaXQncyBub3QsIHRoZXJlIGlzIG5vIG5lZWQgdG8gcmVmcmVzaCBjYWxlbmRhciAqL1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5pc0ludmFsaWREYXRlSW5wdXQgJiYgZGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZWZyZXNoQ3VycmVudGx5RGlzcGxheWVkQ2FsZW5kYXJEYXRlKGZkRGF0ZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLyoqIFdoZXRoZXIgc3RyaW5nIGlzIGludmFsaWQsIGJ5IHBhc3NlZCBibG9jayBvciBkaXNhYmxlIGZ1bmN0aW9ucyB0aGVyZSBpcyBmb3JjZWQgSW52YWxpZCBPYmplY3QsICovXG4gICAgICAgICAgICAgICAgICAgIGZkRGF0ZSA9IHRoaXMuX2ludmFsaWREYXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIERhdGUgaW4gbW9kZWwgaXMgY2hhbmdlZCBubyBtYXR0ZXIgaWYgdGhlIHBhcnNlZCBkYXRlIGZyb20gc3RyaW5nIGlzIHZhbGlkIG9yIG5vdC5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkRGF0ZSA9IGZkRGF0ZTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uQ2hhbmdlKHRoaXMuc2VsZWN0ZWREYXRlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkRGF0ZUNoYW5nZS5lbWl0KHRoaXMuc2VsZWN0ZWREYXRlKTtcbiAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICAvKiogQ2FzZSB3aGVuIHRoZXJlIGlzIHJhbmdlIG1vZGUgKi9cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnREYXRlcyA9IGRhdGUuc3BsaXQodGhpcy5kYXRlQWRhcHRlci5yYW5nZURlbGltaXRlcik7XG4gICAgICAgICAgICBjb25zdCBmaXJzdERhdGUgPSB0aGlzLmRhdGVBZGFwdGVyLnBhcnNlKGN1cnJlbnREYXRlc1swXSk7XG4gICAgICAgICAgICBjb25zdCBzZWNvbmREYXRlID0gdGhpcy5kYXRlQWRhcHRlci5wYXJzZShjdXJyZW50RGF0ZXNbMV0pO1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIENoZWNrIGlmIGRhdGVzIGFyZSBlcXVhbCwgaWYgZGF0ZXMgYXJlIHRoZSBzYW1lIHRoZXJlIGlzIG5vIG5lZWQgdG8gbWFrZSBhbnkgY2hhbmdlc1xuICAgICAgICAgICAgICogRGF0ZSBpbiBtb2RlbCBpcyBjaGFuZ2VkIG5vIG1hdHRlciBpZiB0aGUgcGFyc2VkIGRhdGVzIGZyb20gc3RyaW5nIGFyZSB2YWxpZCBvciBub3QuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmICghQ2FsZW5kYXJTZXJ2aWNlLmRhdGVzRXF1YWwoZmlyc3REYXRlLCB0aGlzLnNlbGVjdGVkUmFuZ2VEYXRlLnN0YXJ0KSB8fFxuICAgICAgICAgICAgICAgICFDYWxlbmRhclNlcnZpY2UuZGF0ZXNFcXVhbChzZWNvbmREYXRlLCB0aGlzLnNlbGVjdGVkUmFuZ2VEYXRlLmVuZCkpIHtcblxuICAgICAgICAgICAgICAgIGxldCBzZWxlY3RlZFJhbmdlRGF0ZTogRmRSYW5nZURhdGUgPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgLyoqIElmIHRoZSBlbmQgZGF0ZSBpcyBiZWZvcmUgdGhlIHN0YXJ0IGRhdGUsIHRoZXJlIGlzIG5lZWQgdG8gcmVwbGFjZSB0aGVtICAqL1xuICAgICAgICAgICAgICAgIGlmICgoZmlyc3REYXRlLmdldFRpbWVTdGFtcCgpID4gc2Vjb25kRGF0ZS5nZXRUaW1lU3RhbXAoKSkgJiYgc2Vjb25kRGF0ZS5pc0RhdGVWYWxpZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkUmFuZ2VEYXRlID0geyBzdGFydDogc2Vjb25kRGF0ZSwgZW5kOiBmaXJzdERhdGUgfTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZFJhbmdlRGF0ZSA9IHsgc3RhcnQ6IGZpcnN0RGF0ZSwgZW5kOiBzZWNvbmREYXRlIH07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5pc0ludmFsaWREYXRlSW5wdXQgPSAhdGhpcy5faXNSYW5nZU1vZGVsVmFsaWQoc2VsZWN0ZWRSYW5nZURhdGUpO1xuXG4gICAgICAgICAgICAgICAgLyoqIElmIHN0YXJ0IGRhdGUgaXMgaW52YWxpZCwgYmVjYXVzZSBvZiBmb3JtYXQsIGJsb2NrIG9yIGRpc2FibGUgZnVuY3Rpb24sIHRoZXJlIGlzIGludmFsaWREYXRlIGZvcmNlZCAqL1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5faXNTdGFydERhdGVWYWxpZChzZWxlY3RlZFJhbmdlRGF0ZS5zdGFydCkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRSYW5nZURhdGUuc3RhcnQgPSB0aGlzLl9pbnZhbGlkRGF0ZSgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8qKiBJZiBlbmQgZGF0ZSBpcyBpbnZhbGlkLCBiZWNhdXNlIG9mIGZvcm1hdCwgYmxvY2sgb3IgZGlzYWJsZSBmdW5jdGlvbiwgdGhlcmUgaXMgaW52YWxpZERhdGUgZm9yY2VkICovXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9pc0VuZERhdGVWYWxpZChzZWxlY3RlZFJhbmdlRGF0ZS5lbmQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkUmFuZ2VEYXRlLmVuZCA9IHRoaXMuX2ludmFsaWREYXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLyoqIFdob2xlIG9iamVjdCBpcyBjaGFuZ2VkLCBldmVuIGl0J3MgaW52YWxpZCAqL1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRSYW5nZURhdGUgPSBzZWxlY3RlZFJhbmdlRGF0ZTtcblxuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRSYW5nZURhdGVDaGFuZ2UuZW1pdCh0aGlzLnNlbGVjdGVkUmFuZ2VEYXRlKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uQ2hhbmdlKHRoaXMuc2VsZWN0ZWRSYW5nZURhdGUpO1xuXG4gICAgICAgICAgICAgICAgLyoqIENoZWNrIGlmIHN0YXJ0IGRhdGUgaXMgdmFsaWQsIGlmIGl0J3Mgbm90LCB0aGVyZSBpcyBubyBuZWVkIG8gcmVmcmVzaCBjYWxlbmRhciAqL1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pc1N0YXJ0RGF0ZVZhbGlkKHRoaXMuc2VsZWN0ZWRSYW5nZURhdGUuc3RhcnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlZnJlc2hDdXJyZW50bHlEaXNwbGF5ZWRDYWxlbmRhckRhdGUodGhpcy5zZWxlY3RlZFJhbmdlRGF0ZS5zdGFydCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFkYXRlICYmIHRoaXMuYWxsb3dOdWxsKSB7XG4gICAgICAgICAgICB0aGlzLmlzSW52YWxpZERhdGVJbnB1dCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIE1ldGhvZCB0aGF0IHByb3ZpZGVzIGluZm9ybWF0aW9uIGlmIG1vZGVsIHNlbGVjdGVkIGRhdGUvZGF0ZXMgaGF2ZSBwcm9wZXJseSB0eXBlcyBhbmQgYXJlIHZhbGlkICovXG4gICAgcHVibGljIGlzTW9kZWxWYWxpZCgpOiBib29sZWFuIHtcbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ3NpbmdsZScpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pc1NpbmdsZU1vZGVsVmFsaWQodGhpcy5zZWxlY3RlZERhdGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lzUmFuZ2VNb2RlbFZhbGlkKHRoaXMuc2VsZWN0ZWRSYW5nZURhdGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIE1ldGhvZCB0aGF0IHJldHVybnMgaW5mbyBpZiBzaW5nbGUgbW9kZWwgZ2l2ZW4gaXMgdmFsaWQgKi9cbiAgICBwcml2YXRlIF9pc1NpbmdsZU1vZGVsVmFsaWQoZmREYXRlOiBGZERhdGUpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHRoaXMuX2lzRmREYXRlVmFsaWQoZmREYXRlKSAmJlxuICAgICAgICAgICAgIXRoaXMuZGlzYWJsZUZ1bmN0aW9uKGZkRGF0ZSkgJiZcbiAgICAgICAgICAgICF0aGlzLmJsb2NrRnVuY3Rpb24oZmREYXRlKVxuICAgICAgICApIHx8ICghdGhpcy5pbnB1dEZpZWxkRGF0ZSAmJiB0aGlzLmFsbG93TnVsbCk7XG4gICAgfVxuXG4gICAgLyoqIE1ldGhvZCB0aGF0IHJldHVybnMgaW5mbyBpZiByYW5nZSBkYXRlIG1vZGVsIGdpdmVuIGlzIHZhbGlkICovXG4gICAgcHJpdmF0ZSBfaXNSYW5nZU1vZGVsVmFsaWQoZmRSYW5nZURhdGU6IEZkUmFuZ2VEYXRlKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiAoZmRSYW5nZURhdGUgJiZcbiAgICAgICAgICAgICAgICB0aGlzLl9pc1N0YXJ0RGF0ZVZhbGlkKGZkUmFuZ2VEYXRlLnN0YXJ0KSAmJlxuICAgICAgICAgICAgICAgIHRoaXMuX2lzRW5kRGF0ZVZhbGlkKGZkUmFuZ2VEYXRlLmVuZClcbiAgICAgICAgICAgICkgfHwgKCF0aGlzLmlucHV0RmllbGREYXRlICYmIHRoaXMuYWxsb3dOdWxsKTtcbiAgICB9XG5cbiAgICAvKiogTWV0aG9kIHRoYXQgcmV0dXJucyBpbmZvIGlmIGVuZCBkYXRlIG1vZGVsIGdpdmVuIGlzIHZhbGlkICovXG4gICAgcHJpdmF0ZSBfaXNFbmREYXRlVmFsaWQoZW5kRGF0ZTogRmREYXRlKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc0ZkRGF0ZVZhbGlkKGVuZERhdGUpICYmXG4gICAgICAgICAgICAhdGhpcy5kaXNhYmxlUmFuZ2VFbmRGdW5jdGlvbihlbmREYXRlKSAmJlxuICAgICAgICAgICAgIXRoaXMuYmxvY2tSYW5nZUVuZEZ1bmN0aW9uKGVuZERhdGUpO1xuICAgIH1cblxuICAgIC8qKiBNZXRob2QgdGhhdCByZXR1cm5zIGluZm8gaWYgc3RhcnQgZGF0ZSBtb2RlbCBnaXZlbiBpcyB2YWxpZCAqL1xuICAgIHByaXZhdGUgX2lzU3RhcnREYXRlVmFsaWQoc3RhcnREYXRlOiBGZERhdGUpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzRmREYXRlVmFsaWQoc3RhcnREYXRlKSAmJlxuICAgICAgICAgICAgIXRoaXMuZGlzYWJsZVJhbmdlU3RhcnRGdW5jdGlvbihzdGFydERhdGUpICYmXG4gICAgICAgICAgICAhdGhpcy5ibG9ja1JhbmdlU3RhcnRGdW5jdGlvbihzdGFydERhdGUpO1xuICAgIH1cblxuICAgIC8qKiBNZXRob2QgdGhhdCByZXR1cm5zIGluZm8gaWYgZW5kIGRhdGUgbW9kZWwgZ2l2ZW4gaXMgdmFsaWQgKi9cbiAgICBwcml2YXRlIF9pc0ZkRGF0ZVZhbGlkKGZkRGF0ZTogRmREYXRlKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiBmZERhdGUgJiZcbiAgICAgICAgICAgIGZkRGF0ZSBpbnN0YW5jZW9mIEZkRGF0ZSAmJlxuICAgICAgICAgICAgZmREYXRlLmlzRGF0ZVZhbGlkKCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfaW52YWxpZERhdGUoKTogRmREYXRlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0ZUFkYXB0ZXIucGFyc2UoJ0luVmFMaUREYVRlJyk7XG4gICAgfVxuXG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBwcml2YXRlIF9yZWZyZXNoQ3VycmVudGx5RGlzcGxheWVkQ2FsZW5kYXJEYXRlKGRhdGU6IEZkRGF0ZSk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5jYWxlbmRhckNvbXBvbmVudCkge1xuICAgICAgICAgICAgdGhpcy5jYWxlbmRhckNvbXBvbmVudC5zZXRDdXJyZW50bHlEaXNwbGF5ZWQoZGF0ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogSWYgdGhlcmUgaXMgYW55IGZvcm1hdCBmdW5jdGlvbiBwcm92aWRlZCwgaXQgaXMgdXNlZC4gT3RoZXJ3aXNlIGRhdGUgZm9ybWF0IGZvbGxvd3MgYW5ndWxhciBEYXRlUGlwZSBmdW5jdGlvbmFsaXR5LlxuICAgICAqL1xuICAgIHByaXZhdGUgX2Zvcm1hdERhdGUoZmREYXRlOiBGZERhdGUpOiBzdHJpbmcge1xuXG4gICAgICAgIGNvbnN0IGN1c3RvbUZvcm1hdHRlZERhdGU6IHN0cmluZyA9IHRoaXMuZGF0ZUFkYXB0ZXIuZm9ybWF0KGZkRGF0ZSk7XG5cbiAgICAgICAgaWYgKGN1c3RvbUZvcm1hdHRlZERhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBjdXN0b21Gb3JtYXR0ZWREYXRlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGVQaXBlLnRyYW5zZm9ybShmZERhdGUudG9EYXRlKCksIHRoaXMuZm9ybWF0LCBudWxsLCB0aGlzLmxvY2FsZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbn1cbiJdfQ==