/**
 * @fileoverview added by tsickle
 * Generated from: lib/nested-list/nested-list-popover/nested-list-popover.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Component, ContentChild, HostBinding, ViewChild, ViewEncapsulation } from '@angular/core';
import { NestedLinkDirective } from '../nested-link/nested-link.directive';
import { NestedListKeyboardService } from '../nested-list-keyboard.service';
import { PopoverComponent } from '../../popover/popover.component';
export class NestedListPopoverComponent {
    /**
     * @hidden
     * @param {?} keyboardNestService
     */
    constructor(keyboardNestService) {
        this.keyboardNestService = keyboardNestService;
        /**
         * @hidden
         */
        this.popoverClass = true;
        /**
         * @hidden
         */
        this.open = false;
        this.keyboardNestService.refresh$.subscribe((/**
         * @return {?}
         */
        () => {
            /** Update popover position, on list of hidden items change */
            if (this.popoverComponent) {
                this.popoverComponent.updatePopover();
            }
        }));
    }
    /**
     * Method called, when open state is changed, from popover component (escape key, outside click).
     * @param {?} open
     * @return {?}
     */
    handleOpenChange(open) {
        this.open = open;
        if (this.parentItemElement) {
            if (open) {
                this.parentItemElement.triggerOpen();
            }
            else {
                this.parentItemElement.triggerClose();
            }
        }
    }
}
NestedListPopoverComponent.decorators = [
    { type: Component, args: [{
                selector: 'fd-nested-list-popover',
                template: "<fd-popover [placement]=\"'right-start'\" [triggers]=\"[]\" [noArrow]=\"false\" [isOpen]=\"open\" (isOpenChange)=\"handleOpenChange($event)\">\n    <fd-popover-control>\n        <ng-content select=\"[fd-nested-list-link]\"></ng-content>\n    </fd-popover-control>\n    <fd-popover-body class=\"fd-nested-list--text-only\">\n        <a fd-nested-list-link class=\"fd-nested-list__popover-header\">\n            <span fd-nested-list-title>{{linkDirective?.getTitle()}}</span>\n        </a>\n        <ng-content select=\"[fd-nested-list]\"></ng-content>\n        <ng-content select=\"fd-prepared-nested-list\"></ng-content>\n    </fd-popover-body>\n</fd-popover>\n",
                encapsulation: ViewEncapsulation.None,
                styles: [".fd-side-nav--condensed .fd-popover-container-custom .fd-nested-list__title{display:inline-block}.fd-side-nav--condensed .fd-nested-list__popover-header{box-shadow:0 0 .25rem 0 rgba(0,0,0,.15),inset 0 -.0625rem 0 0 #d9d9d9}"]
            }] }
];
/** @nocollapse */
NestedListPopoverComponent.ctorParameters = () => [
    { type: NestedListKeyboardService }
];
NestedListPopoverComponent.propDecorators = {
    popoverComponent: [{ type: ViewChild, args: [PopoverComponent, { static: false },] }],
    popoverClass: [{ type: HostBinding, args: ['class.fd-nested-list__popover',] }],
    linkDirective: [{ type: ContentChild, args: [NestedLinkDirective, { static: false },] }]
};
if (false) {
    /**
     * @hidden
     * @type {?}
     */
    NestedListPopoverComponent.prototype.popoverComponent;
    /**
     * @hidden
     * @type {?}
     */
    NestedListPopoverComponent.prototype.popoverClass;
    /**
     * @hidden
     * @type {?}
     */
    NestedListPopoverComponent.prototype.linkDirective;
    /**
     * @hidden
     * Reference to parent item, to propagate open and close change from popover.
     * @type {?}
     */
    NestedListPopoverComponent.prototype.parentItemElement;
    /**
     * @hidden
     * @type {?}
     */
    NestedListPopoverComponent.prototype.open;
    /**
     * @type {?}
     * @private
     */
    NestedListPopoverComponent.prototype.keyboardNestService;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmVzdGVkLWxpc3QtcG9wb3Zlci5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AZnVuZGFtZW50YWwtbmd4L2NvcmUvIiwic291cmNlcyI6WyJsaWIvbmVzdGVkLWxpc3QvbmVzdGVkLWxpc3QtcG9wb3Zlci9uZXN0ZWQtbGlzdC1wb3BvdmVyLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQUUsWUFBWSxFQUFFLFdBQVcsRUFBRSxTQUFTLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFFbkcsT0FBTyxFQUFFLG1CQUFtQixFQUFFLE1BQU0sc0NBQXNDLENBQUM7QUFDM0UsT0FBTyxFQUFFLHlCQUF5QixFQUFFLE1BQU0saUNBQWlDLENBQUM7QUFDNUUsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0saUNBQWlDLENBQUM7QUFRbkUsTUFBTSxPQUFPLDBCQUEwQjs7Ozs7SUFlbkMsWUFDWSxtQkFBOEM7UUFBOUMsd0JBQW1CLEdBQW5CLG1CQUFtQixDQUEyQjs7OztRQVIxRCxpQkFBWSxHQUFZLElBQUksQ0FBQzs7OztRQTJCN0IsU0FBSSxHQUFZLEtBQUssQ0FBQztRQWpCbEIsSUFBSSxDQUFDLG1CQUFtQixDQUFDLFFBQVEsQ0FBQyxTQUFTOzs7UUFBQyxHQUFHLEVBQUU7WUFDN0MsOERBQThEO1lBQzlELElBQUksSUFBSSxDQUFDLGdCQUFnQixFQUFFO2dCQUN2QixJQUFJLENBQUMsZ0JBQWdCLENBQUMsYUFBYSxFQUFFLENBQUM7YUFDekM7UUFDTCxDQUFDLEVBQUMsQ0FBQztJQUNQLENBQUM7Ozs7OztJQWdCRCxnQkFBZ0IsQ0FBQyxJQUFhO1FBQzFCLElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDO1FBQ2pCLElBQUksSUFBSSxDQUFDLGlCQUFpQixFQUFFO1lBQ3hCLElBQUksSUFBSSxFQUFFO2dCQUNOLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxXQUFXLEVBQUUsQ0FBQzthQUN4QztpQkFBTTtnQkFDSCxJQUFJLENBQUMsaUJBQWlCLENBQUMsWUFBWSxFQUFFLENBQUM7YUFDekM7U0FDSjtJQUNMLENBQUM7OztZQXZESixTQUFTLFNBQUM7Z0JBQ1AsUUFBUSxFQUFFLHdCQUF3QjtnQkFDbEMsaXFCQUFtRDtnQkFFbkQsYUFBYSxFQUFFLGlCQUFpQixDQUFDLElBQUk7O2FBQ3hDOzs7O1lBUlEseUJBQXlCOzs7K0JBWTdCLFNBQVMsU0FBQyxnQkFBZ0IsRUFBRSxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUU7MkJBSTdDLFdBQVcsU0FBQywrQkFBK0I7NEJBSTNDLFlBQVksU0FBQyxtQkFBbUIsRUFBRSxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUU7Ozs7Ozs7SUFScEQsc0RBQ21DOzs7OztJQUduQyxrREFDNkI7Ozs7O0lBRzdCLG1EQUNtQzs7Ozs7O0lBa0JuQyx1REFBdUM7Ozs7O0lBS3ZDLDBDQUFzQjs7Ozs7SUFuQmxCLHlEQUFzRCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbXBvbmVudCwgQ29udGVudENoaWxkLCBIb3N0QmluZGluZywgVmlld0NoaWxkLCBWaWV3RW5jYXBzdWxhdGlvbiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgTmVzdGVkSXRlbURpcmVjdGl2ZSB9IGZyb20gJy4uL25lc3RlZC1pdGVtL25lc3RlZC1pdGVtLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBOZXN0ZWRMaW5rRGlyZWN0aXZlIH0gZnJvbSAnLi4vbmVzdGVkLWxpbmsvbmVzdGVkLWxpbmsuZGlyZWN0aXZlJztcbmltcG9ydCB7IE5lc3RlZExpc3RLZXlib2FyZFNlcnZpY2UgfSBmcm9tICcuLi9uZXN0ZWQtbGlzdC1rZXlib2FyZC5zZXJ2aWNlJztcbmltcG9ydCB7IFBvcG92ZXJDb21wb25lbnQgfSBmcm9tICcuLi8uLi9wb3BvdmVyL3BvcG92ZXIuY29tcG9uZW50JztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdmZC1uZXN0ZWQtbGlzdC1wb3BvdmVyJyxcbiAgICB0ZW1wbGF0ZVVybDogJy4vbmVzdGVkLWxpc3QtcG9wb3Zlci5jb21wb25lbnQuaHRtbCcsXG4gICAgc3R5bGVVcmxzOiBbJy4vbmVzdGVkLWxpc3QtcG9wb3Zlci5jb21wb25lbnQuc2NzcyddLFxuICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmVcbn0pXG5leHBvcnQgY2xhc3MgTmVzdGVkTGlzdFBvcG92ZXJDb21wb25lbnQge1xuXG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBAVmlld0NoaWxkKFBvcG92ZXJDb21wb25lbnQsIHsgc3RhdGljOiBmYWxzZSB9KVxuICAgIHBvcG92ZXJDb21wb25lbnQ6IFBvcG92ZXJDb21wb25lbnQ7XG5cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIEBIb3N0QmluZGluZygnY2xhc3MuZmQtbmVzdGVkLWxpc3RfX3BvcG92ZXInKVxuICAgIHBvcG92ZXJDbGFzczogYm9vbGVhbiA9IHRydWU7XG5cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIEBDb250ZW50Q2hpbGQoTmVzdGVkTGlua0RpcmVjdGl2ZSwgeyBzdGF0aWM6IGZhbHNlIH0pXG4gICAgbGlua0RpcmVjdGl2ZTogTmVzdGVkTGlua0RpcmVjdGl2ZTtcblxuICAgIC8qKiBAaGlkZGVuICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIHByaXZhdGUga2V5Ym9hcmROZXN0U2VydmljZTogTmVzdGVkTGlzdEtleWJvYXJkU2VydmljZVxuICAgICkge1xuICAgICAgICB0aGlzLmtleWJvYXJkTmVzdFNlcnZpY2UucmVmcmVzaCQuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgICAgIC8qKiBVcGRhdGUgcG9wb3ZlciBwb3NpdGlvbiwgb24gbGlzdCBvZiBoaWRkZW4gaXRlbXMgY2hhbmdlICovXG4gICAgICAgICAgICBpZiAodGhpcy5wb3BvdmVyQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3BvdmVyQ29tcG9uZW50LnVwZGF0ZVBvcG92ZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIFJlZmVyZW5jZSB0byBwYXJlbnQgaXRlbSwgdG8gcHJvcGFnYXRlIG9wZW4gYW5kIGNsb3NlIGNoYW5nZSBmcm9tIHBvcG92ZXIuXG4gICAgICovXG4gICAgcGFyZW50SXRlbUVsZW1lbnQ6IE5lc3RlZEl0ZW1EaXJlY3RpdmU7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgb3BlbjogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIGNhbGxlZCwgd2hlbiBvcGVuIHN0YXRlIGlzIGNoYW5nZWQsIGZyb20gcG9wb3ZlciBjb21wb25lbnQgKGVzY2FwZSBrZXksIG91dHNpZGUgY2xpY2spLlxuICAgICAqL1xuICAgIGhhbmRsZU9wZW5DaGFuZ2Uob3BlbjogYm9vbGVhbik6IHZvaWQge1xuICAgICAgICB0aGlzLm9wZW4gPSBvcGVuO1xuICAgICAgICBpZiAodGhpcy5wYXJlbnRJdGVtRWxlbWVudCkge1xuICAgICAgICAgICAgaWYgKG9wZW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudEl0ZW1FbGVtZW50LnRyaWdnZXJPcGVuKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50SXRlbUVsZW1lbnQudHJpZ2dlckNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG4iXX0=