/**
 * @fileoverview added by tsickle
 * Generated from: lib/mega-menu/mega-menu-item/mega-menu-item.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { ChangeDetectionStrategy, ChangeDetectorRef, Component, ContentChild, ContentChildren, ElementRef, EventEmitter, HostListener, Input, Output, QueryList, ViewChild, ViewEncapsulation } from '@angular/core';
import { MegaMenuSubitemDirective } from '../mega-menu-subitem.directive';
import { MegaMenuLinkDirective } from '../mega-menu-link/mega-menu-link.directive';
import { MenuKeyboardService } from '../../menu/menu-keyboard.service';
import { merge, Subject } from 'rxjs';
import { startWith, takeUntil } from 'rxjs/operators';
/**
 *  Component represents mega menu item, which contains subitems and link.
 *  ```html
 *  <fd-mega-menu-item>
 *      <a fd-mega-menu-link>Item 0</a>
 *      <li fd-mega-menu-subitem>
 *          <a fd-mega-menu-sublink>Sub Item 1</a>
 *      </li>
 *      <li fd-mega-menu-subitem>
 *          <a fd-mega-menu-sublink>Sub Item 2</a>
 *      </li>
 *      <li fd-mega-menu-subitem>
 *          <a fd-mega-menu-sublink>Sub Item 3</a>
 *      </li>
 *  </fd-mega-menu-item>
 *  ```
 *
 */
export class MegaMenuItemComponent {
    /**
     * @hidden
     * @param {?} elRef
     * @param {?} menuKeyboardService
     * @param {?} changeDetectionRef
     */
    constructor(elRef, menuKeyboardService, changeDetectionRef) {
        this.elRef = elRef;
        this.menuKeyboardService = menuKeyboardService;
        this.changeDetectionRef = changeDetectionRef;
        /**
         * Event thrown, when there is some keyboard event detected on mega menu item
         */
        this.keyDown = new EventEmitter();
        /**
         * An RxJS Subject that will kill the data stream upon component’s destruction (for unsubscribing)
         */
        this.onDestroy$ = new Subject();
        /**
         * An RxJS Subject that will kill the data stream upon queryList changes (for unsubscribing)
         */
        this.onRefresh$ = new Subject();
        /**
         * Variable that specifies if the sublist menu is opened.
         */
        this.open = false;
        /**
         * Defines what should be position for sublist
         */
        this.subListPosition = 'right';
        /**
         * Event that is thrown always, when the open variable is changed
         */
        this.openChange = new EventEmitter();
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    handleKeyboardEvent(event) {
        switch (event.key) {
            case ('ArrowLeft'): {
                this.closeSubList();
                this.link.focus();
                break;
            }
            case ('ArrowRight'):
            case (' '):
            case ('Enter'): {
                this.openSubList();
                this.changeDetectionRef.detectChanges();
                if (this.subItems.first) {
                    this.subItems.first.focus();
                }
                event.preventDefault();
                break;
            }
            default: {
                this.keyDown.emit(event);
            }
        }
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    clickHandler(event) {
        /** Check if click wasn't inside the component, then close. */
        if (!this.elRef.nativeElement.contains(event.target)) {
            this.closeSubList();
        }
    }
    /**
     * @hidden
     * @return {?}
     */
    onResize() {
        if (this.open && this.isSubListPositionRight()) {
            this.changeDetectionRef.detectChanges();
            /** @type {?} */
            let distanceFromCorner = this.subList.nativeElement.getBoundingClientRect().right;
            /**
             * When the page is resized and the menu sub list goes beyond the page,
             * the sub list should go over the parent list
             */
            while (distanceFromCorner > window.innerWidth && this.getLeftPropertyFromSubList() > 1) {
                this.subList.nativeElement.style.left = (this.getLeftPropertyFromSubList() - 1) + '%';
                this.changeDetectionRef.detectChanges();
                distanceFromCorner = this.subList.nativeElement.getBoundingClientRect().right;
            }
            /**
             * When the page is resized and the menu sub list was pulled over parent list,
             * the sub list should go to right side of parent list
             */
            while (distanceFromCorner < window.innerWidth && this.getLeftPropertyFromSubList() < 100) {
                this.subList.nativeElement.style.left = (this.getLeftPropertyFromSubList() + 1) + '%';
                this.changeDetectionRef.detectChanges();
                distanceFromCorner = this.subList.nativeElement.getBoundingClientRect().right;
            }
        }
    }
    /**
     * @hidden
     * @return {?}
     */
    ngAfterContentInit() {
        this.link.hasChild = this.subItems.length > 0;
        this.subItems.changes
            .pipe(takeUntil(this.onDestroy$), startWith(5))
            .subscribe((/**
         * @return {?}
         */
        () => this.refreshSubscription()));
    }
    /**
     * @hidden
     * @return {?}
     */
    ngOnDestroy() {
        this.onDestroy$.next();
        this.onDestroy$.complete();
    }
    /**
     * Keyboard events handler from sublist, the event doesn't propagate upper, when it was ArrowDown or ArrowUp.
     * It prevents from changing focus to item on primary menu list
     * @param {?} event
     * @param {?} index
     * @return {?}
     */
    handleSubListKeyDown(event, index) {
        this.menuKeyboardService.keyDownHandler(event, index, this.subItems.toArray());
        if (event.key === 'ArrowDown' || event.key === 'ArrowUp') {
            event.stopPropagation();
        }
    }
    /**
     * @hidden
     * @return {?}
     */
    click() {
        this.link.click();
    }
    /**
     * @hidden
     * @return {?}
     */
    focus() {
        this.link.focus();
    }
    /**
     * Method that informs if actual position of sublist is set to right
     * @return {?}
     */
    isSubListPositionRight() {
        return this.subListPosition === 'right';
    }
    /**
     * Method that changes state of open variable
     * @return {?}
     */
    toggleOpen() {
        if (this.open) {
            this.closeSubList();
        }
        else {
            this.openSubList();
        }
    }
    /**
     * Method that closes sublist
     * @return {?}
     */
    closeSubList() {
        this.open = false;
        this.link.isExpanded = this.isShow();
        this.openChange.emit(this.open);
    }
    /**
     * Method that opens sublist
     * @return {?}
     */
    openSubList() {
        this.open = true;
        this.link.isExpanded = this.isShow();
        this.openChange.emit(this.open);
        this.onResize();
    }
    /**
     * Method that gives information if the sublist should behave like it is opened.
     * @return {?}
     */
    isShow() {
        return this.open && this.subItems.length > 0;
    }
    /**
     * Method that helps with the responsive support. Gives percentage number of left css attribute on list.
     * @private
     * @return {?}
     */
    getLeftPropertyFromSubList() {
        /** @type {?} */
        const styles = getComputedStyle(this.subList.nativeElement);
        if (styles.left) {
            if (styles.left.includes('px')) {
                return Number(styles.left.split('px')[0]) / this.parentElement.nativeElement.offsetWidth * 100;
            }
            else if (styles.left.includes('%')) {
                return Number(styles.left.split('%')[0]);
            }
        }
        else {
            return 100;
        }
    }
    /**
     * Whether any querylist detects any changes
     * @private
     * @return {?}
     */
    refreshSubscription() {
        /** Finish all of the streams, form before */
        this.onRefresh$.next();
        /**
         * Merge refresh/destroy observables
         * @type {?}
         */
        const refreshObs = merge(this.onRefresh$, this.onDestroy$);
        this.subItems.forEach((/**
         * @param {?} item
         * @param {?} index
         * @return {?}
         */
        (item, index) => item.keyDown
            .pipe(takeUntil(this.onDestroy$))
            .subscribe((/**
         * @param {?} keyboardEvent
         * @return {?}
         */
        (keyboardEvent) => this.handleSubListKeyDown(keyboardEvent, index)))));
    }
}
MegaMenuItemComponent.decorators = [
    { type: Component, args: [{
                selector: 'fd-mega-menu-item',
                template: "<li class=\"fd-mega-menu__item\" (click)=\"toggleOpen()\" #parentElement>\n    <ng-content select=\"[fd-mega-menu-link]\"></ng-content>\n    <ng-content></ng-content>\n    <ul class=\"fd-mega-menu__sublist\"\n        #subList\n        [attr.aria-hidden]=\"!isShow()\"\n        [ngClass]=\"{'fd-mega-menu__sublist--left': !isSubListPositionRight()}\"\n        (click)=\"$event.stopPropagation()\">\n        <ng-content select=\"[fd-mega-menu-subitem]\"></ng-content>\n    </ul>\n</li>\n",
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [".fd-mega-menu__sublist{right:initial;left:100%;z-index:2;margin-top:4px}.fd-mega-menu__sublist--left{right:100%;left:initial}.fd-mega-menu__item{cursor:pointer}.fd-mega-menu__item .fd-mega-menu__link{position:relative}.fd-mega-menu__item .fd-mega-menu__link:focus{z-index:1}ul.fd-mega-menu__sublist{margin-left:-4px}"]
            }] }
];
/** @nocollapse */
MegaMenuItemComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: MenuKeyboardService },
    { type: ChangeDetectorRef }
];
MegaMenuItemComponent.propDecorators = {
    subItems: [{ type: ContentChildren, args: [MegaMenuSubitemDirective,] }],
    link: [{ type: ContentChild, args: [MegaMenuLinkDirective, { static: false },] }],
    subList: [{ type: ViewChild, args: ['subList', { static: false },] }],
    parentElement: [{ type: ViewChild, args: ['parentElement', { static: false },] }],
    keyDown: [{ type: Output }],
    open: [{ type: Input }],
    subListPosition: [{ type: Input }],
    openChange: [{ type: Output }],
    handleKeyboardEvent: [{ type: HostListener, args: ['keydown', ['$event'],] }],
    clickHandler: [{ type: HostListener, args: ['document:click', ['$event'],] }],
    onResize: [{ type: HostListener, args: ['window:resize',] }]
};
if (false) {
    /**
     * @hidden
     * @type {?}
     */
    MegaMenuItemComponent.prototype.subItems;
    /**
     * @hidden
     * @type {?}
     */
    MegaMenuItemComponent.prototype.link;
    /**
     * @hidden
     * @type {?}
     */
    MegaMenuItemComponent.prototype.subList;
    /**
     * @hidden
     * @type {?}
     */
    MegaMenuItemComponent.prototype.parentElement;
    /**
     * Event thrown, when there is some keyboard event detected on mega menu item
     * @type {?}
     */
    MegaMenuItemComponent.prototype.keyDown;
    /**
     * An RxJS Subject that will kill the data stream upon component’s destruction (for unsubscribing)
     * @type {?}
     * @private
     */
    MegaMenuItemComponent.prototype.onDestroy$;
    /**
     * An RxJS Subject that will kill the data stream upon queryList changes (for unsubscribing)
     * @type {?}
     * @private
     */
    MegaMenuItemComponent.prototype.onRefresh$;
    /**
     * Variable that specifies if the sublist menu is opened.
     * @type {?}
     */
    MegaMenuItemComponent.prototype.open;
    /**
     * Defines what should be position for sublist
     * @type {?}
     */
    MegaMenuItemComponent.prototype.subListPosition;
    /**
     * Event that is thrown always, when the open variable is changed
     * @type {?}
     */
    MegaMenuItemComponent.prototype.openChange;
    /**
     * @type {?}
     * @private
     */
    MegaMenuItemComponent.prototype.elRef;
    /**
     * @type {?}
     * @private
     */
    MegaMenuItemComponent.prototype.menuKeyboardService;
    /**
     * @type {?}
     * @private
     */
    MegaMenuItemComponent.prototype.changeDetectionRef;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWVnYS1tZW51LWl0ZW0uY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6Im5nOi8vQGZ1bmRhbWVudGFsLW5neC9jb3JlLyIsInNvdXJjZXMiOlsibGliL21lZ2EtbWVudS9tZWdhLW1lbnUtaXRlbS9tZWdhLW1lbnUtaXRlbS5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxPQUFPLEVBQ2UsdUJBQXVCLEVBQ3pDLGlCQUFpQixFQUNqQixTQUFTLEVBQ1QsWUFBWSxFQUNaLGVBQWUsRUFDZixVQUFVLEVBQ1YsWUFBWSxFQUNaLFlBQVksRUFDWixLQUFLLEVBRUwsTUFBTSxFQUNOLFNBQVMsRUFDVCxTQUFTLEVBQ1QsaUJBQWlCLEVBQ3BCLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBRSx3QkFBd0IsRUFBRSxNQUFNLGdDQUFnQyxDQUFDO0FBQzFFLE9BQU8sRUFBRSxxQkFBcUIsRUFBRSxNQUFNLDRDQUE0QyxDQUFDO0FBQ25GLE9BQU8sRUFBRSxtQkFBbUIsRUFBRSxNQUFNLGtDQUFrQyxDQUFDO0FBQ3ZFLE9BQU8sRUFBRSxLQUFLLEVBQUUsT0FBTyxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQ3RDLE9BQU8sRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE2QnRELE1BQU0sT0FBTyxxQkFBcUI7Ozs7Ozs7SUEwQzlCLFlBQ1ksS0FBaUIsRUFDakIsbUJBQXdDLEVBQ3hDLGtCQUFxQztRQUZyQyxVQUFLLEdBQUwsS0FBSyxDQUFZO1FBQ2pCLHdCQUFtQixHQUFuQixtQkFBbUIsQ0FBcUI7UUFDeEMsdUJBQWtCLEdBQWxCLGtCQUFrQixDQUFtQjs7OztRQXpCeEMsWUFBTyxHQUFnQyxJQUFJLFlBQVksRUFBaUIsQ0FBQzs7OztRQUdqRSxlQUFVLEdBQWtCLElBQUksT0FBTyxFQUFRLENBQUM7Ozs7UUFHaEQsZUFBVSxHQUFrQixJQUFJLE9BQU8sRUFBUSxD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WSxTQUFDLFNBQVMsRUFBRSxDQUFDLFFBQVEsQ0FBQzsyQkEwQmxDLFlBQVksU0FBQyxnQkFBZ0IsRUFBRSxDQUFDLFFBQVEsQ0FBQzt1QkFTekMsWUFBWSxTQUFDLGVBQWU7Ozs7Ozs7SUFqRjdCLHlDQUM4Qzs7Ozs7SUFHOUMscUNBQzRCOzs7OztJQUc1Qix3Q0FDb0I7Ozs7O0lBR3BCLDhDQUMwQjs7Ozs7SUFHMUIsd0NBQ2tGOzs7Ozs7SUFHbEYsMkNBQWlFOzs7Ozs7SUFHakUsMkNBQWlFOzs7OztJQUlqRSxxQ0FDc0I7Ozs7O0lBR3RCLGdEQUMrQzs7Ozs7SUFHL0MsMkNBQ3lFOzs7OztJQUlyRSxzQ0FBeUI7Ozs7O0lBQ3pCLG9EQUFnRDs7Ozs7SUFDaEQsbURBQTZDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgICBBZnRlckNvbnRlbnRJbml0LCBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcbiAgICBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICBDb21wb25lbnQsXG4gICAgQ29udGVudENoaWxkLFxuICAgIENvbnRlbnRDaGlsZHJlbixcbiAgICBFbGVtZW50UmVmLFxuICAgIEV2ZW50RW1pdHRlcixcbiAgICBIb3N0TGlzdGVuZXIsXG4gICAgSW5wdXQsXG4gICAgT25EZXN0cm95LFxuICAgIE91dHB1dCxcbiAgICBRdWVyeUxpc3QsXG4gICAgVmlld0NoaWxkLFxuICAgIFZpZXdFbmNhcHN1bGF0aW9uXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgTWVnYU1lbnVTdWJpdGVtRGlyZWN0aXZlIH0gZnJvbSAnLi4vbWVnYS1tZW51LXN1Yml0ZW0uZGlyZWN0aXZlJztcbmltcG9ydCB7IE1lZ2FNZW51TGlua0RpcmVjdGl2ZSB9IGZyb20gJy4uL21lZ2EtbWVudS1saW5rL21lZ2EtbWVudS1saW5rLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBNZW51S2V5Ym9hcmRTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vbWVudS9tZW51LWtleWJvYXJkLnNlcnZpY2UnO1xuaW1wb3J0IHsgbWVyZ2UsIFN1YmplY3QgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IHN0YXJ0V2l0aCwgdGFrZVVudGlsIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgRGVmYXVsdE1lbnVJdGVtIH0gZnJvbSAnLi4vLi4vbWVudS9kZWZhdWx0LW1lbnUtaXRlbSc7XG5cbmV4cG9ydCB0eXBlIE1lbnVTdWJMaXN0UG9zaXRpb24gPSAnbGVmdCcgfCAncmlnaHQnO1xuXG4vKipcbiAqICBDb21wb25lbnQgcmVwcmVzZW50cyBtZWdhIG1lbnUgaXRlbSwgd2hpY2ggY29udGFpbnMgc3ViaXRlbXMgYW5kIGxpbmsuXG4gKiAgYGBgaHRtbFxuICogIDxmZC1tZWdhLW1lbnUtaXRlbT5cbiAqICAgICAgPGEgZmQtbWVnYS1tZW51LWxpbms+SXRlbSAwPC9hPlxuICogICAgICA8bGkgZmQtbWVnYS1tZW51LXN1Yml0ZW0+XG4gKiAgICAgICAgICA8YSBmZC1tZWdhLW1lbnUtc3VibGluaz5TdWIgSXRlbSAxPC9hPlxuICogICAgICA8L2xpPlxuICogICAgICA8bGkgZmQtbWVnYS1tZW51LXN1Yml0ZW0+XG4gKiAgICAgICAgICA8YSBmZC1tZWdhLW1lbnUtc3VibGluaz5TdWIgSXRlbSAyPC9hPlxuICogICAgICA8L2xpPlxuICogICAgICA8bGkgZmQtbWVnYS1tZW51LXN1Yml0ZW0+XG4gKiAgICAgICAgICA8YSBmZC1tZWdhLW1lbnUtc3VibGluaz5TdWIgSXRlbSAzPC9hPlxuICogICAgICA8L2xpPlxuICogIDwvZmQtbWVnYS1tZW51LWl0ZW0+XG4gKiAgYGBgXG4gKiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdmZC1tZWdhLW1lbnUtaXRlbScsXG4gICAgdGVtcGxhdGVVcmw6ICcuL21lZ2EtbWVudS1pdGVtLmNvbXBvbmVudC5odG1sJyxcbiAgICBzdHlsZVVybHM6IFsnLi9tZWdhLW1lbnUtaXRlbS5jb21wb25lbnQuc2NzcyddLFxuICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcbn0pXG5leHBvcnQgY2xhc3MgTWVnYU1lbnVJdGVtQ29tcG9uZW50IGltcGxlbWVudHMgQWZ0ZXJDb250ZW50SW5pdCwgT25EZXN0cm95LCBEZWZhdWx0TWVudUl0ZW0ge1xuXG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBAQ29udGVudENoaWxkcmVuKE1lZ2FNZW51U3ViaXRlbURpcmVjdGl2ZSlcbiAgICBzdWJJdGVtczogUXVlcnlMaXN0PE1lZ2FNZW51U3ViaXRlbURpcmVjdGl2ZT47XG5cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIEBDb250ZW50Q2hpbGQoTWVnYU1lbnVMaW5rRGlyZWN0aXZlLCB7IHN0YXRpYzogZmFsc2UgfSlcbiAgICBsaW5rOiBNZWdhTWVudUxpbmtEaXJlY3RpdmU7XG5cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIEBWaWV3Q2hpbGQoJ3N1Ykxpc3QnLCB7IHN0YXRpYzogZmFsc2UgfSlcbiAgICBzdWJMaXN0OiBFbGVtZW50UmVmO1xuXG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBAVmlld0NoaWxkKCdwYXJlbnRFbGVtZW50JywgeyBzdGF0aWM6IGZhbHNlIH0pXG4gICAgcGFyZW50RWxlbWVudDogRWxlbWVudFJlZjtcblxuICAgIC8qKiAgRXZlbnQgdGhyb3duLCB3aGVuIHRoZXJlIGlzIHNvbWUga2V5Ym9hcmQgZXZlbnQgZGV0ZWN0ZWQgb24gbWVnYSBtZW51IGl0ZW0gKi9cbiAgICBAT3V0cHV0KClcbiAgICByZWFkb25seSBrZXlEb3duOiBFdmVudEVtaXR0ZXI8S2V5Ym9hcmRFdmVudD4gPSBuZXcgRXZlbnRFbWl0dGVyPEtleWJvYXJkRXZlbnQ+KCk7XG5cbiAgICAvKiogQW4gUnhKUyBTdWJqZWN0IHRoYXQgd2lsbCBraWxsIHRoZSBkYXRhIHN0cmVhbSB1cG9uIGNvbXBvbmVudOKAmXMgZGVzdHJ1Y3Rpb24gKGZvciB1bnN1YnNjcmliaW5nKSAgKi9cbiAgICBwcml2YXRlIHJlYWRvbmx5IG9uRGVzdHJveSQ6IFN1YmplY3Q8dm9pZD4gPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuXG4gICAgLyoqIEFuIFJ4SlMgU3ViamVjdCB0aGF0IHdpbGwga2lsbCB0aGUgZGF0YSBzdHJlYW0gdXBvbiBxdWVyeUxpc3QgY2hhbmdlcyAoZm9yIHVuc3Vic2NyaWJpbmcpICAqL1xuICAgIHByaXZhdGUgcmVhZG9ubHkgb25SZWZyZXNoJDogU3ViamVjdDx2b2lkPiA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG5cblxuICAgIC8qKiBWYXJpYWJsZSB0aGF0IHNwZWNpZmllcyBpZiB0aGUgc3VibGlzdCBtZW51IGlzIG9wZW5lZC4gKi9cbiAgICBASW5wdXQoKVxuICAgIG9wZW46IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIC8qKiBEZWZpbmVzIHdoYXQgc2hvdWxkIGJlIHBvc2l0aW9uIGZvciBzdWJsaXN0ICovXG4gICAgQElucHV0KClcbiAgICBzdWJMaXN0UG9zaXRpb246IE1lbnVTdWJMaXN0UG9zaXRpb24gPSAncmlnaHQnO1xuXG4gICAgLyoqIEV2ZW50IHRoYXQgaXMgdGhyb3duIGFsd2F5cywgd2hlbiB0aGUgb3BlbiB2YXJpYWJsZSBpcyBjaGFuZ2VkICovXG4gICAgQE91dHB1dCgpXG4gICAgcmVhZG9ubHkgb3BlbkNoYW5nZTogRXZlbnRFbWl0dGVyPGJvb2xlYW4+ID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPigpO1xuXG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHJpdmF0ZSBlbFJlZjogRWxlbWVudFJlZixcbiAgICAgICAgcHJpdmF0ZSBtZW51S2V5Ym9hcmRTZXJ2aWNlOiBNZW51S2V5Ym9hcmRTZXJ2aWNlLFxuICAgICAgICBwcml2YXRlIGNoYW5nZURldGVjdGlvblJlZjogQ2hhbmdlRGV0ZWN0b3JSZWZcbiAgICApIHt9XG5cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIEBIb3N0TGlzdGVuZXIoJ2tleWRvd24nLCBbJyRldmVudCddKVxuICAgIGhhbmRsZUtleWJvYXJkRXZlbnQoZXZlbnQ6IEtleWJvYXJkRXZlbnQpOiB2b2lkIHtcbiAgICAgICAgc3dpdGNoIChldmVudC5rZXkpIHtcbiAgICAgICAgICAgIGNhc2UgKCdBcnJvd0xlZnQnKToge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xvc2VTdWJMaXN0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5saW5rLmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICgnQXJyb3dSaWdodCcpOlxuICAgICAgICAgICAgY2FzZSAoJyAnKTpcbiAgICAgICAgICAgIGNhc2UgKCdFbnRlcicpOiB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcGVuU3ViTGlzdCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlRGV0ZWN0aW9uUmVmLmRldGVjdENoYW5nZXMoKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdWJJdGVtcy5maXJzdCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN1Ykl0ZW1zLmZpcnN0LmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgdGhpcy5rZXlEb3duLmVtaXQoZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBASG9zdExpc3RlbmVyKCdkb2N1bWVudDpjbGljaycsIFsnJGV2ZW50J10pXG4gICAgY2xpY2tIYW5kbGVyKGV2ZW50KTogdm9pZCB7XG4gICAgICAgIC8qKiBDaGVjayBpZiBjbGljayB3YXNuJ3QgaW5zaWRlIHRoZSBjb21wb25lbnQsIHRoZW4gY2xvc2UuICovXG4gICAgICAgIGlmICghdGhpcy5lbFJlZi5uYXRpdmVFbGVtZW50LmNvbnRhaW5zKGV2ZW50LnRhcmdldCkpIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VTdWJMaXN0KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIEBIb3N0TGlzdGVuZXIoJ3dpbmRvdzpyZXNpemUnKVxuICAgIG9uUmVzaXplKCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5vcGVuICYmIHRoaXMuaXNTdWJMaXN0UG9zaXRpb25SaWdodCgpKSB7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZURldGVjdGlvblJlZi5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgICAgICBsZXQgZGlzdGFuY2VGcm9tQ29ybmVyID0gdGhpcy5zdWJMaXN0Lm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkucmlnaHQ7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogV2hlbiB0aGUgcGFnZSBpcyByZXNpemVkIGFuZCB0aGUgbWVudSBzdWIgbGlzdCBnb2VzIGJleW9uZCB0aGUgcGFnZSxcbiAgICAgICAgICAgICAqIHRoZSBzdWIgbGlzdCBzaG91bGQgZ28gb3ZlciB0aGUgcGFyZW50IGxpc3RcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgd2hpbGUgKGRpc3RhbmNlRnJvbUNvcm5lciA+IHdpbmRvdy5pbm5lcldpZHRoICYmIHRoaXMuZ2V0TGVmdFByb3BlcnR5RnJvbVN1Ykxpc3QoKSA+IDEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN1Ykxpc3QubmF0aXZlRWxlbWVudC5zdHlsZS5sZWZ0ID0gKHRoaXMuZ2V0TGVmdFByb3BlcnR5RnJvbVN1Ykxpc3QoKSAtIDEpICsgJyUnO1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlRGV0ZWN0aW9uUmVmLmRldGVjdENoYW5nZXMoKTtcbiAgICAgICAgICAgICAgICBkaXN0YW5jZUZyb21Db3JuZXIgPSB0aGlzLnN1Ykxpc3QubmF0aXZlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5yaWdodDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBXaGVuIHRoZSBwYWdlIGlzIHJlc2l6ZWQgYW5kIHRoZSBtZW51IHN1YiBsaXN0IHdhcyBwdWxsZWQgb3ZlciBwYXJlbnQgbGlzdCxcbiAgICAgICAgICAgICAqIHRoZSBzdWIgbGlzdCBzaG91bGQgZ28gdG8gcmlnaHQgc2lkZSBvZiBwYXJlbnQgbGlzdFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB3aGlsZSAoZGlzdGFuY2VGcm9tQ29ybmVyIDwgd2luZG93LmlubmVyV2lkdGggJiYgdGhpcy5nZXRMZWZ0UHJvcGVydHlGcm9tU3ViTGlzdCgpIDwgMTAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdWJMaXN0Lm5hdGl2ZUVsZW1lbnQuc3R5bGUubGVmdCA9ICh0aGlzLmdldExlZnRQcm9wZXJ0eUZyb21TdWJMaXN0KCkgKyAxKSArICclJztcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZURldGVjdGlvblJlZi5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgICAgICAgICAgZGlzdGFuY2VGcm9tQ29ybmVyID0gdGhpcy5zdWJMaXN0Lm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkucmlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIG5nQWZ0ZXJDb250ZW50SW5pdCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5saW5rLmhhc0NoaWxkID0gdGhpcy5zdWJJdGVtcy5sZW5ndGggPiAwO1xuICAgICAgICB0aGlzLnN1Ykl0ZW1zLmNoYW5nZXNcbiAgICAgICAgICAgIC5waXBlKHRha2VVbnRpbCh0aGlzLm9uRGVzdHJveSQpLCBzdGFydFdpdGgoNSkpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKCgpID0+IHRoaXMucmVmcmVzaFN1YnNjcmlwdGlvbigpKVxuICAgICAgICA7XG4gICAgfVxuXG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5vbkRlc3Ryb3kkLm5leHQoKTtcbiAgICAgICAgdGhpcy5vbkRlc3Ryb3kkLmNvbXBsZXRlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogS2V5Ym9hcmQgZXZlbnRzIGhhbmRsZXIgZnJvbSBzdWJsaXN0LCB0aGUgZXZlbnQgZG9lc24ndCBwcm9wYWdhdGUgdXBwZXIsIHdoZW4gaXQgd2FzIEFycm93RG93biBvciBBcnJvd1VwLlxuICAgICAqIEl0IHByZXZlbnRzIGZyb20gY2hhbmdpbmcgZm9jdXMgdG8gaXRlbSBvbiBwcmltYXJ5IG1lbnUgbGlzdFxuICAgICAqL1xuICAgIGhhbmRsZVN1Ykxpc3RLZXlEb3duKGV2ZW50OiBLZXlib2FyZEV2ZW50LCBpbmRleDogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIHRoaXMubWVudUtleWJvYXJkU2VydmljZS5rZXlEb3duSGFuZGxlcihldmVudCwgaW5kZXgsIHRoaXMuc3ViSXRlbXMudG9BcnJheSgpKTtcbiAgICAgICAgaWYgKGV2ZW50LmtleSA9PT0gJ0Fycm93RG93bicgfHwgZXZlbnQua2V5ID09PSAnQXJyb3dVcCcpIHtcbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBjbGljaygpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5saW5rLmNsaWNrKCk7XG4gICAgfVxuXG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBmb2N1cygpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5saW5rLmZvY3VzKCk7XG4gICAgfVxuXG4gICAgLyoqIE1ldGhvZCB0aGF0IGluZm9ybXMgaWYgYWN0dWFsIHBvc2l0aW9uIG9mIHN1Ymxpc3QgaXMgc2V0IHRvIHJpZ2h0ICovXG4gICAgcHVibGljIGlzU3ViTGlzdFBvc2l0aW9uUmlnaHQoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1Ykxpc3RQb3NpdGlvbiA9PT0gJ3JpZ2h0JztcbiAgICB9XG5cbiAgICAvKiogTWV0aG9kIHRoYXQgY2hhbmdlcyBzdGF0ZSBvZiBvcGVuIHZhcmlhYmxlICovXG4gICAgcHVibGljIHRvZ2dsZU9wZW4oKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLm9wZW4pIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VTdWJMaXN0KClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMub3BlblN1Ykxpc3QoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBNZXRob2QgdGhhdCBjbG9zZXMgc3VibGlzdCAqL1xuICAgIHB1YmxpYyBjbG9zZVN1Ykxpc3QoKTogdm9pZCB7XG4gICAgICAgIHRoaXMub3BlbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxpbmsuaXNFeHBhbmRlZCA9IHRoaXMuaXNTaG93KCk7XG4gICAgICAgIHRoaXMub3BlbkNoYW5nZS5lbWl0KHRoaXMub3Blbik7XG4gICAgfVxuXG4gICAgLyoqIE1ldGhvZCB0aGF0IG9wZW5zIHN1Ymxpc3QgKi9cbiAgICBwdWJsaWMgb3BlblN1Ykxpc3QoKTogdm9pZCB7XG4gICAgICAgIHRoaXMub3BlbiA9IHRydWU7XG4gICAgICAgIHRoaXMubGluay5pc0V4cGFuZGVkID0gdGhpcy5pc1Nob3coKTtcbiAgICAgICAgdGhpcy5vcGVuQ2hhbmdlLmVtaXQodGhpcy5vcGVuKTtcbiAgICAgICAgdGhpcy5vblJlc2l6ZSgpO1xuICAgIH1cblxuICAgIC8qKiBNZXRob2QgdGhhdCBnaXZlcyBpbmZvcm1hdGlvbiBpZiB0aGUgc3VibGlzdCBzaG91bGQgYmVoYXZlIGxpa2UgaXQgaXMgb3BlbmVkLiAqL1xuICAgIHB1YmxpYyBpc1Nob3coKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wZW4gJiYgdGhpcy5zdWJJdGVtcy5sZW5ndGggPiAwO1xuICAgIH1cblxuICAgIC8qKiBNZXRob2QgdGhhdCBoZWxwcyB3aXRoIHRoZSByZXNwb25zaXZlIHN1cHBvcnQuIEdpdmVzIHBlcmNlbnRhZ2UgbnVtYmVyIG9mIGxlZnQgY3NzIGF0dHJpYnV0ZSBvbiBsaXN0LiAqL1xuICAgIHByaXZhdGUgZ2V0TGVmdFByb3BlcnR5RnJvbVN1Ykxpc3QoKTogbnVtYmVyIHtcbiAgICAgICAgY29uc3Qgc3R5bGVzID0gZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLnN1Ykxpc3QubmF0aXZlRWxlbWVudCk7XG4gICAgICAgIGlmIChzdHlsZXMubGVmdCkge1xuICAgICAgICAgICAgaWYgKHN0eWxlcy5sZWZ0LmluY2x1ZGVzKCdweCcpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE51bWJlcihzdHlsZXMubGVmdC5zcGxpdCgncHgnKVswXSkgLyB0aGlzLnBhcmVudEVsZW1lbnQubmF0aXZlRWxlbWVudC5vZmZzZXRXaWR0aCAqIDEwMDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3R5bGVzLmxlZnQuaW5jbHVkZXMoJyUnKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBOdW1iZXIoc3R5bGVzLmxlZnQuc3BsaXQoJyUnKVswXSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAxMDA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogV2hldGhlciBhbnkgcXVlcnlsaXN0IGRldGVjdHMgYW55IGNoYW5nZXMgKi9cbiAgICBwcml2YXRlIHJlZnJlc2hTdWJzY3JpcHRpb24oKTogdm9pZCB7XG4gICAgICAgIC8qKiBGaW5pc2ggYWxsIG9mIHRoZSBzdHJlYW1zLCBmb3JtIGJlZm9yZSAqL1xuICAgICAgICB0aGlzLm9uUmVmcmVzaCQubmV4dCgpO1xuXG4gICAgICAgIC8qKiBNZXJnZSByZWZyZXNoL2Rlc3Ryb3kgb2JzZXJ2YWJsZXMgKi9cbiAgICAgICAgY29uc3QgcmVmcmVzaE9icyA9IG1lcmdlKHRoaXMub25SZWZyZXNoJCwgdGhpcy5vbkRlc3Ryb3kkKTtcblxuICAgICAgICB0aGlzLnN1Ykl0ZW1zLmZvckVhY2goKGl0ZW06IE1lZ2FNZW51U3ViaXRlbURpcmVjdGl2ZSwgaW5kZXg6IG51bWJlcikgPT4gaXRlbS5rZXlEb3duXG4gICAgICAgICAgICAucGlwZSh0YWtlVW50aWwodGhpcy5vbkRlc3Ryb3kkKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKGtleWJvYXJkRXZlbnQ6IEtleWJvYXJkRXZlbnQpID0+IHRoaXMuaGFuZGxlU3ViTGlzdEtleURvd24oa2V5Ym9hcmRFdmVudCwgaW5kZXgpKSlcbiAgICAgICAgO1xuICAgIH1cbn1cbiJdfQ==