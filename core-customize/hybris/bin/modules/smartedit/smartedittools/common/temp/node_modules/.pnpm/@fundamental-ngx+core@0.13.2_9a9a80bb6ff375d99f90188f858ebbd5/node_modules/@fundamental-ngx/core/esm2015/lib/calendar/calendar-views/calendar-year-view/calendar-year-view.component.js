/**
 * @fileoverview added by tsickle
 * Generated from: lib/calendar/calendar-views/calendar-year-view/calendar-year-view.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Component, ViewEncapsulation, Output, Input, EventEmitter, ElementRef, ChangeDetectionStrategy, ChangeDetectorRef } from '@angular/core';
import { FdDate } from '../../models/fd-date';
import { takeUntil } from 'rxjs/operators';
import { CalendarService } from '../../calendar.service';
import { Subject } from 'rxjs';
/**
 * Component representing the YearView of the Calendar Component.
 */
export class CalendarYearViewComponent {
    /**
     * @hidden
     * @param {?} eRef
     * @param {?} changeDetectorRef
     * @param {?} calendarService
     */
    constructor(eRef, changeDetectorRef, calendarService) {
        this.eRef = eRef;
        this.changeDetectorRef = changeDetectorRef;
        this.calendarService = calendarService;
        this._amountOfColPerRow = 4;
        /**
         * Parameter storing the year of the present day.
         */
        this.currentYear = FdDate.getToday().year;
        /**
         * Parameter storing first shown year on list
         */
        this.firstYearInList = this.currentYear;
        /**
         * An RxJS Subject that will kill the data stream upon component’s destruction (for unsubscribing)
         */
        this.onDestroy$ = new Subject();
        /**
         * Event fired when a year is selected.
         */
        this.yearClicked = new EventEmitter();
    }
    /**
     * @hidden
     * @return {?}
     */
    ngAfterViewChecked() {
        if (this.newFocusedYearId) {
            this.focusElement(this.newFocusedYearId);
            this.newFocusedYearId = null;
        }
    }
    /**
     * @hidden
     * @return {?}
     */
    ngOnInit() {
        this.firstYearInList = this.yearSelected;
        this.constructYearGrid();
        this.calendarService.onFocusIdChange
            .pipe(takeUntil(this.onDestroy$))
            .subscribe((/**
         * @param {?} index
         * @return {?}
         */
        index => {
            this.newFocusedYearId = this.id + '-fd-year-' + index;
            this.focusElement(this.newFocusedYearId);
        }));
        this.calendarService.focusEscapeFunction = this.focusEscapeFunction;
        this.calendarService.onKeySelect
            .pipe(takeUntil(this.onDestroy$))
            .subscribe((/**
         * @param {?} index
         * @return {?}
         */
        index => this.selectYear(this.getYearList()[index])));
        this.calendarService.onListStartApproach
            .pipe(takeUntil(this.onDestroy$))
            .subscribe((/**
         * @return {?}
         */
        () => this.loadPreviousYearList()));
        this.calendarService.onListEndApproach
            .pipe(takeUntil(this.onDestroy$))
            .subscribe((/**
         * @return {?}
         */
        () => this.loadNextYearList()));
    }
    /**
     * @hidden
     * @return {?}
     */
    ngOnDestroy() {
        this.onDestroy$.next();
        this.onDestroy$.complete();
    }
    /**
     * Method that returns active cell, which means:
     * if there is any selected year, return selected year
     * if there is no selected year, but there is current year, return current year
     * if there is no current year, or selected, return first one
     * @private
     * @return {?}
     */
    getActiveYear() {
        /** @type {?} */
        const selectedYear = this.getYearList().find((/**
         * @param {?} year
         * @return {?}
         */
        year => year === this.yearSelected));
        if (selectedYear) {
            return selectedYear;
        }
        /** @type {?} */
        const currentYear = this.getYearList().find((/**
         * @param {?} year
         * @return {?}
         */
        year => year === this.currentYear));
        if (currentYear) {
            return currentYear;
        }
        return this.calendarYearListGrid[0][0];
    }
    /**
     * Method for handling the keyboard navigation.
     * @param {?} event
     * @param {?} index
     * @return {?}
     */
    onKeydownYearHandler(event, index) {
        this.calendarService.onKeydownHandler(event, index);
    }
    /**
     * Method used to load the previous 12 years to be displayed.
     * @return {?}
     */
    loadNextYearList() {
        this.firstYearInList += 12;
        this.constructYearGrid();
    }
    /**
     * Method used to load the next 12 years to be displayed.
     * @return {?}
     */
    loadPreviousYearList() {
        this.firstYearInList -= 12;
        this.constructYearGrid();
    }
    /**
     * Method allowing focusing on elements within this component.
     * @param {?} elementSelector
     * @return {?}
     */
    focusElement(elementSelector) {
        setTimeout((/**
         * @return {?}
         */
        () => {
            /** @type {?} */
            const elementToFocus = this.eRef.nativeElement.querySelector('#' + elementSelector);
            if (elementToFocus) {
                this.eRef.nativeElement.querySelector('#' + elementSelector).focus();
            }
        }), 0);
    }
    /**
     * Method that sends the year to the parent component when it is clicked.
     * @param {?} selectedYear
     * @param {?=} event
     * @return {?}
     */
    selectYear(selectedYear, event) {
        if (event) {
            event.stopPropagation();
        }
        this.yearSelected = selectedYear;
        this.yearClicked.emit(this.yearSelected);
    }
    /**
     * @param {?} rowIndex
     * @param {?} colIndex
     * @return {?}
     */
    getId(rowIndex, colIndex) {
        return rowIndex * this._amountOfColPerRow + colIndex;
    }
    /**
     * @hidden
     * @private
     * @return {?}
     */
    constructYearGrid() {
        /** @type {?} */
        const displayedYearsAmount = 12;
        /** @type {?} */
        const calendarYearList = [];
        this.calendarYearListGrid = [];
        for (let x = 0; x < displayedYearsAmount; ++x) {
            calendarYearList.push(this.firstYearInList + x);
        }
        /** Creating 2d grid */
        while (calendarYearList.length) {
            this.calendarYearListGrid.push(calendarYearList.splice(0, this._amountOfColPerRow));
        }
        this.activeYear = this.getActiveYear();
        this.changeDetectorRef.markForCheck();
    }
    /**
     * Returns transformed 1d array from 2d year grid.
     * @private
     * @return {?}
     */
    getYearList() {
        return [].concat.apply([], this.calendarYearListGrid);
    }
}
CalendarYearViewComponent.decorators = [
    { type: Component, args: [{
                selector: 'fd-calendar-year-view',
                template: "<div class=\"fd-calendar__years\">\n    <table class=\"fd-calendar__table\" role=\"grid\">\n        <tbody class=\"fd-calendar__group\">\n        <tr class=\"fd-calendar__row\"\n            *ngFor=\"let colYears of calendarYearListGrid; let rowIndex = index\">\n            <td class=\"fd-calendar__item\"\n                *ngFor=\"let year of colYears; let colIndex = index\"\n                [ngClass]=\"{\n                    'is-selected': (year == yearSelected),\n                    'fd-calendar__item--current': (year == currentYear)\n                }\"\n                [attr.id]=\"id + '-fd-year-' + getId(rowIndex, colIndex)\"\n                [attr.tabindex]=\"year === activeYear ? 0 : -1\"\n                (keydown)=\"onKeydownYearHandler($event, getId(rowIndex, colIndex))\"\n                (click)=\"selectYear(year, $event)\">\n                <span role=\"button\" class=\"fd-calendar__text\">\n                    {{ year }}\n                </span>\n            </td>\n        </tr>\n        </tbody>\n    </table>\n</div>\n",
                encapsulation: ViewEncapsulation.None,
                host: {
                    '[attr.id]': 'id + "-year-view"'
                },
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [""]
            }] }
];
/** @nocollapse */
CalendarYearViewComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: ChangeDetectorRef },
    { type: CalendarService }
];
CalendarYearViewComponent.propDecorators = {
    id: [{ type: Input }],
    focusEscapeFunction: [{ type: Input }],
    yearSelected: [{ type: Input }],
    yearClicked: [{ type: Output }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    CalendarYearViewComponent.prototype._amountOfColPerRow;
    /**
     * @hidden
     *  This variable is used to define which year from calendarYearList should be focusable by tab key
     * @type {?}
     */
    CalendarYearViewComponent.prototype.activeYear;
    /**
     * Parameter that stores the dozen of years that are currently being displayed.
     * @type {?}
     */
    CalendarYearViewComponent.prototype.calendarYearListGrid;
    /**
     * Parameter storing the year of the present day.
     * @type {?}
     */
    CalendarYearViewComponent.prototype.currentYear;
    /**
     * Parameter storing first shown year on list
     * @type {?}
     */
    CalendarYearViewComponent.prototype.firstYearInList;
    /**
     * An RxJS Subject that will kill the data stream upon component’s destruction (for unsubscribing)
     * @type {?}
     * @private
     */
    CalendarYearViewComponent.prototype.onDestroy$;
    /**
     * @hidden
     * @type {?}
     * @private
     */
    CalendarYearViewComponent.prototype.newFocusedYearId;
    /**
     * Parameter used in id of years used for help with focusing on the correct element during keyboard navigation.
     * @type {?}
     */
    CalendarYearViewComponent.prototype.id;
    /**
     * Function that is called when the focus would escape the element.
     * @type {?}
     */
    CalendarYearViewComponent.prototype.focusEscapeFunction;
    /**
     * Parameter holding the year that is currently selected.
     * @type {?}
     */
    CalendarYearViewComponent.prototype.yearSelected;
    /**
     * Event fired when a year is selected.
     * @type {?}
     */
    CalendarYearViewComponent.prototype.yearClicked;
    /**
     * @type {?}
     * @private
     */
    CalendarYearViewComponent.prototype.eRef;
    /**
     * @type {?}
     * @private
     */
    CalendarYearViewComponent.prototype.changeDetectorRef;
    /**
     * @type {?}
     * @private
     */
    CalendarYearViewComponent.prototype.calendarService;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2FsZW5kYXIteWVhci12aWV3LmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BmdW5kYW1lbnRhbC1uZ3gvY29yZS8iLCJzb3VyY2VzIjpbImxpYi9jYWxlbmRhci9jYWxlbmRhci12aWV3cy9jYWxlbmRhci15ZWFyLXZpZXcvY2FsZW5kYXIteWVhci12aWV3LmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLE9BQU8sRUFDSCxTQUFTLEVBRVQsaUJBQWlCLEVBQ2pCLE1BQU0sRUFDTixLQUFLLEVBQ0wsWUFBWSxFQUNaLFVBQVUsRUFHVix1QkFBdUIsRUFBRSxpQkFBaUIsRUFDN0MsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFFLE1BQU0sRUFBRSxNQUFNLHNCQUFzQixDQUFDO0FBQzlDLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUMzQyxPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0sd0JBQXdCLENBQUM7QUFDekQsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLE1BQU0sQ0FBQzs7OztBQWEvQixNQUFNLE9BQU8seUJBQXlCOzs7Ozs7O0lBeUNsQyxZQUNZLElBQWdCLEVBQ2hCLGlCQUFvQyxFQUNwQyxlQUFnQztRQUZoQyxTQUFJLEdBQUosSUFBSSxDQUFZO1FBQ2hCLHNCQUFpQixHQUFqQixpQkFBaUIsQ0FBbUI7UUFDcEMsb0JBQWUsR0FBZixlQUFlLENBQWlCO1FBMUMzQix1QkFBa0IsR0FBVyxDQUFDLENBQUM7Ozs7UUFXaEQsZ0JBQVcsR0FBVyxNQUFNLENBQUMsUUFBUSxFQUFFLENBQUMsSUFBSSxDQUFDOzs7O1FBRzdDLG9CQUFlLEdBQVcsSUFBSSxDQUFDLFdBQVcsQ0FBQzs7OztRQUcxQixlQUFVLEdBQWtCLElBQUksT0FBTyxFQUFRLENBQUM7Ozs7UUFtQnhELGdCQUFXLEdBQXlCLElBQUksWUFBWSxFQUFVLENBQUM7SUFPeEUsQ0FBQzs7Ozs7SUFHRCxrQkFBa0I7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dCxcbiAgICBWaWV3RW5jYXBzdWxhdGlvbixcbiAgICBPdXRwdXQsXG4gICAgSW5wdXQsXG4gICAgRXZlbnRFbWl0dGVyLFxuICAgIEVsZW1lbnRSZWYsXG4gICAgQWZ0ZXJWaWV3Q2hlY2tlZCxcbiAgICBPbkRlc3Ryb3ksXG4gICAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksIENoYW5nZURldGVjdG9yUmVmXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRmREYXRlIH0gZnJvbSAnLi4vLi4vbW9kZWxzL2ZkLWRhdGUnO1xuaW1wb3J0IHsgdGFrZVVudGlsIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgQ2FsZW5kYXJTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vY2FsZW5kYXIuc2VydmljZSc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5cbi8qKiBDb21wb25lbnQgcmVwcmVzZW50aW5nIHRoZSBZZWFyVmlldyBvZiB0aGUgQ2FsZW5kYXIgQ29tcG9uZW50LiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdmZC1jYWxlbmRhci15ZWFyLXZpZXcnLFxuICAgIHRlbXBsYXRlVXJsOiAnLi9jYWxlbmRhci15ZWFyLXZpZXcuY29tcG9uZW50Lmh0bWwnLFxuICAgIHN0eWxlVXJsczogWycuL2NhbGVuZGFyLXllYXItdmlldy5jb21wb25lbnQuc2NzcyddLFxuICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gICAgaG9zdDoge1xuICAgICAgICAnW2F0dHIuaWRdJzogJ2lkICsgXCIteWVhci12aWV3XCInXG4gICAgfSxcbiAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxufSlcbmV4cG9ydCBjbGFzcyBDYWxlbmRhclllYXJWaWV3Q29tcG9uZW50IGltcGxlbWVudHMgQWZ0ZXJWaWV3Q2hlY2tlZCwgT25Jbml0LCBPbkRlc3Ryb3kge1xuXG4gICAgcHJpdmF0ZSByZWFkb25seSBfYW1vdW50T2ZDb2xQZXJSb3c6IG51bWJlciA9IDQ7XG5cbiAgICAvKiogQGhpZGRlblxuICAgICAqICBUaGlzIHZhcmlhYmxlIGlzIHVzZWQgdG8gZGVmaW5lIHdoaWNoIHllYXIgZnJvbSBjYWxlbmRhclllYXJMaXN0IHNob3VsZCBiZSBmb2N1c2FibGUgYnkgdGFiIGtleVxuICAgICAqL1xuICAgIGFjdGl2ZVllYXI6IG51bWJlcjtcblxuICAgIC8qKiBQYXJhbWV0ZXIgdGhhdCBzdG9yZXMgdGhlIGRvemVuIG9mIHllYXJzIHRoYXQgYXJlIGN1cnJlbnRseSBiZWluZyBkaXNwbGF5ZWQuICovXG4gICAgY2FsZW5kYXJZZWFyTGlzdEdyaWQ6IG51bWJlcltdW107XG5cbiAgICAvKiogUGFyYW1ldGVyIHN0b3JpbmcgdGhlIHllYXIgb2YgdGhlIHByZXNlbnQgZGF5LiAqL1xuICAgIGN1cnJlbnRZZWFyOiBudW1iZXIgPSBGZERhdGUuZ2V0VG9kYXkoKS55ZWFyO1xuXG4gICAgLyoqIFBhcmFtZXRlciBzdG9yaW5nIGZpcnN0IHNob3duIHllYXIgb24gbGlzdCAqL1xuICAgIGZpcnN0WWVhckluTGlzdDogbnVtYmVyID0gdGhpcy5jdXJyZW50WWVhcjtcblxuICAgIC8qKiBBbiBSeEpTIFN1YmplY3QgdGhhdCB3aWxsIGtpbGwgdGhlIGRhdGEgc3RyZWFtIHVwb24gY29tcG9uZW504oCZcyBkZXN0cnVjdGlvbiAoZm9yIHVuc3Vic2NyaWJpbmcpICAqL1xuICAgIHByaXZhdGUgcmVhZG9ubHkgb25EZXN0cm95JDogU3ViamVjdDx2b2lkPiA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG5cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIHByaXZhdGUgbmV3Rm9jdXNlZFllYXJJZDogc3RyaW5nO1xuXG4gICAgLyoqIFBhcmFtZXRlciB1c2VkIGluIGlkIG9mIHllYXJzIHVzZWQgZm9yIGhlbHAgd2l0aCBmb2N1c2luZyBvbiB0aGUgY29ycmVjdCBlbGVtZW50IGR1cmluZyBrZXlib2FyZCBuYXZpZ2F0aW9uLiAqL1xuICAgIEBJbnB1dCgpXG4gICAgaWQ6IHN0cmluZztcblxuICAgIC8qKiBGdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aGVuIHRoZSBmb2N1cyB3b3VsZCBlc2NhcGUgdGhlIGVsZW1lbnQuICovXG4gICAgQElucHV0KClcbiAgICBmb2N1c0VzY2FwZUZ1bmN0aW9uOiBGdW5jdGlvbjtcblxuICAgIC8qKiBQYXJhbWV0ZXIgaG9sZGluZyB0aGUgeWVhciB0aGF0IGlzIGN1cnJlbnRseSBzZWxlY3RlZC4gKi9cbiAgICBASW5wdXQoKVxuICAgIHllYXJTZWxlY3RlZDogbnVtYmVyO1xuXG4gICAgLyoqIEV2ZW50IGZpcmVkIHdoZW4gYSB5ZWFyIGlzIHNlbGVjdGVkLiAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHJlYWRvbmx5IHllYXJDbGlja2VkOiBFdmVudEVtaXR0ZXI8bnVtYmVyPiA9IG5ldyBFdmVudEVtaXR0ZXI8bnVtYmVyPigpO1xuXG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHJpdmF0ZSBlUmVmOiBFbGVtZW50UmVmLFxuICAgICAgICBwcml2YXRlIGNoYW5nZURldGVjdG9yUmVmOiBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICAgICAgcHJpdmF0ZSBjYWxlbmRhclNlcnZpY2U6IENhbGVuZGFyU2VydmljZSkge1xuICAgIH1cblxuICAgIC8qKiBAaGlkZGVuICovXG4gICAgbmdBZnRlclZpZXdDaGVja2VkKCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5uZXdGb2N1c2VkWWVhcklkKSB7XG4gICAgICAgICAgICB0aGlzLmZvY3VzRWxlbWVudCh0aGlzLm5ld0ZvY3VzZWRZZWFySWQpO1xuICAgICAgICAgICAgdGhpcy5uZXdGb2N1c2VkWWVhcklkID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBAaGlkZGVuICovXG4gICAgbmdPbkluaXQoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZmlyc3RZZWFySW5MaXN0ID0gdGhpcy55ZWFyU2VsZWN0ZWQ7XG4gICAgICAgIHRoaXMuY29uc3RydWN0WWVhckdyaWQoKTtcblxuICAgICAgICB0aGlzLmNhbGVuZGFyU2VydmljZS5vbkZvY3VzSWRDaGFuZ2VcbiAgICAgICAgICAgIC5waXBlKHRha2VVbnRpbCh0aGlzLm9uRGVzdHJveSQpKVxuICAgICAgICAgICAgLnN1YnNjcmliZShpbmRleCA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXdGb2N1c2VkWWVhcklkID0gdGhpcy5pZCArICctZmQteWVhci0nICsgaW5kZXg7XG4gICAgICAgICAgICAgICAgdGhpcy5mb2N1c0VsZW1lbnQodGhpcy5uZXdGb2N1c2VkWWVhcklkKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIDtcbiAgICAgICAgdGhpcy5jYWxlbmRhclNlcnZpY2UuZm9jdXNFc2NhcGVGdW5jdGlvbiA9IHRoaXMuZm9jdXNFc2NhcGVGdW5jdGlvbjtcblxuICAgICAgICB0aGlzLmNhbGVuZGFyU2VydmljZS5vbktleVNlbGVjdFxuICAgICAgICAgICAgLnBpcGUodGFrZVVudGlsKHRoaXMub25EZXN0cm95JCkpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKGluZGV4ID0+IHRoaXMuc2VsZWN0WWVhcih0aGlzLmdldFllYXJMaXN0KClbaW5kZXhdKSlcbiAgICAgICAgO1xuXG4gICAgICAgIHRoaXMuY2FsZW5kYXJTZXJ2aWNlLm9uTGlzdFN0YXJ0QXBwcm9hY2hcbiAgICAgICAgICAgIC5waXBlKHRha2VVbnRpbCh0aGlzLm9uRGVzdHJveSQpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgoKSA9PiB0aGlzLmxvYWRQcmV2aW91c1llYXJMaXN0KCkpXG4gICAgICAgIDtcblxuICAgICAgICB0aGlzLmNhbGVuZGFyU2VydmljZS5vbkxpc3RFbmRBcHByb2FjaFxuICAgICAgICAgICAgLnBpcGUodGFrZVVudGlsKHRoaXMub25EZXN0cm95JCkpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKCgpID0+IHRoaXMubG9hZE5leHRZZWFyTGlzdCgpKVxuICAgICAgICA7XG4gICAgfVxuXG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5vbkRlc3Ryb3kkLm5leHQoKTtcbiAgICAgICAgdGhpcy5vbkRlc3Ryb3kkLmNvbXBsZXRlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHRoYXQgcmV0dXJucyBhY3RpdmUgY2VsbCwgd2hpY2ggbWVhbnM6XG4gICAgICogaWYgdGhlcmUgaXMgYW55IHNlbGVjdGVkIHllYXIsIHJldHVybiBzZWxlY3RlZCB5ZWFyXG4gICAgICogaWYgdGhlcmUgaXMgbm8gc2VsZWN0ZWQgeWVhciwgYnV0IHRoZXJlIGlzIGN1cnJlbnQgeWVhciwgcmV0dXJuIGN1cnJlbnQgeWVhclxuICAgICAqIGlmIHRoZXJlIGlzIG5vIGN1cnJlbnQgeWVhciwgb3Igc2VsZWN0ZWQsIHJldHVybiBmaXJzdCBvbmVcbiAgICAgKi9cbiAgICBwcml2YXRlIGdldEFjdGl2ZVllYXIoKTogbnVtYmVyIHtcbiAgICAgICAgY29uc3Qgc2VsZWN0ZWRZZWFyOiBudW1iZXIgPSB0aGlzLmdldFllYXJMaXN0KCkuZmluZCh5ZWFyID0+IHllYXIgPT09IHRoaXMueWVhclNlbGVjdGVkKTtcbiAgICAgICAgaWYgKHNlbGVjdGVkWWVhcikge1xuICAgICAgICAgICAgcmV0dXJuIHNlbGVjdGVkWWVhcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGN1cnJlbnRZZWFyOiBudW1iZXIgPSB0aGlzLmdldFllYXJMaXN0KCkuZmluZCh5ZWFyID0+IHllYXIgPT09IHRoaXMuY3VycmVudFllYXIpO1xuICAgICAgICBpZiAoY3VycmVudFllYXIpIHtcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50WWVhcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmNhbGVuZGFyWWVhckxpc3RHcmlkWzBdWzBdO1xuICAgIH1cblxuICAgIC8qKiBNZXRob2QgZm9yIGhhbmRsaW5nIHRoZSBrZXlib2FyZCBuYXZpZ2F0aW9uLiAqL1xuICAgIG9uS2V5ZG93blllYXJIYW5kbGVyKGV2ZW50LCBpbmRleDogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIHRoaXMuY2FsZW5kYXJTZXJ2aWNlLm9uS2V5ZG93bkhhbmRsZXIoZXZlbnQsIGluZGV4KTtcbiAgICB9XG5cbiAgICAvKiogTWV0aG9kIHVzZWQgdG8gbG9hZCB0aGUgcHJldmlvdXMgMTIgeWVhcnMgdG8gYmUgZGlzcGxheWVkLiAqL1xuICAgIGxvYWROZXh0WWVhckxpc3QoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZmlyc3RZZWFySW5MaXN0ICs9IDEyO1xuICAgICAgICB0aGlzLmNvbnN0cnVjdFllYXJHcmlkKCk7XG4gICAgfVxuXG4gICAgLyoqIE1ldGhvZCB1c2VkIHRvIGxvYWQgdGhlIG5leHQgMTIgeWVhcnMgdG8gYmUgZGlzcGxheWVkLiAqL1xuICAgIGxvYWRQcmV2aW91c1llYXJMaXN0KCk6IHZvaWQge1xuICAgICAgICB0aGlzLmZpcnN0WWVhckluTGlzdCAtPSAxMjtcbiAgICAgICAgdGhpcy5jb25zdHJ1Y3RZZWFyR3JpZCgpO1xuICAgIH1cblxuICAgIC8qKiBNZXRob2QgYWxsb3dpbmcgZm9jdXNpbmcgb24gZWxlbWVudHMgd2l0aGluIHRoaXMgY29tcG9uZW50LiAqL1xuICAgIGZvY3VzRWxlbWVudChlbGVtZW50U2VsZWN0b3I6IHN0cmluZyk6IHZvaWQge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnRUb0ZvY3VzOiBIVE1MRWxlbWVudCA9IHRoaXMuZVJlZi5uYXRpdmVFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJyMnICsgZWxlbWVudFNlbGVjdG9yKTtcbiAgICAgICAgICAgIGlmIChlbGVtZW50VG9Gb2N1cykge1xuICAgICAgICAgICAgICAgIHRoaXMuZVJlZi5uYXRpdmVFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJyMnICsgZWxlbWVudFNlbGVjdG9yKS5mb2N1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCAwKTtcbiAgICB9XG5cbiAgICAvKiogTWV0aG9kIHRoYXQgc2VuZHMgdGhlIHllYXIgdG8gdGhlIHBhcmVudCBjb21wb25lbnQgd2hlbiBpdCBpcyBjbGlja2VkLiAqL1xuICAgIHNlbGVjdFllYXIoc2VsZWN0ZWRZZWFyOiBudW1iZXIsIGV2ZW50PzogTW91c2VFdmVudCkge1xuICAgICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMueWVhclNlbGVjdGVkID0gc2VsZWN0ZWRZZWFyO1xuICAgICAgICB0aGlzLnllYXJDbGlja2VkLmVtaXQodGhpcy55ZWFyU2VsZWN0ZWQpO1xuICAgIH1cblxuICAgIGdldElkKHJvd0luZGV4OiBudW1iZXIsIGNvbEluZGV4OiBudW1iZXIpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gcm93SW5kZXggKiB0aGlzLl9hbW91bnRPZkNvbFBlclJvdyArIGNvbEluZGV4O1xuICAgIH1cblxuICAgIC8qKiBAaGlkZGVuICovXG4gICAgcHJpdmF0ZSBjb25zdHJ1Y3RZZWFyR3JpZCgpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgZGlzcGxheWVkWWVhcnNBbW91bnQ6IG51bWJlciA9IDEyO1xuICAgICAgICBjb25zdCBjYWxlbmRhclllYXJMaXN0ID0gW107XG4gICAgICAgIHRoaXMuY2FsZW5kYXJZZWFyTGlzdEdyaWQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCBkaXNwbGF5ZWRZZWFyc0Ftb3VudDsgKyt4KSB7XG4gICAgICAgICAgICBjYWxlbmRhclllYXJMaXN0LnB1c2godGhpcy5maXJzdFllYXJJbkxpc3QgKyB4KTtcbiAgICAgICAgfVxuICAgICAgICAvKiogQ3JlYXRpbmcgMmQgZ3JpZCAqL1xuICAgICAgICB3aGlsZSAoY2FsZW5kYXJZZWFyTGlzdC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuY2FsZW5kYXJZZWFyTGlzdEdyaWQucHVzaChjYWxlbmRhclllYXJMaXN0LnNwbGljZSgwLCB0aGlzLl9hbW91bnRPZkNvbFBlclJvdykpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWN0aXZlWWVhciA9IHRoaXMuZ2V0QWN0aXZlWWVhcigpO1xuICAgICAgICB0aGlzLmNoYW5nZURldGVjdG9yUmVmLm1hcmtGb3JDaGVjaygpO1xuICAgIH1cblxuICAgIC8qKiBSZXR1cm5zIHRyYW5zZm9ybWVkIDFkIGFycmF5IGZyb20gMmQgeWVhciBncmlkLiAqL1xuICAgIHByaXZhdGUgZ2V0WWVhckxpc3QoKTogbnVtYmVyW10ge1xuICAgICAgICByZXR1cm4gW10uY29uY2F0LmFwcGx5KFtdLCB0aGlzLmNhbGVuZGFyWWVhckxpc3RHcmlkKTtcbiAgICB9XG59XG4iXX0=