"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
exports.OperationFactory = void 0;
const RushConstants_1 = require("../RushConstants");
const NullOperationRunner_1 = require("./NullOperationRunner");
const ShellOperationRunner_1 = require("./ShellOperationRunner");
const Operation_1 = require("./Operation");
const OperationStatus_1 = require("./OperationStatus");
class OperationFactory {
    constructor(options) {
        this._options = options;
        this._customParametersByPhase = new Map();
    }
    createTask(options) {
        const { phase, project } = options;
        const factoryOptions = this._options;
        const customParameterValues = this._getCustomParameterValuesForPhase(phase);
        const commandToRun = OperationFactory._getScriptToRun(project, phase.name, customParameterValues);
        if (commandToRun === undefined && !phase.ignoreMissingScript) {
            throw new Error(`The project '${project.packageName}' does not define a '${phase.name}' command in the 'scripts' section of its package.json`);
        }
        const displayName = OperationFactory._getDisplayName(phase, project);
        // Empty build script indicates a no-op, so use a no-op runner
        const runner = commandToRun
            ? new ShellOperationRunner_1.ShellOperationRunner({
                rushProject: project,
                displayName,
                rushConfiguration: factoryOptions.rushConfiguration,
                buildCacheConfiguration: factoryOptions.buildCacheConfiguration,
                commandToRun: commandToRun || '',
                isIncrementalBuildAllowed: factoryOptions.isIncrementalBuildAllowed,
                projectChangeAnalyzer: factoryOptions.projectChangeAnalyzer,
                phase
            })
            : new NullOperationRunner_1.NullOperationRunner(displayName, OperationStatus_1.OperationStatus.FromCache);
        const operation = new Operation_1.Operation(runner, OperationStatus_1.OperationStatus.Ready);
        return operation;
    }
    static _getScriptToRun(rushProject, commandToRun, customParameterValues) {
        const { scripts } = rushProject.packageJson;
        const rawCommand = scripts === null || scripts === void 0 ? void 0 : scripts[commandToRun];
        if (rawCommand === undefined || rawCommand === null) {
            return undefined;
        }
        if (!rawCommand) {
            return '';
        }
        else {
            const shellCommand = `${rawCommand} ${customParameterValues.join(' ')}`;
            return process.platform === 'win32' ? (0, ShellOperationRunner_1.convertSlashesForWindows)(shellCommand) : shellCommand;
        }
    }
    static _getDisplayName(phase, project) {
        if (phase.isSynthetic) {
            // Because this is a synthetic phase, just use the project name because there aren't any other phases
            return project.packageName;
        }
        else {
            const phaseNameWithoutPrefix = phase.name.slice(RushConstants_1.RushConstants.phaseNamePrefix.length);
            return `${project.packageName} (${phaseNameWithoutPrefix})`;
        }
    }
    _getCustomParameterValuesForPhase(phase) {
        let customParameterValues = this._customParametersByPhase.get(phase);
        if (!customParameterValues) {
            customParameterValues = [];
            for (const { tsCommandLineParameter, parameter } of this._options.customParameters) {
                if (phase.associatedParameters.has(parameter)) {
                    tsCommandLineParameter.appendToArgList(customParameterValues);
                }
            }
            this._customParametersByPhase.set(phase, customParameterValues);
        }
        return customParameterValues;
    }
}
exports.OperationFactory = OperationFactory;
//# sourceMappingURL=ShellOperationFactory.js.map