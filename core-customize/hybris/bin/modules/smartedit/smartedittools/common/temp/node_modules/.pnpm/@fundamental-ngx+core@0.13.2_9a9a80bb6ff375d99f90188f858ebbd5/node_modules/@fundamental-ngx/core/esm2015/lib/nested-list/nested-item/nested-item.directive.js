/**
 * @fileoverview added by tsickle
 * Generated from: lib/nested-list/nested-item/nested-item.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { ContentChild, Directive, ElementRef, EventEmitter, forwardRef, HostBinding, Input, Output } from '@angular/core';
import { NestedLinkDirective } from '../nested-link/nested-link.directive';
import { NestedListKeyboardService } from '../nested-list-keyboard.service';
import { NestedListPopoverComponent } from '../nested-list-popover/nested-list-popover.component';
import { NestedListDirective } from '../nested-list/nested-list.directive';
import { PreparedNestedListComponent } from '../prepared-nested-list/prepared-nested-list.component';
export class NestedItemDirective {
    /**
     * @hidden
     * @param {?} elementRef
     * @param {?} keyboardService
     */
    constructor(elementRef, keyboardService) {
        this.elementRef = elementRef;
        this.keyboardService = keyboardService;
        /**
         * @hidden
         */
        this.fdNestedListItemClass = true;
        /**
         * @hidden
         */
        this._expanded = false;
        /**
         * Event thrown, when expanded state is changed
         */
        this.expandedChange = new EventEmitter();
        /**
         * Event thrown, when any keyboard event is dispatched on this, or link element
         */
        this.keyboardTriggered = new EventEmitter();
    }
    /**
     * Check if the item element has any child
     * @return {?}
     */
    get hasChildren() {
        return !!(this.nestedListItem || this.popoverItem || this.nestedListFromPreparedComponent);
    }
    /**
     * Get all of the children item elements
     * @return {?}
     */
    get allChildrenItems() {
        if (this.nestedListItem && this.nestedListItem.nestedItems) {
            /** Get elements from child list */
            return this.nestedListItem.nestedItems.toArray();
        }
        else if (this.nestedListFromPreparedComponent && this.nestedListFromPreparedComponent.nestedItems) {
            /** Get elements from child prepared list  component */
            return this.nestedListFromPreparedComponent.nestedItems.toArray();
        }
        else {
            return [];
        }
    }
    /**
     * Whether item should be expanded
     * @param {?} expanded
     * @return {?}
     */
    set expanded(expanded) {
        this.propagateOpenChange(expanded);
    }
    /**
     * @hidden
     * @return {?}
     */
    get expanded() {
        return this._expanded;
    }
    /**
     * @hidden
     * @return {?}
     */
    ngAfterContentInit() {
        /** Propagate hasChildren property */
        if (this.hasChildren && this.linkItem) {
            this.linkItem.hasChildren = true;
            this.linkItem.changeDetRef.detectChanges();
        }
        if (this.linkItem) {
            /** Subscribe to mouse click event, thrown by link item */
            this.linkItem.clicked.subscribe((/**
             * @return {?}
             */
            () => this.toggle()));
            /** Subscribe to keyboard event and throw it farther */
            this.linkItem.keyboardTriggered.subscribe((/**
             * @param {?} keyboardEvent
             * @return {?}
             */
            keyboardEvent => this.keyboardTriggered.emit(keyboardEvent)));
        }
        /** Pass this element to popover child item, to allow control `expanded` value */
        if (this.popoverItem) {
            this.popoverItem.parentItemElement = this;
        }
        /** Propagate initial open state to children */
        this.propagateOpenChange(this._expanded);
    }
    /**
     * Method that expand the item and propagate it to children
     * @return {?}
     */
    triggerOpen() {
        if (!this.expanded) {
            /** Propagate initial open state to children */
            this.propagateOpenChange(true);
        }
    }
    /**
     * Method that close the item and propagate it to children
     * @return {?}
     */
    triggerClose() {
        if (this.expanded) {
            /** Propagate initial open state to children */
            this.propagateOpenChange(false);
        }
    }
    /**
     * Method that toggle the item and propagate it to children
     * @return {?}
     */
    toggle() {
        /** Propagate initial open state to children */
        this.propagateOpenChange(!this._expanded);
    }
    /**
     * Method that dispatches `click` event on link item
     * @return {?}
     */
    click() {
        if (this.linkItem) {
            this.linkItem.click();
        }
    }
    /**
     * Method that focuses link item
     * @return {?}
     */
    focus() {
        if (this.linkItem) {
            this.linkItem.focus();
        }
    }
    /**
     * @hidden
     * Propagate open state to all of the children
     * @private
     * @param {?} open
     * @return {?}
     */
    propagateOpenChange(open) {
        this._expanded = open;
        if (this.linkItem) {
            this.linkItem.expanded = open;
        }
        if (this.nestedListItem) {
            this.nestedListItem.hidden = !open;
        }
        if (this.nestedListFromPreparedComponent) {
            this.nestedListFromPreparedComponent.hidden = !open;
        }
        if (this.popoverItem) {
            this.popoverItem.open = open;
        }
        /** Trigger event to provide keyboard support to new list of opened item element. */
        this.keyboardService.refresh$.next();
        this.expandedChange.emit(open);
    }
    /**
     * @hidden
     * @private
     * @return {?}
     */
    get nestedListFromPreparedComponent() {
        return this.preparedListComponent && this.preparedListComponent.nestedListDirective;
    }
}
NestedItemDirective.decorators = [
    { type: Directive, args: [{
                selector: '[fdNestedItem], [fd-nested-list-item]'
            },] }
];
/** @nocollapse */
NestedItemDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: NestedListKeyboardService }
];
NestedItemDirective.propDecorators = {
    fdNestedListItemClass: [{ type: HostBinding, args: ['class.fd-nested-list__item',] }],
    linkItem: [{ type: ContentChild, args: [NestedLinkDirective, { static: false },] }],
    popoverItem: [{ type: ContentChild, args: [NestedListPopoverComponent, { static: false },] }],
    nestedListItem: [{ type: ContentChild, args: [forwardRef((/**
                 * @return {?}
                 */
                () => NestedListDirective)), { static: false },] }],
    preparedListComponent: [{ type: ContentChild, args: [forwardRef((/**
                 * @return {?}
                 */
                () => PreparedNestedListComponent)), { static: false },] }],
    expanded: [{ type: Input }],
    expandedChange: [{ type: Output }],
    keyboardTriggered: [{ type: Output }]
};
if (false) {
    /**
     * @hidden
     * @type {?}
     */
    NestedItemDirective.prototype.fdNestedListItemClass;
    /**
     * @hidden
     * Reference to the link directive, to allow manipulating the properties of this element.
     * @type {?}
     */
    NestedItemDirective.prototype.linkItem;
    /**
     * @hidden
     * @type {?}
     */
    NestedItemDirective.prototype.popoverItem;
    /**
     * @hidden
     * @type {?}
     */
    NestedItemDirective.prototype.nestedListItem;
    /**
     * @hidden
     * @type {?}
     */
    NestedItemDirective.prototype.preparedListComponent;
    /**
     * @hidden
     * @type {?}
     * @private
     */
    NestedItemDirective.prototype._expanded;
    /**
     * Event thrown, when expanded state is changed
     * @type {?}
     */
    NestedItemDirective.prototype.expandedChange;
    /**
     * Event thrown, when any keyboard event is dispatched on this, or link element
     * @type {?}
     */
    NestedItemDirective.prototype.keyboardTriggered;
    /**
     * @type {?}
     * @private
     */
    NestedItemDirective.prototype.elementRef;
    /**
     * @type {?}
     * @private
     */
    NestedItemDirective.prototype.keyboardService;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmVzdGVkLWl0ZW0uZGlyZWN0aXZlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQGZ1bmRhbWVudGFsLW5neC9jb3JlLyIsInNvdXJjZXMiOlsibGliL25lc3RlZC1saXN0L25lc3RlZC1pdGVtL25lc3RlZC1pdGVtLmRpcmVjdGl2ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLE9BQU8sRUFFSCxZQUFZLEVBQ1osU0FBUyxFQUNULFVBQVUsRUFDVixZQUFZLEVBQ1osVUFBVSxFQUNWLFdBQVcsRUFDWCxLQUFLLEVBQ0wsTUFBTSxFQUNULE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBRSxtQkFBbUIsRUFBRSxNQUFNLHNDQUFzQyxDQUFDO0FBQzNFLE9BQU8sRUFBRSx5QkFBeUIsRUFBRSxNQUFNLGlDQUFpQyxDQUFDO0FBQzVFLE9BQU8sRUFBRSwwQkFBMEIsRUFBRSxNQUFNLHNEQUFzRCxDQUFDO0FBRWxHLE9BQU8sRUFBRSxtQkFBbUIsRUFBRSxNQUFNLHNDQUFzQyxDQUFDO0FBQzNFLE9BQU8sRUFBRSwyQkFBMkIsRUFBRSxNQUFNLHdEQUF3RCxDQUFDO0FBS3JHLE1BQU0sT0FBTyxtQkFBbUI7Ozs7OztJQThDNUIsWUFDWSxVQUFzQixFQUN0QixlQUEwQztRQUQxQyxlQUFVLEdBQVYsVUFBVSxDQUFZO1FBQ3RCLG9CQUFlLEdBQWYsZUFBZSxDQUEyQjs7OztRQTVDdEQsMEJBQXFCLEdBQVksSUFBSSxDQUFDOzs7O1FBMEQ5QixjQUFTLEdBQVksS0FBSyxDQUFDOzs7O1FBSTFCLG1CQUFjLEdBQTBCLElBQUksWUFBWSxFQUFXLENBQUM7Ozs7UUFJcEUsc0JBQWlCLEdBQWdDLElBQUksWUFBWSxFQUFpQixDQUFDO0lBckJ6RixDQUFDOzs7OztJQXZCSixJQUFXLFdBQVc7UUFDbEIsT0FBTyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsY0FBYyxJQUFJLElBQUksQ0FBQyxXQUFXLElBQUksSUFBSSxDQUFDLCtCQUErQixDQUFDLENB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QUlOLE1BQU07Ozs7Ozs7SUFsRVAsb0RBQ3NDOzs7Ozs7SUFNdEMsdUNBQzhCOzs7OztJQUc5QiwwQ0FDd0M7Ozs7O0lBR3hDLDZDQUNvQzs7Ozs7SUFHcEMsb0RBQ21EOzs7Ozs7SUF1Q25ELHdDQUFtQzs7Ozs7SUFHbkMsNkNBQzZFOzs7OztJQUc3RSxnREFDNEY7Ozs7O0lBdkJ4Rix5Q0FBOEI7Ozs7O0lBQzlCLDhDQUFrRCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gICAgQWZ0ZXJDb250ZW50SW5pdCxcbiAgICBDb250ZW50Q2hpbGQsXG4gICAgRGlyZWN0aXZlLFxuICAgIEVsZW1lbnRSZWYsXG4gICAgRXZlbnRFbWl0dGVyLFxuICAgIGZvcndhcmRSZWYsXG4gICAgSG9zdEJpbmRpbmcsXG4gICAgSW5wdXQsXG4gICAgT3V0cHV0XG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgTmVzdGVkTGlua0RpcmVjdGl2ZSB9IGZyb20gJy4uL25lc3RlZC1saW5rL25lc3RlZC1saW5rLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBOZXN0ZWRMaXN0S2V5Ym9hcmRTZXJ2aWNlIH0gZnJvbSAnLi4vbmVzdGVkLWxpc3Qta2V5Ym9hcmQuc2VydmljZSc7XG5pbXBvcnQgeyBOZXN0ZWRMaXN0UG9wb3ZlckNvbXBvbmVudCB9IGZyb20gJy4uL25lc3RlZC1saXN0LXBvcG92ZXIvbmVzdGVkLWxpc3QtcG9wb3Zlci5jb21wb25lbnQnO1xuaW1wb3J0IHsgTmVzdGVkSXRlbUludGVyZmFjZSB9IGZyb20gJy4vbmVzdGVkLWl0ZW0uaW50ZXJmYWNlJztcbmltcG9ydCB7IE5lc3RlZExpc3REaXJlY3RpdmUgfSBmcm9tICcuLi9uZXN0ZWQtbGlzdC9uZXN0ZWQtbGlzdC5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgUHJlcGFyZWROZXN0ZWRMaXN0Q29tcG9uZW50IH0gZnJvbSAnLi4vcHJlcGFyZWQtbmVzdGVkLWxpc3QvcHJlcGFyZWQtbmVzdGVkLWxpc3QuY29tcG9uZW50JztcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdbZmROZXN0ZWRJdGVtXSwgW2ZkLW5lc3RlZC1saXN0LWl0ZW1dJ1xufSlcbmV4cG9ydCBjbGFzcyBOZXN0ZWRJdGVtRGlyZWN0aXZlIGltcGxlbWVudHMgQWZ0ZXJDb250ZW50SW5pdCwgTmVzdGVkSXRlbUludGVyZmFjZSB7XG5cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIEBIb3N0QmluZGluZygnY2xhc3MuZmQtbmVzdGVkLWxpc3RfX2l0ZW0nKVxuICAgIGZkTmVzdGVkTGlzdEl0ZW1DbGFzczogYm9vbGVhbiA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogUmVmZXJlbmNlIHRvIHRoZSBsaW5rIGRpcmVjdGl2ZSwgdG8gYWxsb3cgbWFuaXB1bGF0aW5nIHRoZSBwcm9wZXJ0aWVzIG9mIHRoaXMgZWxlbWVudC5cbiAgICAgKi9cbiAgICBAQ29udGVudENoaWxkKE5lc3RlZExpbmtEaXJlY3RpdmUsIHsgc3RhdGljOiBmYWxzZSB9KVxuICAgIGxpbmtJdGVtOiBOZXN0ZWRMaW5rRGlyZWN0aXZlO1xuXG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBAQ29udGVudENoaWxkKE5lc3RlZExpc3RQb3BvdmVyQ29tcG9uZW50LCB7IHN0YXRpYzogZmFsc2UgfSlcbiAgICBwb3BvdmVySXRlbTogTmVzdGVkTGlzdFBvcG92ZXJDb21wb25lbnQ7XG5cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIEBDb250ZW50Q2hpbGQoZm9yd2FyZFJlZigoKSA9PiBOZXN0ZWRMaXN0RGlyZWN0aXZlKSwgeyBzdGF0aWM6IGZhbHNlIH0pXG4gICAgbmVzdGVkTGlzdEl0ZW06IE5lc3RlZExpc3REaXJlY3RpdmU7XG5cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIEBDb250ZW50Q2hpbGQoZm9yd2FyZFJlZigoKSA9PiBQcmVwYXJlZE5lc3RlZExpc3RDb21wb25lbnQpLCB7IHN0YXRpYzogZmFsc2UgfSlcbiAgICBwcmVwYXJlZExpc3RDb21wb25lbnQ6IFByZXBhcmVkTmVzdGVkTGlzdENvbXBvbmVudDtcblxuICAgIC8qKiBDaGVjayBpZiB0aGUgaXRlbSBlbGVtZW50IGhhcyBhbnkgY2hpbGQgKi9cbiAgICBwdWJsaWMgZ2V0IGhhc0NoaWxkcmVuKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gISEodGhpcy5uZXN0ZWRMaXN0SXRlbSB8fCB0aGlzLnBvcG92ZXJJdGVtIHx8IHRoaXMubmVzdGVkTGlzdEZyb21QcmVwYXJlZENvbXBvbmVudCk7XG4gICAgfVxuXG4gICAgLyoqIEdldCBhbGwgb2YgdGhlIGNoaWxkcmVuIGl0ZW0gZWxlbWVudHMgKi9cbiAgICBwdWJsaWMgZ2V0IGFsbENoaWxkcmVuSXRlbXMoKTogTmVzdGVkSXRlbUludGVyZmFjZVtdIHtcbiAgICAgICAgaWYgKHRoaXMubmVzdGVkTGlzdEl0ZW0gJiYgdGhpcy5uZXN0ZWRMaXN0SXRlbS5uZXN0ZWRJdGVtcykge1xuICAgICAgICAgICAgLyoqIEdldCBlbGVtZW50cyBmcm9tIGNoaWxkIGxpc3QgKi9cbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5lc3RlZExpc3RJdGVtLm5lc3RlZEl0ZW1zLnRvQXJyYXkoKTtcblxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMubmVzdGVkTGlzdEZyb21QcmVwYXJlZENvbXBvbmVudCAmJiB0aGlzLm5lc3RlZExpc3RGcm9tUHJlcGFyZWRDb21wb25lbnQubmVzdGVkSXRlbXMpIHtcbiAgICAgICAgICAgIC8qKiBHZXQgZWxlbWVudHMgZnJvbSBjaGlsZCBwcmVwYXJlZCBsaXN0ICBjb21wb25lbnQgKi9cbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5lc3RlZExpc3RGcm9tUHJlcGFyZWRDb21wb25lbnQubmVzdGVkSXRlbXMudG9BcnJheSgpO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIGNvbnN0cnVjdG9yIChcbiAgICAgICAgcHJpdmF0ZSBlbGVtZW50UmVmOiBFbGVtZW50UmVmLFxuICAgICAgICBwcml2YXRlIGtleWJvYXJkU2VydmljZTogTmVzdGVkTGlzdEtleWJvYXJkU2VydmljZVxuICAgICkge31cblxuICAgIC8qKiBXaGV0aGVyIGl0ZW0gc2hvdWxkIGJlIGV4cGFuZGVkICovXG4gICAgQElucHV0KCkgc2V0IGV4cGFuZGVkKGV4cGFuZGVkOiBib29sZWFuKSB7XG4gICAgICAgIHRoaXMucHJvcGFnYXRlT3BlbkNoYW5nZShleHBhbmRlZCk7XG4gICAgfVxuXG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBnZXQgZXhwYW5kZWQoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9leHBhbmRlZDtcbiAgICB9XG5cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIHByaXZhdGUgX2V4cGFuZGVkOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICAvKiogRXZlbnQgdGhyb3duLCB3aGVuIGV4cGFuZGVkIHN0YXRlIGlzIGNoYW5nZWQgKi9cbiAgICBAT3V0cHV0KClcbiAgICByZWFkb25seSBleHBhbmRlZENoYW5nZTogRXZlbnRFbWl0dGVyPGJvb2xlYW4+ID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPigpO1xuXG4gICAgLyoqIEV2ZW50IHRocm93biwgd2hlbiBhbnkga2V5Ym9hcmQgZXZlbnQgaXMgZGlzcGF0Y2hlZCBvbiB0aGlzLCBvciBsaW5rIGVsZW1lbnQgKi9cbiAgICBAT3V0cHV0KClcbiAgICByZWFkb25seSBrZXlib2FyZFRyaWdnZXJlZDogRXZlbnRFbWl0dGVyPEtleWJvYXJkRXZlbnQ+ID0gbmV3IEV2ZW50RW1pdHRlcjxLZXlib2FyZEV2ZW50PigpO1xuXG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBuZ0FmdGVyQ29udGVudEluaXQoKTogdm9pZCB7XG5cbiAgICAgICAgLyoqIFByb3BhZ2F0ZSBoYXNDaGlsZHJlbiBwcm9wZXJ0eSAqL1xuICAgICAgICBpZiAodGhpcy5oYXNDaGlsZHJlbiAmJiB0aGlzLmxpbmtJdGVtKSB7XG4gICAgICAgICAgICB0aGlzLmxpbmtJdGVtLmhhc0NoaWxkcmVuID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMubGlua0l0ZW0uY2hhbmdlRGV0UmVmLmRldGVjdENoYW5nZXMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmxpbmtJdGVtKSB7XG4gICAgICAgICAgICAvKiogU3Vic2NyaWJlIHRvIG1vdXNlIGNsaWNrIGV2ZW50LCB0aHJvd24gYnkgbGluayBpdGVtICovXG4gICAgICAgICAgICB0aGlzLmxpbmtJdGVtLmNsaWNrZWQuc3Vic2NyaWJlKCgpID0+IHRoaXMudG9nZ2xlKCkpO1xuXG4gICAgICAgICAgICAvKiogU3Vic2NyaWJlIHRvIGtleWJvYXJkIGV2ZW50IGFuZCB0aHJvdyBpdCBmYXJ0aGVyICovXG4gICAgICAgICAgICB0aGlzLmxpbmtJdGVtLmtleWJvYXJkVHJpZ2dlcmVkLnN1YnNjcmliZShrZXlib2FyZEV2ZW50ID0+XG4gICAgICAgICAgICAgICAgdGhpcy5rZXlib2FyZFRyaWdnZXJlZC5lbWl0KGtleWJvYXJkRXZlbnQpXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqIFBhc3MgdGhpcyBlbGVtZW50IHRvIHBvcG92ZXIgY2hpbGQgaXRlbSwgdG8gYWxsb3cgY29udHJvbCBgZXhwYW5kZWRgIHZhbHVlICovXG4gICAgICAgIGlmICh0aGlzLnBvcG92ZXJJdGVtKSB7XG4gICAgICAgICAgICB0aGlzLnBvcG92ZXJJdGVtLnBhcmVudEl0ZW1FbGVtZW50ID0gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKiBQcm9wYWdhdGUgaW5pdGlhbCBvcGVuIHN0YXRlIHRvIGNoaWxkcmVuICovXG4gICAgICAgIHRoaXMucHJvcGFnYXRlT3BlbkNoYW5nZSh0aGlzLl9leHBhbmRlZCk7XG4gICAgfVxuXG4gICAgLyoqIE1ldGhvZCB0aGF0IGV4cGFuZCB0aGUgaXRlbSBhbmQgcHJvcGFnYXRlIGl0IHRvIGNoaWxkcmVuICovXG4gICAgdHJpZ2dlck9wZW4oKTogdm9pZCB7XG4gICAgICAgIGlmICghdGhpcy5leHBhbmRlZCkge1xuICAgICAgICAgICAgLyoqIFByb3BhZ2F0ZSBpbml0aWFsIG9wZW4gc3RhdGUgdG8gY2hpbGRyZW4gKi9cbiAgICAgICAgICAgIHRoaXMucHJvcGFnYXRlT3BlbkNoYW5nZSh0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBNZXRob2QgdGhhdCBjbG9zZSB0aGUgaXRlbSBhbmQgcHJvcGFnYXRlIGl0IHRvIGNoaWxkcmVuICovXG4gICAgdHJpZ2dlckNsb3NlKCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5leHBhbmRlZCkge1xuICAgICAgICAgICAgLyoqIFByb3BhZ2F0ZSBpbml0aWFsIG9wZW4gc3RhdGUgdG8gY2hpbGRyZW4gKi9cbiAgICAgICAgICAgIHRoaXMucHJvcGFnYXRlT3BlbkNoYW5nZShmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogTWV0aG9kIHRoYXQgdG9nZ2xlIHRoZSBpdGVtIGFuZCBwcm9wYWdhdGUgaXQgdG8gY2hpbGRyZW4gKi9cbiAgICB0b2dnbGUoKTogdm9pZCB7XG4gICAgICAgIC8qKiBQcm9wYWdhdGUgaW5pdGlhbCBvcGVuIHN0YXRlIHRvIGNoaWxkcmVuICovXG4gICAgICAgIHRoaXMucHJvcGFnYXRlT3BlbkNoYW5nZSghdGhpcy5fZXhwYW5kZWQpO1xuICAgIH1cblxuICAgIC8qKiBNZXRob2QgdGhhdCBkaXNwYXRjaGVzIGBjbGlja2AgZXZlbnQgb24gbGluayBpdGVtKi9cbiAgICBjbGljaygpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMubGlua0l0ZW0pIHtcbiAgICAgICAgICAgIHRoaXMubGlua0l0ZW0uY2xpY2soKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBNZXRob2QgdGhhdCBmb2N1c2VzIGxpbmsgaXRlbSovXG4gICAgZm9jdXMoKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLmxpbmtJdGVtKSB7XG4gICAgICAgICAgICB0aGlzLmxpbmtJdGVtLmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogUHJvcGFnYXRlIG9wZW4gc3RhdGUgdG8gYWxsIG9mIHRoZSBjaGlsZHJlblxuICAgICAqL1xuICAgIHByaXZhdGUgcHJvcGFnYXRlT3BlbkNoYW5nZShvcGVuOiBib29sZWFuKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX2V4cGFuZGVkID0gb3BlbjtcblxuICAgICAgICBpZiAodGhpcy5saW5rSXRlbSkge1xuICAgICAgICAgICAgdGhpcy5saW5rSXRlbS5leHBhbmRlZCA9IG9wZW47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5uZXN0ZWRMaXN0SXRlbSkge1xuICAgICAgICAgICAgdGhpcy5uZXN0ZWRMaXN0SXRlbS5oaWRkZW4gPSAhb3BlbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm5lc3RlZExpc3RGcm9tUHJlcGFyZWRDb21wb25lbnQpIHtcbiAgICAgICAgICAgIHRoaXMubmVzdGVkTGlzdEZyb21QcmVwYXJlZENvbXBvbmVudC5oaWRkZW4gPSAhb3BlbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnBvcG92ZXJJdGVtKSB7XG4gICAgICAgICAgICB0aGlzLnBvcG92ZXJJdGVtLm9wZW4gPSBvcGVuO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqIFRyaWdnZXIgZXZlbnQgdG8gcHJvdmlkZSBrZXlib2FyZCBzdXBwb3J0IHRvIG5ldyBsaXN0IG9mIG9wZW5lZCBpdGVtIGVsZW1lbnQuICovXG4gICAgICAgIHRoaXMua2V5Ym9hcmRTZXJ2aWNlLnJlZnJlc2gkLm5leHQoKTtcbiAgICAgICAgdGhpcy5leHBhbmRlZENoYW5nZS5lbWl0KG9wZW4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcml2YXRlIGdldCBuZXN0ZWRMaXN0RnJvbVByZXBhcmVkQ29tcG9uZW50KCk6IE5lc3RlZExpc3REaXJlY3RpdmUge1xuICAgICAgICByZXR1cm4gdGhpcy5wcmVwYXJlZExpc3RDb21wb25lbnQgJiYgdGhpcy5wcmVwYXJlZExpc3RDb21wb25lbnQubmVzdGVkTGlzdERpcmVjdGl2ZTtcbiAgICB9XG5cbn1cbiJdfQ==