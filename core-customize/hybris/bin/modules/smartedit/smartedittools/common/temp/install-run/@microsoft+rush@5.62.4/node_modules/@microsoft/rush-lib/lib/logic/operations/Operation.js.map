{"version":3,"file":"Operation.js","sourceRoot":"","sources":["../../../src/logic/operations/Operation.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D;;;AAU3D;;;;GAIG;AACH,MAAa,SAAS;IA2EpB,YAAmB,MAAwB,EAAE,aAA8B;QA5D3E;;;WAGG;QACI,iBAAY,GAAmB,IAAI,GAAG,EAAa,CAAC;QAE3D;;WAEG;QACI,eAAU,GAAmB,IAAI,GAAG,EAAa,CAAC;QAoDvD,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;QACrB,IAAI,CAAC,MAAM,GAAG,aAAa,CAAC;IAC9B,CAAC;IAED,IAAW,IAAI;QACb,OAAO,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC;IAC1B,CAAC;CACF;AAnFD,8BAmFC","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport { StdioSummarizer } from '@rushstack/terminal';\nimport { CollatedWriter } from '@rushstack/stream-collator';\n\nimport { Stopwatch } from '../../utilities/Stopwatch';\nimport { OperationStatus } from './OperationStatus';\nimport { OperationError } from './OperationError';\nimport { IOperationRunner } from './IOperationRunner';\n\n/**\n * The `Operation` class is a node in the dependency graph of work that needs to be scheduled by the\n * `OperationExecutionManager`. Each `Operation` has a `runner` member of type `IOperationRunner`, whose\n * implementation manages the actual process of running a single operation.\n */\nexport class Operation {\n  /**\n   * When the scheduler is ready to process this `Operation`, the `runner` implements the actual work of\n   * running the operation.\n   */\n  public runner: IOperationRunner;\n\n  /**\n   * The current execution status of an operation. Operations start in the 'ready' state,\n   * but can be 'blocked' if an upstream operation failed. It is 'executing' when\n   * the operation is executing. Once execution is complete, it is either 'success' or\n   * 'failure'.\n   */\n  public status: OperationStatus;\n\n  /**\n   * A set of all dependencies which must be executed before this operation is complete.\n   * When dependencies finish execution, they are removed from this list.\n   */\n  public dependencies: Set<Operation> = new Set<Operation>();\n\n  /**\n   * The inverse of dependencies, lists all projects which are directly dependent on this one.\n   */\n  public dependents: Set<Operation> = new Set<Operation>();\n\n  /**\n   * This number represents how far away this Operation is from the furthest \"root\" project (i.e.\n   * a project with no dependents). This helps us to calculate the critical path (i.e. the\n   * longest chain of projects which must be executed in order, thereby limiting execution speed\n   * of the entire operation tree.\n   *\n   * This number is calculated via a memoized depth-first search, and when choosing the next\n   * operation to execute, the operation with the highest criticalPathLength is chosen.\n   *\n   * Example:\n   *        (0) A\n   *             \\\n   *          (1) B     C (0)         (applications)\n   *               \\   /|\\\n   *                \\ / | \\\n   *             (2) D  |  X (1)      (utilities)\n   *                    | / \\\n   *                    |/   \\\n   *                (2) Y     Z (2)   (other utilities)\n   *\n   * All roots (A & C) have a criticalPathLength of 0.\n   * B has a score of 1, since A depends on it.\n   * D has a score of 2, since we look at the longest chain (e.g D->B->A is longer than D->C)\n   * X has a score of 1, since the only package which depends on it is A\n   * Z has a score of 2, since only X depends on it, and X has a score of 1\n   * Y has a score of 2, since the chain Y->X->C is longer than Y->C\n   *\n   * The algorithm is implemented in AsyncOperationQueue.ts as calculateCriticalPathLength()\n   */\n  public criticalPathLength: number | undefined;\n\n  /**\n   * The error which occurred while executing this operation, this is stored in case we need\n   * it later (for example to re-print errors at end of execution).\n   */\n  public error: OperationError | undefined;\n\n  /**\n   * The operation writer which contains information from the output streams of this operation\n   */\n  public collatedWriter!: CollatedWriter;\n\n  public stdioSummarizer!: StdioSummarizer;\n\n  /**\n   * The stopwatch which measures how long it takes the operation to execute\n   */\n  public stopwatch!: Stopwatch;\n\n  public constructor(runner: IOperationRunner, initialStatus: OperationStatus) {\n    this.runner = runner;\n    this.status = initialStatus;\n  }\n\n  public get name(): string {\n    return this.runner.name;\n  }\n}\n"]}