/**
 * @fileoverview added by tsickle
 * Generated from: lib/calendar/calendar-views/calendar-year-view/calendar-year-view.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Component, ViewEncapsulation, Output, Input, EventEmitter, ElementRef, ChangeDetectionStrategy, ChangeDetectorRef } from '@angular/core';
import { FdDate } from '../../models/fd-date';
import { takeUntil } from 'rxjs/operators';
import { CalendarService } from '../../calendar.service';
import { Subject } from 'rxjs';
/**
 * Component representing the YearView of the Calendar Component.
 */
var CalendarYearViewComponent = /** @class */ (function () {
    /** @hidden */
    function CalendarYearViewComponent(eRef, changeDetectorRef, calendarService) {
        this.eRef = eRef;
        this.changeDetectorRef = changeDetectorRef;
        this.calendarService = calendarService;
        this._amountOfColPerRow = 4;
        /**
         * Parameter storing the year of the present day.
         */
        this.currentYear = FdDate.getToday().year;
        /**
         * Parameter storing first shown year on list
         */
        this.firstYearInList = this.currentYear;
        /**
         * An RxJS Subject that will kill the data stream upon component’s destruction (for unsubscribing)
         */
        this.onDestroy$ = new Subject();
        /**
         * Event fired when a year is selected.
         */
        this.yearClicked = new EventEmitter();
    }
    /** @hidden */
    /**
     * @hidden
     * @return {?}
     */
    CalendarYearViewComponent.prototype.ngAfterViewChecked = /**
     * @hidden
     * @return {?}
     */
    function () {
        if (this.newFocusedYearId) {
            this.focusElement(this.newFocusedYearId);
            this.newFocusedYearId = null;
        }
    };
    /** @hidden */
    /**
     * @hidden
     * @return {?}
     */
    CalendarYearViewComponent.prototype.ngOnInit = /**
     * @hidden
     * @return {?}
     */
    function () {
        var _this = this;
        this.firstYearInList = this.yearSelected;
        this.constructYearGrid();
        this.calendarService.onFocusIdChange
            .pipe(takeUntil(this.onDestroy$))
            .subscribe((/**
         * @param {?} index
         * @return {?}
         */
        function (index) {
            _this.newFocusedYearId = _this.id + '-fd-year-' + index;
            _this.focusElement(_this.newFocusedYearId);
        }));
        this.calendarService.focusEscapeFunction = this.focusEscapeFunction;
        this.calendarService.onKeySelect
            .pipe(takeUntil(this.onDestroy$))
            .subscribe((/**
         * @param {?} index
         * @return {?}
         */
        function (index) { return _this.selectYear(_this.getYearList()[index]); }));
        this.calendarService.onListStartApproach
            .pipe(takeUntil(this.onDestroy$))
            .subscribe((/**
         * @return {?}
         */
        function () { return _this.loadPreviousYearList(); }));
        this.calendarService.onListEndApproach
            .pipe(takeUntil(this.onDestroy$))
            .subscribe((/**
         * @return {?}
         */
        function () { return _this.loadNextYearList(); }));
    };
    /** @hidden */
    /**
     * @hidden
     * @return {?}
     */
    CalendarYearViewComponent.prototype.ngOnDestroy = /**
     * @hidden
     * @return {?}
     */
    function () {
        this.onDestroy$.next();
        this.onDestroy$.complete();
    };
    /**
     * Method that returns active cell, which means:
     * if there is any selected year, return selected year
     * if there is no selected year, but there is current year, return current year
     * if there is no current year, or selected, return first one
     */
    /**
     * Method that returns active cell, which means:
     * if there is any selected year, return selected year
     * if there is no selected year, but there is current year, return current year
     * if there is no current year, or selected, return first one
     * @private
     * @return {?}
     */
    CalendarYearViewComponent.prototype.getActiveYear = /**
     * Method that returns active cell, which means:
     * if there is any selected year, return selected year
     * if there is no selected year, but there is current year, return current year
     * if there is no current year, or selected, return first one
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var selectedYear = this.getYearList().find((/**
         * @param {?} year
         * @return {?}
         */
        function (year) { return year === _this.yearSelected; }));
        if (selectedYear) {
            return selectedYear;
        }
        /** @type {?} */
        var currentYear = this.getYearList().find((/**
         * @param {?} year
         * @return {?}
         */
        function (year) { return year === _this.currentYear; }));
        if (currentYear) {
            return currentYear;
        }
        return this.calendarYearListGrid[0][0];
    };
    /** Method for handling the keyboard navigation. */
    /**
     * Method for handling the keyboard navigation.
     * @param {?} event
     * @param {?} index
     * @return {?}
     */
    CalendarYearViewComponent.prototype.onKeydownYearHandler = /**
     * Method for handling the keyboard navigation.
     * @param {?} event
     * @param {?} index
     * @return {?}
     */
    function (event, index) {
        this.calendarService.onKeydownHandler(event, index);
    };
    /** Method used to load the previous 12 years to be displayed. */
    /**
     * Method used to load the previous 12 years to be displayed.
     * @return {?}
     */
    CalendarYearViewComponent.prototype.loadNextYearList = /**
     * Method used to load the previous 12 years to be displayed.
     * @return {?}
     */
    function () {
        this.firstYearInList += 12;
        this.constructYearGrid();
    };
    /** Method used to load the next 12 years to be displayed. */
    /**
     * Method used to load the next 12 years to be displayed.
     * @return {?}
     */
    CalendarYearViewComponent.prototype.loadPreviousYearList = /**
     * Method used to load the next 12 years to be displayed.
     * @return {?}
     */
    function () {
        this.firstYearInList -= 12;
        this.constructYearGrid();
    };
    /** Method allowing focusing on elements within this component. */
    /**
     * Method allowing focusing on elements within this component.
     * @param {?} elementSelector
     * @return {?}
     */
    CalendarYearViewComponent.prototype.focusElement = /**
     * Method allowing focusing on elements within this component.
     * @param {?} elementSelector
     * @return {?}
     */
    function (elementSelector) {
        var _this = this;
        setTimeout((/**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var elementToFocus = _this.eRef.nativeElement.querySelector('#' + elementSelector);
            if (elementToFocus) {
                _this.eRef.nativeElement.querySelector('#' + elementSelector).focus();
            }
        }), 0);
    };
    /** Method that sends the year to the parent component when it is clicked. */
    /**
     * Method that sends the year to the parent component when it is clicked.
     * @param {?} selectedYear
     * @param {?=} event
     * @return {?}
     */
    CalendarYearViewComponent.prototype.selectYear = /**
     * Method that sends the year to the parent component when it is clicked.
     * @param {?} selectedYear
     * @param {?=} event
     * @return {?}
     */
    function (selectedYear, event) {
        if (event) {
            event.stopPropagation();
        }
        this.yearSelected = selectedYear;
        this.yearClicked.emit(this.yearSelected);
    };
    /**
     * @param {?} rowIndex
     * @param {?} colIndex
     * @return {?}
     */
    CalendarYearViewComponent.prototype.getId = /**
     * @param {?} rowIndex
     * @param {?} colIndex
     * @return {?}
     */
    function (rowIndex, colIndex) {
        return rowIndex * this._amountOfColPerRow + colIndex;
    };
    /** @hidden */
    /**
     * @hidden
     * @private
     * @return {?}
     */
    CalendarYearViewComponent.prototype.constructYearGrid = /**
     * @hidden
     * @private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var displayedYearsAmount = 12;
        /** @type {?} */
        var calendarYearList = [];
        this.calendarYearListGrid = [];
        for (var x = 0; x < displayedYearsAmount; ++x) {
            calendarYearList.push(this.firstYearInList + x);
        }
        /** Creating 2d grid */
        while (calendarYearList.length) {
            this.calendarYearListGrid.push(calendarYearList.splice(0, this._amountOfColPerRow));
        }
        this.activeYear = this.getActiveYear();
        this.changeDetectorRef.markForCheck();
    };
    /** Returns transformed 1d array from 2d year grid. */
    /**
     * Returns transformed 1d array from 2d year grid.
     * @private
     * @return {?}
     */
    CalendarYearViewComponent.prototype.getYearList = /**
     * Returns transformed 1d array from 2d year grid.
     * @private
     * @return {?}
     */
    function () {
        return [].concat.apply([], this.calendarYearListGrid);
    };
    CalendarYearViewComponent.decorators = [
        { type: Component, args: [{
                    selector: 'fd-calendar-year-view',
                    template: "<div class=\"fd-calendar__years\">\n    <table class=\"fd-calendar__table\" role=\"grid\">\n        <tbody class=\"fd-calendar__group\">\n        <tr class=\"fd-calendar__row\"\n            *ngFor=\"let colYears of calendarYearListGrid; let rowIndex = index\">\n            <td class=\"fd-calendar__item\"\n                *ngFor=\"let year of colYears; let colIndex = index\"\n                [ngClass]=\"{\n                    'is-selected': (year == yearSelected),\n                    'fd-calendar__item--current': (year == currentYear)\n                }\"\n                [attr.id]=\"id + '-fd-year-' + getId(rowIndex, colIndex)\"\n                [attr.tabindex]=\"year === activeYear ? 0 : -1\"\n                (keydown)=\"onKeydownYearHandler($event, getId(rowIndex, colIndex))\"\n                (click)=\"selectYear(year, $event)\">\n                <span role=\"button\" class=\"fd-calendar__text\">\n                    {{ year }}\n                </span>\n            </td>\n        </tr>\n        </tbody>\n    </table>\n</div>\n",
                    encapsulation: ViewEncapsulation.None,
                    host: {
                        '[attr.id]': 'id + "-year-view"'
                    },
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    styles: [""]
                }] }
    ];
    /** @nocollapse */
    CalendarYearViewComponent.ctorParameters = function () { return [
        { type: ElementRef },
        { type: ChangeDetectorRef },
        { type: CalendarService }
    ]; };
    CalendarYearViewComponent.propDecorators = {
        id: [{ type: Input }],
        focusEscapeFunction: [{ type: Input }],
        yearSelected: [{ type: Input }],
        yearClicked: [{ type: Output }]
    };
    return CalendarYearViewComponent;
}());
export { CalendarYearViewComponent };
if (false) {
    /**
     * @type {?}
     * @private
     */
    CalendarYearViewComponent.prototype._amountOfColPerRow;
    /**
     * @hidden
     *  This variable is used to define which year from calendarYearList should be focusable by tab key
     * @type {?}
     */
    CalendarYearViewComponent.prototype.activeYear;
    /**
     * Parameter that stores the dozen of years that are currently being displayed.
     * @type {?}
     */
    CalendarYearViewComponent.prototype.calendarYearListGrid;
    /**
     * Parameter storing the year of the present day.
     * @type {?}
     */
    CalendarYearViewComponent.prototype.currentYear;
    /**
     * Parameter storing first shown year on list
     * @type {?}
     */
    CalendarYearViewComponent.prototype.firstYearInList;
    /**
     * An RxJS Subject that will kill the data stream upon component’s destruction (for unsubscribing)
     * @type {?}
     * @private
     */
    CalendarYearViewComponent.prototype.onDestroy$;
    /**
     * @hidden
     * @type {?}
     * @private
     */
    CalendarYearViewComponent.prototype.newFocusedYearId;
    /**
     * Parameter used in id of years used for help with focusing on the correct element during keyboard navigation.
     * @type {?}
     */
    CalendarYearViewComponent.prototype.id;
    /**
     * Function that is called when the focus would escape the element.
     * @type {?}
     */
    CalendarYearViewComponent.prototype.focusEscapeFunction;
    /**
     * Parameter holding the year that is currently selected.
     * @type {?}
     */
    CalendarYearViewComponent.prototype.yearSelected;
    /**
     * Event fired when a year is selected.
     * @type {?}
     */
    CalendarYearViewComponent.prototype.yearClicked;
    /**
     * @type {?}
     * @private
     */
    CalendarYearViewComponent.prototype.eRef;
    /**
     * @type {?}
     * @private
     */
    CalendarYearViewComponent.prototype.changeDetectorRef;
    /**
     * @type {?}
     * @private
     */
    CalendarYearViewComponent.prototype.calendarService;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2FsZW5kYXIteWVhci12aWV3LmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BmdW5kYW1lbnRhbC1uZ3gvY29yZS8iLCJzb3VyY2VzIjpbImxpYi9jYWxlbmRhci9jYWxlbmRhci12aWV3cy9jYWxlbmRhci15ZWFyLXZpZXcvY2FsZW5kYXIteWVhci12aWV3LmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLE9BQU8sRUFDSCxTQUFTLEVBRVQsaUJBQWlCLEVBQ2pCLE1BQU0sRUFDTixLQUFLLEVBQ0wsWUFBWSxFQUNaLFVBQVUsRUFHVix1QkFBdUIsRUFBRSxpQkFBaUIsRUFDN0MsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFFLE1BQU0sRUFBRSxNQUFNLHNCQUFzQixDQUFDO0FBQzlDLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUMzQyxPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0sd0JBQXdCLENBQUM7QUFDekQsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLE1BQU0sQ0FBQzs7OztBQUcvQjtJQWtESSxjQUFjO0lBQ2QsbUNBQ1ksSUFBZ0IsRUFDaEIsaUJBQW9DLEVBQ3BDLGVBQWdDO1FBRmhDLFNBQUksR0FBSixJQUFJLENBQVk7UUFDaEIsc0JBQWlCLEdBQWpCLGlCQUFpQixDQUFtQjtRQUNwQyxvQkFBZSxHQUFmLGVBQWUsQ0FBaUI7UUExQzNCLHVCQUFrQixHQUFXLENBQUMsQ0FBQzs7OztRQVdoRCxnQkFBVyxHQUFXLE1BQU0sQ0FBQyxRQUFRLEVBQUUsQ0FBQyxJQUFJLENBQUM7Ozs7UUFHN0Msb0JBQWUsR0FBVyxJQUFJLENBQUMsV0FBVyxDQUFDOzs7O1FBRzFCLGVBQVUsR0FBa0IsSUFBSSxPQUFPLEVBQVEsQ0FBQzs7OztRQW1CeEQsZ0JBQVcsR0FBeUIsSUFBSSxZQUFZLEVBQVUsQ0FBQztJQU94RSxDQUFDO0lBRUQsY0FBYzs7Ozs7SUFDZCxzREFBa0I7Ozs7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SUwsS0FBSzs4QkFJTCxNQUFNOztJQXNJWCxnQ0FBQztDQUFBLEFBckxELElBcUxDO1NBM0tZLHlCQUF5Qjs7Ozs7O0lBRWxDLHVEQUFnRDs7Ozs7O0lBS2hELCtDQUFtQjs7Ozs7SUFHbkIseURBQWlDOzs7OztJQUdqQyxnREFBNkM7Ozs7O0lBRzdDLG9EQUEyQzs7Ozs7O0lBRzNDLCtDQUFpRTs7Ozs7O0lBR2pFLHFEQUFpQzs7Ozs7SUFHakMsdUNBQ1c7Ozs7O0lBR1gsd0RBQzhCOzs7OztJQUc5QixpREFDcUI7Ozs7O0lBR3JCLGdEQUN3RTs7Ozs7SUFJcEUseUNBQXdCOzs7OztJQUN4QixzREFBNEM7Ozs7O0lBQzVDLG9EQUF3QyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gICAgQ29tcG9uZW50LFxuICAgIE9uSW5pdCxcbiAgICBWaWV3RW5jYXBzdWxhdGlvbixcbiAgICBPdXRwdXQsXG4gICAgSW5wdXQsXG4gICAgRXZlbnRFbWl0dGVyLFxuICAgIEVsZW1lbnRSZWYsXG4gICAgQWZ0ZXJWaWV3Q2hlY2tlZCxcbiAgICBPbkRlc3Ryb3ksXG4gICAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksIENoYW5nZURldGVjdG9yUmVmXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRmREYXRlIH0gZnJvbSAnLi4vLi4vbW9kZWxzL2ZkLWRhdGUnO1xuaW1wb3J0IHsgdGFrZVVudGlsIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgQ2FsZW5kYXJTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vY2FsZW5kYXIuc2VydmljZSc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5cbi8qKiBDb21wb25lbnQgcmVwcmVzZW50aW5nIHRoZSBZZWFyVmlldyBvZiB0aGUgQ2FsZW5kYXIgQ29tcG9uZW50LiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdmZC1jYWxlbmRhci15ZWFyLXZpZXcnLFxuICAgIHRlbXBsYXRlVXJsOiAnLi9jYWxlbmRhci15ZWFyLXZpZXcuY29tcG9uZW50Lmh0bWwnLFxuICAgIHN0eWxlVXJsczogWycuL2NhbGVuZGFyLXllYXItdmlldy5jb21wb25lbnQuc2NzcyddLFxuICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gICAgaG9zdDoge1xuICAgICAgICAnW2F0dHIuaWRdJzogJ2lkICsgXCIteWVhci12aWV3XCInXG4gICAgfSxcbiAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxufSlcbmV4cG9ydCBjbGFzcyBDYWxlbmRhclllYXJWaWV3Q29tcG9uZW50IGltcGxlbWVudHMgQWZ0ZXJWaWV3Q2hlY2tlZCwgT25Jbml0LCBPbkRlc3Ryb3kge1xuXG4gICAgcHJpdmF0ZSByZWFkb25seSBfYW1vdW50T2ZDb2xQZXJSb3c6IG51bWJlciA9IDQ7XG5cbiAgICAvKiogQGhpZGRlblxuICAgICAqICBUaGlzIHZhcmlhYmxlIGlzIHVzZWQgdG8gZGVmaW5lIHdoaWNoIHllYXIgZnJvbSBjYWxlbmRhclllYXJMaXN0IHNob3VsZCBiZSBmb2N1c2FibGUgYnkgdGFiIGtleVxuICAgICAqL1xuICAgIGFjdGl2ZVllYXI6IG51bWJlcjtcblxuICAgIC8qKiBQYXJhbWV0ZXIgdGhhdCBzdG9yZXMgdGhlIGRvemVuIG9mIHllYXJzIHRoYXQgYXJlIGN1cnJlbnRseSBiZWluZyBkaXNwbGF5ZWQuICovXG4gICAgY2FsZW5kYXJZZWFyTGlzdEdyaWQ6IG51bWJlcltdW107XG5cbiAgICAvKiogUGFyYW1ldGVyIHN0b3JpbmcgdGhlIHllYXIgb2YgdGhlIHByZXNlbnQgZGF5LiAqL1xuICAgIGN1cnJlbnRZZWFyOiBudW1iZXIgPSBGZERhdGUuZ2V0VG9kYXkoKS55ZWFyO1xuXG4gICAgLyoqIFBhcmFtZXRlciBzdG9yaW5nIGZpcnN0IHNob3duIHllYXIgb24gbGlzdCAqL1xuICAgIGZpcnN0WWVhckluTGlzdDogbnVtYmVyID0gdGhpcy5jdXJyZW50WWVhcjtcblxuICAgIC8qKiBBbiBSeEpTIFN1YmplY3QgdGhhdCB3aWxsIGtpbGwgdGhlIGRhdGEgc3RyZWFtIHVwb24gY29tcG9uZW504oCZcyBkZXN0cnVjdGlvbiAoZm9yIHVuc3Vic2NyaWJpbmcpICAqL1xuICAgIHByaXZhdGUgcmVhZG9ubHkgb25EZXN0cm95JDogU3ViamVjdDx2b2lkPiA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG5cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIHByaXZhdGUgbmV3Rm9jdXNlZFllYXJJZDogc3RyaW5nO1xuXG4gICAgLyoqIFBhcmFtZXRlciB1c2VkIGluIGlkIG9mIHllYXJzIHVzZWQgZm9yIGhlbHAgd2l0aCBmb2N1c2luZyBvbiB0aGUgY29ycmVjdCBlbGVtZW50IGR1cmluZyBrZXlib2FyZCBuYXZpZ2F0aW9uLiAqL1xuICAgIEBJbnB1dCgpXG4gICAgaWQ6IHN0cmluZztcblxuICAgIC8qKiBGdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aGVuIHRoZSBmb2N1cyB3b3VsZCBlc2NhcGUgdGhlIGVsZW1lbnQuICovXG4gICAgQElucHV0KClcbiAgICBmb2N1c0VzY2FwZUZ1bmN0aW9uOiBGdW5jdGlvbjtcblxuICAgIC8qKiBQYXJhbWV0ZXIgaG9sZGluZyB0aGUgeWVhciB0aGF0IGlzIGN1cnJlbnRseSBzZWxlY3RlZC4gKi9cbiAgICBASW5wdXQoKVxuICAgIHllYXJTZWxlY3RlZDogbnVtYmVyO1xuXG4gICAgLyoqIEV2ZW50IGZpcmVkIHdoZW4gYSB5ZWFyIGlzIHNlbGVjdGVkLiAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHJlYWRvbmx5IHllYXJDbGlja2VkOiBFdmVudEVtaXR0ZXI8bnVtYmVyPiA9IG5ldyBFdmVudEVtaXR0ZXI8bnVtYmVyPigpO1xuXG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHJpdmF0ZSBlUmVmOiBFbGVtZW50UmVmLFxuICAgICAgICBwcml2YXRlIGNoYW5nZURldGVjdG9yUmVmOiBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICAgICAgcHJpdmF0ZSBjYWxlbmRhclNlcnZpY2U6IENhbGVuZGFyU2VydmljZSkge1xuICAgIH1cblxuICAgIC8qKiBAaGlkZGVuICovXG4gICAgbmdBZnRlclZpZXdDaGVja2VkKCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5uZXdGb2N1c2VkWWVhcklkKSB7XG4gICAgICAgICAgICB0aGlzLmZvY3VzRWxlbWVudCh0aGlzLm5ld0ZvY3VzZWRZZWFySWQpO1xuICAgICAgICAgICAgdGhpcy5uZXdGb2N1c2VkWWVhcklkID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBAaGlkZGVuICovXG4gICAgbmdPbkluaXQoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZmlyc3RZZWFySW5MaXN0ID0gdGhpcy55ZWFyU2VsZWN0ZWQ7XG4gICAgICAgIHRoaXMuY29uc3RydWN0WWVhckdyaWQoKTtcblxuICAgICAgICB0aGlzLmNhbGVuZGFyU2VydmljZS5vbkZvY3VzSWRDaGFuZ2VcbiAgICAgICAgICAgIC5waXBlKHRha2VVbnRpbCh0aGlzLm9uRGVzdHJveSQpKVxuICAgICAgICAgICAgLnN1YnNjcmliZShpbmRleCA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXdGb2N1c2VkWWVhcklkID0gdGhpcy5pZCArICctZmQteWVhci0nICsgaW5kZXg7XG4gICAgICAgICAgICAgICAgdGhpcy5mb2N1c0VsZW1lbnQodGhpcy5uZXdGb2N1c2VkWWVhcklkKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIDtcbiAgICAgICAgdGhpcy5jYWxlbmRhclNlcnZpY2UuZm9jdXNFc2NhcGVGdW5jdGlvbiA9IHRoaXMuZm9jdXNFc2NhcGVGdW5jdGlvbjtcblxuICAgICAgICB0aGlzLmNhbGVuZGFyU2VydmljZS5vbktleVNlbGVjdFxuICAgICAgICAgICAgLnBpcGUodGFrZVVudGlsKHRoaXMub25EZXN0cm95JCkpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKGluZGV4ID0+IHRoaXMuc2VsZWN0WWVhcih0aGlzLmdldFllYXJMaXN0KClbaW5kZXhdKSlcbiAgICAgICAgO1xuXG4gICAgICAgIHRoaXMuY2FsZW5kYXJTZXJ2aWNlLm9uTGlzdFN0YXJ0QXBwcm9hY2hcbiAgICAgICAgICAgIC5waXBlKHRha2VVbnRpbCh0aGlzLm9uRGVzdHJveSQpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgoKSA9PiB0aGlzLmxvYWRQcmV2aW91c1llYXJMaXN0KCkpXG4gICAgICAgIDtcblxuICAgICAgICB0aGlzLmNhbGVuZGFyU2VydmljZS5vbkxpc3RFbmRBcHByb2FjaFxuICAgICAgICAgICAgLnBpcGUodGFrZVVudGlsKHRoaXMub25EZXN0cm95JCkpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKCgpID0+IHRoaXMubG9hZE5leHRZZWFyTGlzdCgpKVxuICAgICAgICA7XG4gICAgfVxuXG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5vbkRlc3Ryb3kkLm5leHQoKTtcbiAgICAgICAgdGhpcy5vbkRlc3Ryb3kkLmNvbXBsZXRlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHRoYXQgcmV0dXJucyBhY3RpdmUgY2VsbCwgd2hpY2ggbWVhbnM6XG4gICAgICogaWYgdGhlcmUgaXMgYW55IHNlbGVjdGVkIHllYXIsIHJldHVybiBzZWxlY3RlZCB5ZWFyXG4gICAgICogaWYgdGhlcmUgaXMgbm8gc2VsZWN0ZWQgeWVhciwgYnV0IHRoZXJlIGlzIGN1cnJlbnQgeWVhciwgcmV0dXJuIGN1cnJlbnQgeWVhclxuICAgICAqIGlmIHRoZXJlIGlzIG5vIGN1cnJlbnQgeWVhciwgb3Igc2VsZWN0ZWQsIHJldHVybiBmaXJzdCBvbmVcbiAgICAgKi9cbiAgICBwcml2YXRlIGdldEFjdGl2ZVllYXIoKTogbnVtYmVyIHtcbiAgICAgICAgY29uc3Qgc2VsZWN0ZWRZZWFyOiBudW1iZXIgPSB0aGlzLmdldFllYXJMaXN0KCkuZmluZCh5ZWFyID0+IHllYXIgPT09IHRoaXMueWVhclNlbGVjdGVkKTtcbiAgICAgICAgaWYgKHNlbGVjdGVkWWVhcikge1xuICAgICAgICAgICAgcmV0dXJuIHNlbGVjdGVkWWVhcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGN1cnJlbnRZZWFyOiBudW1iZXIgPSB0aGlzLmdldFllYXJMaXN0KCkuZmluZCh5ZWFyID0+IHllYXIgPT09IHRoaXMuY3VycmVudFllYXIpO1xuICAgICAgICBpZiAoY3VycmVudFllYXIpIHtcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50WWVhcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmNhbGVuZGFyWWVhckxpc3RHcmlkWzBdWzBdO1xuICAgIH1cblxuICAgIC8qKiBNZXRob2QgZm9yIGhhbmRsaW5nIHRoZSBrZXlib2FyZCBuYXZpZ2F0aW9uLiAqL1xuICAgIG9uS2V5ZG93blllYXJIYW5kbGVyKGV2ZW50LCBpbmRleDogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIHRoaXMuY2FsZW5kYXJTZXJ2aWNlLm9uS2V5ZG93bkhhbmRsZXIoZXZlbnQsIGluZGV4KTtcbiAgICB9XG5cbiAgICAvKiogTWV0aG9kIHVzZWQgdG8gbG9hZCB0aGUgcHJldmlvdXMgMTIgeWVhcnMgdG8gYmUgZGlzcGxheWVkLiAqL1xuICAgIGxvYWROZXh0WWVhckxpc3QoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZmlyc3RZZWFySW5MaXN0ICs9IDEyO1xuICAgICAgICB0aGlzLmNvbnN0cnVjdFllYXJHcmlkKCk7XG4gICAgfVxuXG4gICAgLyoqIE1ldGhvZCB1c2VkIHRvIGxvYWQgdGhlIG5leHQgMTIgeWVhcnMgdG8gYmUgZGlzcGxheWVkLiAqL1xuICAgIGxvYWRQcmV2aW91c1llYXJMaXN0KCk6IHZvaWQge1xuICAgICAgICB0aGlzLmZpcnN0WWVhckluTGlzdCAtPSAxMjtcbiAgICAgICAgdGhpcy5jb25zdHJ1Y3RZZWFyR3JpZCgpO1xuICAgIH1cblxuICAgIC8qKiBNZXRob2QgYWxsb3dpbmcgZm9jdXNpbmcgb24gZWxlbWVudHMgd2l0aGluIHRoaXMgY29tcG9uZW50LiAqL1xuICAgIGZvY3VzRWxlbWVudChlbGVtZW50U2VsZWN0b3I6IHN0cmluZyk6IHZvaWQge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnRUb0ZvY3VzOiBIVE1MRWxlbWVudCA9IHRoaXMuZVJlZi5uYXRpdmVFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJyMnICsgZWxlbWVudFNlbGVjdG9yKTtcbiAgICAgICAgICAgIGlmIChlbGVtZW50VG9Gb2N1cykge1xuICAgICAgICAgICAgICAgIHRoaXMuZVJlZi5uYXRpdmVFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJyMnICsgZWxlbWVudFNlbGVjdG9yKS5mb2N1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCAwKTtcbiAgICB9XG5cbiAgICAvKiogTWV0aG9kIHRoYXQgc2VuZHMgdGhlIHllYXIgdG8gdGhlIHBhcmVudCBjb21wb25lbnQgd2hlbiBpdCBpcyBjbGlja2VkLiAqL1xuICAgIHNlbGVjdFllYXIoc2VsZWN0ZWRZZWFyOiBudW1iZXIsIGV2ZW50PzogTW91c2VFdmVudCkge1xuICAgICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMueWVhclNlbGVjdGVkID0gc2VsZWN0ZWRZZWFyO1xuICAgICAgICB0aGlzLnllYXJDbGlja2VkLmVtaXQodGhpcy55ZWFyU2VsZWN0ZWQpO1xuICAgIH1cblxuICAgIGdldElkKHJvd0luZGV4OiBudW1iZXIsIGNvbEluZGV4OiBudW1iZXIpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gcm93SW5kZXggKiB0aGlzLl9hbW91bnRPZkNvbFBlclJvdyArIGNvbEluZGV4O1xuICAgIH1cblxuICAgIC8qKiBAaGlkZGVuICovXG4gICAgcHJpdmF0ZSBjb25zdHJ1Y3RZZWFyR3JpZCgpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgZGlzcGxheWVkWWVhcnNBbW91bnQ6IG51bWJlciA9IDEyO1xuICAgICAgICBjb25zdCBjYWxlbmRhclllYXJMaXN0ID0gW107XG4gICAgICAgIHRoaXMuY2FsZW5kYXJZZWFyTGlzdEdyaWQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCBkaXNwbGF5ZWRZZWFyc0Ftb3VudDsgKyt4KSB7XG4gICAgICAgICAgICBjYWxlbmRhclllYXJMaXN0LnB1c2godGhpcy5maXJzdFllYXJJbkxpc3QgKyB4KTtcbiAgICAgICAgfVxuICAgICAgICAvKiogQ3JlYXRpbmcgMmQgZ3JpZCAqL1xuICAgICAgICB3aGlsZSAoY2FsZW5kYXJZZWFyTGlzdC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuY2FsZW5kYXJZZWFyTGlzdEdyaWQucHVzaChjYWxlbmRhclllYXJMaXN0LnNwbGljZSgwLCB0aGlzLl9hbW91bnRPZkNvbFBlclJvdykpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWN0aXZlWWVhciA9IHRoaXMuZ2V0QWN0aXZlWWVhcigpO1xuICAgICAgICB0aGlzLmNoYW5nZURldGVjdG9yUmVmLm1hcmtGb3JDaGVjaygpO1xuICAgIH1cblxuICAgIC8qKiBSZXR1cm5zIHRyYW5zZm9ybWVkIDFkIGFycmF5IGZyb20gMmQgeWVhciBncmlkLiAqL1xuICAgIHByaXZhdGUgZ2V0WWVhckxpc3QoKTogbnVtYmVyW10ge1xuICAgICAgICByZXR1cm4gW10uY29uY2F0LmFwcGx5KFtdLCB0aGlzLmNhbGVuZGFyWWVhckxpc3RHcmlkKTtcbiAgICB9XG59XG4iXX0=